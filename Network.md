# 네트워크 (Network)
1. 컴퓨터 네트워크와 인터넷

1.1 인터넷 이란?

1.1.1 구성요소로 본 인터넷
- 종단 시스템 : 통신 링크와 패킷 스위치의 네트워크로 연결됨
  - ISP를 통해 인터넷 접속, 각 ISP는 패킷 스위치와 통신 링크로 이루어진 네트워크
  - ISP는 종단 시스템에게 다양한 네트워크 접속을 제공, 웹 사이트를 인터넷에 직접 연결하도록 CP에 인터넷 접속을 제공
  - 인터넷은 종단 시스템을 서로 연결하는 것이므로 종단 시스템에 접속을 제공하는 ISP들도 서로 연결되어야 함
- 패킷 스위치
  - 라우터 : 네트워크 코어에서 사용
  - 링크 계층 스위치 : 보통 액세스 네트워크에서 사용
  - 두 형태 스위치는 최종 목적지 방향으로 패킷을 전달 
1.1.2 서비스 측면에서 본 인터넷
- 애플리케이션에 서비스를 제공하는 인프라 구조서 인터넷을 기술 
- 인터넷 애플리케이션은 종단 시스템에서 수행
1.1.3 프로토콜
- 어떤 일을 수행하려면 둘 이상의 통신 개체가 함께 인식하는 프로토콜이 필요
- 프로토콜은 둘 이상의 통신 개체 간에 교환되는 메시지 포맷과 순서뿐 아니라, 메시지 송수신과 다른 이벤트에 따른 행동들을 정의

1.2 네트워크의 가장자리

1.2.1 접속 네트워크
- 종단 시스템을 그 종단 시스템으로부터 다른 먼 거리의 종단 시스템까지 경로상에 있는 첫 번째 라우터에 연결하는 네트워크
- 가정 접속(DSL, 케이블, FTTH, 다이얼-업 그리고 위성)    
  - DSL은 다운 스트림과 업 스트림의 전송 속도가 다르기 때문에 접속이 비대칭
  
    ![ex_screenshot](/res/nt1.png)
    - 텔코의 기존로컬 전화 기반 구조 이용
    - 스플리터는 가정에 도착하는 데이터와 전화 신호를 분리하고 데이터 신호를 DSL 모뎀으로 전송
    - 텔코 쪽의 CO에 있는 DSLAM은 데이터와 전화 신호르 분리하고 데이터를 인터넷으로 송신
  - 케이블 인터넷 접속은 케이블 TV 기반 구조 이용
  
    ![ex_screenshot](/res/nt2.png)
    - 케이블 모뎀이 필요하고 접속은 비대칭이며 다운 스트림 채널이 업스트림 채널보다 빠른 전송속도가 할당
    - CMTS는 DSL의 DSLAM과 유사한 기능을 제공
    - 공유 방송 매체라는 특성이 있다
    - 여러 사용자가 다운 스트림 채널에 동시 수신하면, 실제 수신율은 다운 스트림 전송률보다 작아짐
- 기업접속 (이더넷과 와이파이)
  - LAN은 일반적으로 종단 시스템을 가장자리 라우터에 연결하기 위해 사용
  - 이더넷은 이더넷 스위치와 연결하기 위해 꼬임쌍선을 이용하고 더 큰 인터넷으로 연결
  - 무선 랜 환경에서는 기업 네트워크에 연결된 AP로 패킷을 송/수신하고, AP는 유선 네트워크에 다시 연결, 사용자들은 AP의 수십m 반경 내에 있어야함.
- 광역 무선 접속(3G, LTE)
  - 이동 전화망 사업자들이 운영하는 기지국을 통해 패킷을 송수신하는 데 사용하는 것과 같은 무선 기반구조 채택
  - 와이파이와 달리 기지국의 수십km 반경 내에 있으면 됨
  
1.3 네트워크 코어

1.3.1 패킷 교환
- 패킷은 통신 링크와 패킷 스위치를 거치게 되며, 링크의 최대 전송속도와 같은 속도로 각 통신 링크상에서 전소오
- 패킷 스위치가 R bit/sec의 속도로 링크상에서 L bits 패킷 송신하면, 패킷을 전송하는 데 걸리는 시간은 L/R 초

- 저장 후 전달 : 스위치가 출력 링크로 패킷의 첫 비트를 전송하기 전에 전체 패킷을 받아야 함을 의미

  ![ex_screenshot](/res/nt3.png)
  - 라우터가 패킷의 모든 비트를 수신 후 출력 링크로 패킷을 전송하기 시작
  - 라우터는 입력되는 패킷을 출력 링크로 교환한다
  - d 종단간 지연 = N * L/R
  
- 큐잉 지연과 패킷 손실
  - 각 링크에 대해 패킷 스위치는 출력 버퍼를 갖고 있으며 송신하려는 패킷을 저장하고 있다
  - 도착하는 패킷이 왔을 때 다른 패킷이 전송 중이면 출력 버퍼에서 대기 => 큐잉 지연을 겪음
  - 큐잉 지연은 가변적이고 네트워크의 혼잡 정도에 따른다
  - 도착 시 다른 패킷으로 가득 차있을 경우 패킷 손실이 발생할 수 있다 => 도착 패킷 OR 대기 패킷을 폐기
  
  ![ex_screenshot](/res/nt4.png)
  
- 전달 테이블과 라우팅 프로토콜
  - 인터넷에서 모든 종단 시스템은 IP 주소를 갖는다
  - 소스 종단 시스템이 패킷을 목적 종단 시스템으로 보낼 때 소스는 패킷의 헤더에 목적지 IP 주소를 포함
  - 라우터는 패킷의 목적지 주소의 일부를 조사하고 패킷을 이웃 라우터로 전달
  - 각 라우터는 목적지 주소를 라우터의 출력 링크로 맵핑하는 전달 테이블을 랒고 있다
  - 패킷 라우터 도착 시, 라우터는 주소 조사후 목적지 주소를 이용해 전달 테이블을 검색하고 패킷을 출력 링크로 보냄

1.3.2 회선 교환
- 링크와 스위치의 네트워크를 통해 데이터를 이동시키는 방식 => 회선 교환, 패킷 교환
- 회선 교환은 종단 시스템 간 통신을 제공하기 위해 경로 상 필요 자원은 통신 세션 동안 예약
  - 정보 보내기 전 송,수신자 간 연결을 설정해야 한다
  - 송,수신자 간의 경로에 있는 스위치들이 해당 연결 상태를 유지해야 하는 연결(회선)
  - 연결이 이루어지는 동안 네트워크 링크에 일정한 전송률을 예약한다
  - 송신자는 수신자에게 보장된 일정 전송률로 데이터를 보낼 수 있다
- 패킷 교환은 자원을 예약하지 않음
  - 링크중 하나가 혼잡하다면 송신 쪽 버퍼에서 기다려야하고 지연이 발생
  - 일정 시간 내에 전달하는 것을 보장하지 않음

1.4 패킷 교환 네트워크에서 지연, 손실과 처리율

1.4.1 패킷 교환 네트워크에서의 지연 개요 
- 처리 지연 : 패킷 헤더를 조사하고 패킷을 어디로 보낼 지 결정하는 시간
- 큐잉 지연 : 큐에 저장되어 링크로 전송되기를 기다리는 다른 패킷 수에 의해 결정된다
- 전송 지연 : 패킷의 모든 비트를 링크로 밀어내는 데 필요한 시간(L/R -> 패킷 길이/전송률), 라우터가 패킷을 내보내는 데 필요한 시간 
- 전파 지연 : 링크의 처음부터 라우터까지 전파에 필요한 시간 (d/s -> 라우터 간 거리 / 링크 전파 속도), 한 라우터에서 다음라우터로 전파되는 데 걸리는 시간 
- 전체 노드 지연 = 처리 지연 + 큐잉 지연 + 전송 지연 + 전파 지연 

1.4.2 큐잉 지연과 패킷 손실
- R: 전송률, L: 패킷 길이, a: 패킷이 큐에 도착하는 평균율 -> La/R : 비트가 큐에 도착하는 평균율 
- 트랙픽 강도(La/R)은 큐잉 지연 정도를 측정하는 데 매우 중요
- La/R > 1이면, 큐는 끝없이 증가하고 큐잉 지연은 무한대에 도달
- La/R <=1
  - 주기적 도착 -> 큐잉 지연 없음
  - 몰려서 도착 -> 상당한 평균 큐잉 지연 발생 
- 패킷을 저장할 수 없는 경우 패킷을 버리게 된다, 손실 패킷의 비율은 트래픽 강도가 클수록 증가

1.4.3 종단 간 지연
- 종단 간 지연 = N(처리 지연 + 전송 지연 + 전파 지연)

1.4.4 컴퓨터 네트워크에서 처리율 
- 병목 링크의 전송률이 처리율 ( 여러개 링크로 구성된 경우 가장 작은 값의 전송률이 처리율이 된다 )

1.5 프로토콜 계층과 서비스 모델 
  
  ![ex_screenshot](/res/nt5.png)
  ![ex_screenshot](/res/nt6.png)

- 애플리케이션 계층 : 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳
  - HTTP, SMTP, FTP 등 많은 프로토콜 포함
  - 정보 패킷 : 메시지
- 트랜스포트 계층 : 클라이언트와 서버 간 애플리케이션 계층 메시지를 전송하는 서비스 제공
  - TCP : 연결지향형 서비스 제공, 메시지의 전달 보장과 흐름제어 포함 
  - UDP : 비연결형 서비스 제공. 신뢰성, 흐름제어, 혼잡제어를 제공하지 않는 간단한 서비스 
  - 정보 패킷 : 세그먼트
- 네트워크 계층 : 한 호스트에서 다른 호스트로 데이터그램을 라우팅하는 책임을 진다.
  - 출발지 트랜스포트 계층에서 목적지 트랜스포트 계층까지 세그먼트를 운반하는 서비스 제공
  - IP 프로토콜
  - 출발지와 목적지 사이에서 데이터그램이 이동하는 경로를 결정하는 라우팅 프로토콜을 포함
  - 정보 패킷 : 데이터그램
- 링크 계층
  - 네트워크 계층은 출발지와 목적지 간 패킷 스위치를 통해 데이터그램을 라우트 한다
  - 경로상 한 노드에서 다른 노드로 패킷을 이동하기 위해 네트워크 계층은 링크 계층 서비스에 의존해야 한다.
  - 패킷 : 프레임
- 물리 계층
  - 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동하는 것이 기능이다.
  - 실제 전송 매체에 의존한다.
- OSI 모델
  - 프레젠테이션 계층 : 통신하는 애플리케이션들이 교환되는 데이터의 의미를 해석하도록 하는 서비스 제공
    - 데이터 압축, 데이터 암호화를 포함
  - 세션 계층 : 데이터 교환의 경계와 동기화를 제공하는데, 체킹포인트와 회복 방법을 세우는 수단을 포함

1.6 공격받는 네트워크
- 나쁜 친구들은 인터넷을 통해 당신의 호스트에 맬웨어를 침투시킬 수 있다.
  - 맬웨어는 사적인 정보를 모으는 스파이 웨어를 설치해 정보를 모아 나쁜 친구들에게 다시 보낸다.
    - 면역되지 않는 호스트는 비슷한 면역되지 않는 장치들로 구성된 네트워크(봇넷)에 등록 될 수 있다.
    - 목표로 하는 호스트에 대해 스팸 전자메일 분배 OR 분산 DoS 공격을 위해 봇넷을 제어하고 이용한다.
  - 맬웨어는 자기복제를 한다 -> 바이러스 OR 웜의 형태로 퍼질 수 있다.
  - 웜은 사용자의 직접적인 상호작용 없이 장치에 침투하는 맬웨어이다. 
- 나쁜 친구들은 서버와 네트워크 기반구조를 공격할 수 있다.
  - DoS 공격은 네트워크, 호스트 OR 다른 기본구조의 요소들을 정상적인 사용자들이 사용할 수 없게 하는 것
    - 취약성 공격 : 목표 호스트에서 수행되는 공격받기 쉬운 애플리케이션or운영체제에 교묘한 메시지를 보내는 것을 포함하고 서비스가 중단되거나 호스트가 멈출 수 있다.
    - 대역폭 플러딩 : 목표 호스트의 접속 링크가 동작하지 못하게 많은 패킷을 보내 정당 패킷이 서버에 도달하지 못하도록 한다.
    - 연결 플러딩 : 목표 호스트에 반열림 or 전열림된 tcp연결을 설정 -> 호스트는 가짜 연결을 처리하느라 정상적인 연결을 받아들이는 것을 중단하게 된다.
- 나쁜 친구들은 패킷을 탐지할 수 있다.
  - 수동적인 수신자를 무선 전송장치 근처에 두어 전송되는 모든 패킷의 사본을 얻을 수 있다.
  - 패킷에는 민감한 정보를 포함할 수 있다
  - 지나가는 모든 패킷의 사본을 기록하는 수동적인 수신자를 패킷 스니퍼라 한다.
- 나쁜 친구들은 당신이 신뢰하는 사람인 것처럼 위장할 수 있다.
  - IP 스푸핑 : 거짓 출발지 주소를 가진 패킷을 인터넷으로 보내는 능력 -> 한 사용자가 다른 사용자인 것처럼 행동
  -> 이 문제를 해결하기위해 종단 인증 방법이 필요하다. 

2. 애플리케이션 계층

2.1 네트워크 애플리케이션의 원리

2.1.1 네트워크 애플리케이션 구조
- 클라이언트/서버 구조
  - 항상 켜져 있는 호스트 -> 서버
  - 클라이언트라는 다른 많은 호스트의 요청을 받는다
  - 서버가 고정 IP 주소라는 잘 알려진 주소를 갖는다
  - 서버는 항상 동작하므로 클라이언트는 서버 주소로 패킷을 보내 항상 서버에 연결할 수 있다
  - 웹, 파일 전송, 원격 로그인, 전자메일
- P2P 구조
  - 항상 켜져있는 기반구조 서버에 최소로 의존
  - 애플리케이션은 피어라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하도록 한다
  - 트래픽 집중적인 애플리케이션들이 사용
  - 자가 확장성
    - 각 피어들은 or 파일을 다른 피어들에게 분배함으로써 서비스 능력을 추가
  - 비요 효율적
    - 상당한 서버 기반구조와 서버 대역폭을 요구하지 않음
  - 세가지 주요 과제
    - ISP 우호적 
      - 대부분 가정 ISP들은 '비대칭' 대역폭 방식을 제공
      - 업스트릶 트래픽보다 다운스트림 트래픽에 대역폭을 더 많이 제공
      - ISP에 상당한 부하를 야기한다
    - 보안
      - 고도의 분산 및 개방성으로 인해 P2P 응용은 보안에 문제를 야기할 수 있다
    - 보상
      - P2P 응용의 성공은 응요에 대역폭, 저장 장치, 계산 자원을 자발적으로 제공하도록 사용자들을 설득해야한다
  
2.1.2 프로세스 간 통신
- 2개의 다른 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메시지 교환으로 서로 통신
- 클라이언트와 서버 프로세스
  - 웹 애플리케이션에서 클라이언트 브라우저 프로세스는 웹 서버 프로세스와 메시지를 교환한다
  - P2P 파일 공유 시스템에서는 한 피어의 프로세스에서 다른 피어의 프로세스로 파일을 전송
  - P2P 파일 공유에서 파일을 내려받는 피어를 클라이언트, 파일을 올리는 피어를 서버라 한다
  - 두 프로세스 간의 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스 -> 클라이언트
  - 세션을 시작하기 위해 접속을 기다리는 프로세스 -> 서버
  
- 프로세스와 컴퓨터 네트워크 사이의 인터페이스
  - 프로세스는 소켓을 통해 네트워크로 메시지를 보내고 받는다
  - 소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
  - 소켓은 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스 -> 애플리케이션과 네트워크 사이의 API
  
- 주소화 프로세스
  - 한 호스트상에서 수행되고 있는 프로세스가 패킷을 다른 호스트에서 수행되고 있는 프로세스로 패킷을 보내기 위해 수신 프로세스가 주소를 갖고 있을 필요가 있다
  - 수신 프로세스를 식별하기 위해 호스트의 주소와 목적지 호스트 내의 수신 프로세스를 명시하는 식별자가 명시될 필요가 있다
  - 인터넷에서 호스트는 IP 주소로 식별된다
  - 목적지 포트번호는 수신 호스트에 있는 프로세스 식별에 사용된다
  ![ex_screenshot](/res/nt7.png) 
  
2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
- 많은 네트워크들은 하나 이상의 트랜스포트 프로토콜을 제공한다
- 트랜스포트 계층 프로토콜이 그것을 이용하는 애플리케이션에게 제공할 수 있는 서비스
  - 신뢰적 데이터 전송
    - 프로토콜이 보장된 데이터 전송 서비스를 제공한다면 이를 신뢰적 데이터 전송을 제공한다고 한다
    - 트랜스포트 계층 프로토콜이 애플리케이션에 제공할 수 있는 주요 서비스는 프로세스 간 신뢰적 데이터 전송
    - 송신 프로세스는 데이터를 소켓으로 보내고 데이터가 오류 없이 수신 프로세스에 도착할 것이라는 확신을 갖는다
    - 손실 허용 애플리케이션 : 신뢰적 데이터 전송을 제공하지 않는 경우
  - 처리량
    - 두 프로세스 간 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
    - 어느 명시된 속도에서 보장된 가용 처리율을 제공한다는 것(r bps의 보장된 처리율을 보장한다) -> 트랜스포트 프로토콜이 제공할 수 있는 서비스
    - 대역폭 민감 애플리케이션 : 처리율 요구사항을 갖는 애플리케이션
      - 멀티미디어 애플리케이션은 대역폭에 민감
    - 융통성 있는 애플리케이션 : 있는 대로 융통적으로 처리할 수 있는 애플리케이션
      - 전자메일, 파일, 웹 전송 등
  - 시간
    - 시간 보장을 제공할 수 있다
  - 보안 
    - 하나 이상의 보안 서비스를 제공할 수 있다
    - 송신 프로세스가 전송하는 모든 데이터를 암호화 할 수 있고, 수신 프로세스로 전달 전 데이터의 암호를 해독할 수 있다
    - 두 프로세스 사이에 비밀성을 제공한다
    
2.1.4 인터넷 전송 프로토콜이 제공하는 서비스
- 인터넷은 애플리케이션에게 2개의 전송 프로토콜, 즉 UDP/TCP를 제공한다
- TCP 서비스 : 연결 지향형 서비스와 신뢰적인 데이터 전송 서비스 포함
  - 연결 지향형 서비스
    - 애플리케이션 계층이 메시지를 전송하기 전 TCP를 클라이언트와 서버가 서로 전송 제어 정보를 교환하도록 한다
    - 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도달할 것이니 준비하라고 알려주는 역할 수행
    - 핸드셰이킹 단계를 지나면 TCP 연결이 두 프로세스의 소켓 사이에 존재 (전이중 연결)
    - 메시지 전송을 마치면 연결을 끊어야 한다
  - 신뢰적인 데이터 전송 서비스
    - 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존한다
    - TCP는 바이트 스트림을 소켓으로 전달하면 손실하거나 중복되지 않게 수신 소켓으로 전달한다
    - TCP는 혼잡제어 방식, 인터넷의 전체 성능 향상을 위한 서비스를 포함한다 -> 네트워크가 혼잡상태에 이르면 프로세스는 속도를 낮춘다
- UDP 서비스
  - 비연결형이므로 두 프로세스가 통신 전 핸드셰이킹 하지 않는다
  - 비신뢰적인 데이터 전송 서비스를 제공한다 -> 수신 소켓에 도착하는 메시지들의 순서가 뒤바뀔 수 있다
  - UDP는 혼잡제어 방식을 포함하지 않는다
  
2.1.5 애플리케이션 계층 프로토콜
- 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의
  - 교환 메시지 타입(요청 메시지와 응답 메시지)
  - 여러 메시지 타입의 문법
  - 필드의 의미
  - 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙
- HTTP는 브라우저와 웹 서버 사이에서 교환되는 메시지의 포맷과 순서를 정의한다

2.2 웹과 HTTP

2.2.1 HTTP 개요
- 서로 다른 종단 시스템에서 수행되는 클라이언트와 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다
- HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 저으이하고 있다
- 웹 페이지는 객체들로 구성된다
  - 객체는 단일 URL로 지정할 수 있는 하나의 파일
- 대부분 웹페이지는 기본 HTML파일과 여러 참조 객체로 구성
- 기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조
  - 각 URL은 2개의 요소, 즉 ' 객체를 갖고 있는 서버 호스트 네임', '객체 경로 이름'을 갖고 있다
  - http://www.someSchool.edu/someDepartment/picture.gif
  -       호스트 네임          경로 이름
- HTTP의 서버 측을 구현하는 웹 서버는 URL로 각각 지정할 수 있는 웹 객체를 갖고 있다 
- HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다
- 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다
- 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다
- HTTP는 TCP를 전송 프로토콜로 사용한다
  - HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작
  - 연결되면 브라우저와 서버 프로세스는 소켓 인터페이스를 통해 TCP로 접속
  - 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고 소켓 인터페이스로부터 HTTP응답 메시지를 받는다
  - HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다
- HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로, HTTP를 비상태 프로토콜이라고 한다

2.2.2 비지속 연결과 지속 연결
- 비지속 연결 HTTP
  - ex) http://www.someSchool.edu/someDepartment/home.index
  - HTTP 클라이언트는 HTTP의 기본 포트번호 80을 통해 www.someSchool.edu 서버로 TCP 연결을 시도
  - HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다
    - 이 요청 메시지는 /someDepartment/home.index 경로 이름을 포함
  - HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받는다
    - 저장 장치로부터 /someDepartment/home.index 객체를 추출
    - HTTP 응답 메시지에 객체를 캡슐화하여 소켓을 통해 클라이언트로 보낸다
  - HTTP 서버는 TCP에게 TCP 연결을 끊으라 한다
  - HTTP 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단
    - 클라이언트는 응답 메시지로 부터 파일을 추출하고 HTML을 조사하고 10개의 JPGE 객체에 대한 참조를 찾는다
    - 이후 참조되는 각 JPEG 객체에 대해 처음 4단계를 반복
  - 서버가 객체를 보낸후 각 TCP 연결이 끊어지므로 비지속 연결을 사용하고 있다 
  - 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송한다
  ![ex_screenshot](/res/nt8.png)
  - 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어 한다
    - TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다
  - 연결 설정, 핸드셰이킹 하는 시간이 필요
- 지속 연결 http
  - 서버는 응답을 보낸후 TCP 연결을 그대로 유지한다
  - 같은 클라이언트와 서버 간 이후 요청과 응답은 같은 연결을 통해 보내진다
  - HTTP 서버는 일정 기간 사용되지 않으면 연결을 닫는다

2.2.3 HTTP 메시지 포맷
- HTTP 요청 메시지
  - 메시지가 일반 ASCII 텍스트로 쓰여 사람들이 읽을 수 있다
  - 메시지가 다섯줄로 되어 있고 각 줄은 CR, LF로 구별
  - 마지막 줄에 추가 CR, LF가 따른다
  - 요청 메시지의 첫 줄은 요청 라인, 이후를 헤더 라인이라 부름
  - 요청라인은 '방식 필드', 'URL 필드', 'HTTP 버전 필드'를 갖는다
  - 방식 필드는 GET, POST, HEAD, PUT, DELETE를 포함하는 여러 가지 값을 가질 수 있다
    - GET 방식은 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용
  - 헤더 라인에는 개체가 존재하는 호스트를 명시하고 있다
    - Connection : close -> 지속 연결 사용을 원하지 않음
    - Accept-language : fr -> 사용자가 객체의 프랑스 버전을 원함
  - 개체 몸체
    - GET 방식에서는 비어있고 POST 방식에 사용
  - HTTP 클라이언트는 사용자가 폼을 채원 넣을 때 POST 방식을 사용
  - HEAD 방식은 GET과 유사
    - 서버가 HEAD 방식의 요청을 받으면 HTTP 메시지로 응답하는데 요청 객체는 보내지 않는다
    - 디버깅 용도로 많이 사용
  - PUT 방식은 웹 서버에 업로드할 객체를 필요로하는 애플리케이션에 의해 사용
  - DELETE 방식은 사용자 or 애플리케이션이 웹 서버에 있는 객체를 지우는 것 허용
  
  ![ex_screenshot](/res/nt9.png) 
  
- HTTP 응답 메시지
  - 초기 상태 라인, 6개 헤더라인, 개체 몸체로 이루어짐
  - 상태라인은 버전 필드, 상태코드, 상태 메시지로 구성 
    - HTTP/1.1 200 OK
    - 상태 코드 
      - 200 OK -> 요청 성공, 정보가 응답으로 보내짐
      - 301 Moved Permanently -> 요청 객체가 영원히 이동, 새로운 URL은 응답 메시지의 Location 헤더에 있음
      - 400 Bad Request -> 서버가 요청을 이해할 수 없다는 오류 코드
      - 404 Not Found -> 요청문서가 서버에 존재하지 않음
      - 505 HTTP Version Not Supported -> 요청 HTTP 프로토콜 버전을 서버가 지원하지 않음
  - 헤더라인
    - Connection : close -> TCP 연결 닫을 때 사용
    - Data -> HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타냄
    - Server 
    - Last-Modified -> 객체가 생성되거나 마지막으로 수정된 날짜
    - Content-Length -> 송신되는 객체의 바이트 수
    - Content-Type -> 객체 타입을 나타냄
  ![ex_screenshot](/res/nt10.png)
  
2.2.4 사용자와 서버 간의 상호작용 : 쿠키
- HTTP는 쿠리를 사용
  - 사이트가 사용자를 추적하도록 해준다
- 쿠키의 네가지 요소
  - HTTP 응답 메시지 쿠키 헤더 라인
  - HTTP 요청 메시지 쿠키 헤더 라인
  - 사용자 브라우저에 사용자 종단 시스템과 관리를 지속 시키는 쿠키 파일
  - 백 엔드 데이터베이스
  
![ex_screenshot](/res/nt11.png) 
  - 요청이 들어올 때 서버는 유일한 식별번호를 만들고 식별번호로 인덱스되는 백엔드 데이터베이스 안에 엔트리를 만듬
- 쿠키는 사용자 식별에 사용할 수 있음
- 처음 방문 시 사용자는 사용자 확인을 제공 
- 브라우저는 서버에 쿠키 헤더를 전달해 서버에게 사용자를 확인한다
- 쿠키는 비상태 HTTP 위에서 사용자 세션 계층을 생성하는데 이용될 수 있다

2.2.5 웹 캐싱
- 기점 웹 서버를 대신해 HTTP 요구를 충족시키는 네트워크 개체
  - 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존
- 동작 과정
  - 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보냄
  - 웹 캐시는 객체의 사본이 지역적으로 저장되어 있는지 확인, 저장되어 있으면 웹 캐시는 클라이언트 브라우저로 HTTP 응답 메시지와 객체를 전송
  - 웹 캐시가 객체를 가지고 있지 않다면 웹 캐시는 기점 서버로 TCP 연결 설정
    - 웹 캐시는 캐시와 서버간 TCP 연결로 객체에 대한 HTTP 요청을 보냄
    - 요청 받은 후 기점 서버는 웹 캐시로 HTTP 응답 메시지와 객체를 보냄
  - 웹 캐시의 객체를 수신할 때, 객체를 지역 저장 장치에 복사하고 클라리언트 브라우저에 HTTP 응답 메시지와 객체의 사본을 보냄
- 웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다
  - 클라이언트와 기점 서버 사이 병목 대역폭이 클라이언트와 캐시 사이 병목 대역폭에 비해 매우 작을 때 효과적
- 웹 캐시는 인터넷으로의 기관 접속 회선상의 웹 트래픽을 실질적으로 줄일 수 있다
- 웹 캐시를 가진 고밀도 인터넷은 비록 콘텐츠 제공자가 저속도의 접속 회선을 가진 느린 서버에서 자신의 사이트를 운영하더라도 빠른 콘텐츠 분배를 위한 기반 구조를 제공

2.2.6 조건부 GET
- HTTP는 클라이언트가 브라우저로 전달되는 모든 객체들이 최신의 것임을 확인하며 캐싱하도록 해주는 방식을 갖는다
- 조건부 GET
  - HTTP 요청 메시지가 GET 방식을 사용하고 If-Modified-Since 헤더라인을 포함
- 동작 과정
  - 브라우저의 요청 대신 프록시 캐시는 요청 메시지를 웹 서버로 보냄
  - 웹 서버는 캐시에게 객체를 가진 응답 서버를 보냄
    - 캐시는 요청하는 브라우저에게 객체를 보내 주고 자신에게도 객체를 저장
    - 마지막으로 수정된 날짜를 함께 저장
  - 다른 날, 다른 브라우저가 같은 객체를 캐시에게 요청하면 객체는 여전히 저장
    - 이전에 웹서버에서 수정되었으므로 브라우저는 조건부 GET으로 갱신 조사 수행
    - If-Modified-since 헤더 라인 값이 전에 보낸 Last-Modified 헤더 라인 값과 일치하는지 비교
    - 조건부 GET은 서버에게 객체가 명시된 날짜 이후 수정된 경우에만 그 객체를 보낼 것
  - 웹 서버는 클라이언트에게 응답 메시지를 보냄
    - Not Modified를 보냄 -> 캐시된 복사본을 사용하라는 의미

2.3 파일전송 : FTP
- 일반 FTP 세션에서 사용자는 호스트 앞에 앉아 있고 원격 호스트 or 원격 호스트로부터 파일을 전송하기 원한다
- 원격 계정에 접속하기위해 사용자는 사용자 계정과 비밀번호를 제공해야 한다

![ex_screenshot](/res/nt12.png)
- 사용자는 원격호스트의 호스트 네임을 제공해 로컬 호스트에 있는 FTP 클라이언트 프로세스가 원격 호스트에 있는 FTP 서버 프로세스와 TCP 연결을 설정하게 함
- 사용자는 FTP 명령으로 TCP 연결을 통해 전해진는 사용자 계정과 비밀번호를 제공
- 서버가 사용자를 확인하면 사용자는 로컬 파일에 저장된 여러 파일을 원격 파일 시스템 or 반대쪽으로 복사한다

- HTTP와 FTP는 모두 파일 전송 프로토콜
- HTTP와 FTP의 차이점
  - FTP가 한 파일을 전송하는 데 두 TCP 연결, 제어 연결과 데이터 연결을 동시 사용
    - 제어 연결은 두 호스트 간에 제어 정보 (사용자 계정, 비밀번호, 원격 디렉토리 변경, 파일 보내고 가져오는 명령)를 보내는 데 사용
    - 데이터 연결은 실제 파일을 보내는데 사용
  - FTP는 별도 제어 연결을 사용하므로 FTP는 제어 정보를 아웃 밴드로 보낸다 표현
  - HTTP는 인 밴드로 보낸다 표현
- 제어 연결과 데이터 연결
  - FTP는 서버의 21번 포트로 TCP 연결 설정
  - FTP의 클라이언트측은 제어 연결을 통해 사용자 계정과 비밀번호를 보냄
  - 서버 측은 제어 연결상 파일 전송을 위한 명령을 받으면 클라이언트 측에게 TCP 데이터 연결을 초기화
  - FTP는 데이터 연결을 통해 한 파일만 전송하고 연결을 닫음
  - 같은 세션 기간에 다른 파일 전송 시 FTP는 다른 데이터 연결을 개통
  - FTP는 제어 연결은 사용자 세션 시간 동안 계속 연결되어 있으나, 세견의 각 파일이 전송 될 때마다 새로운 데이터 연결이 생성
- FTP 서버는 사용자에 대한 상태를 유지해야 한다
  - 서버는 제어 연결을 특정 사용자 계정과 연계해야 하고 사용자의 현재 디렉터리를 추적해야 한다
- HTTP는 사용자 상태를 유지할 필요가 없는 비상태 유지 애플리케이션이다

2.4 인터넷 전자 메일 

![ex_screenshot](/res/nt13.png)
- 사용자 에이전트, 메일 서버, SMTP라는 3개의 주요 요소가 있다
- 사용자 에이전트는 사용자가 메시지를 읽고, 응답하고, 전잘하고, 저장하고, 구성하게 해준다
- 사용자 에이전트는 메시지를 메일 서버로 보내고, 메시지는 메일 서버의 출력 메시지 큐에 들어간다
  - 수신자가 읽고 싶을 때, 그의 사용자 에이전트는 메일 서버에 있는 메일 박스에서 메시지를 가져옴
- 메일 서버는 전자 메일 기반 구조의 중심을 형성한다
  - 메일 서버안에 메일 박스를 가지고 있다
  - 메일박스는 메시지를 유지하고 관리한다
  - 메일 서버는 사용자 계정과 비밀번호를 이용해 사용자를 인증한다
- 송신자의 메일 서버는 수신자의 메일 서버 고장에도 대처해야 한다
  - 전달할 수 없다면 송신자 서버는 메시지를 메시지큐에 보관하고 나중에 전달 시도를 수행한다(재시도는 30분 마다 수행)
  - 여러 시도에도 성공하지 못하면 서버는 메시지를 제거하고 송신자에게 전자메일로 이를 통보
- SMTP는 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜
  - TCP의 신뢰적 데이터 전송 서비스를 이용
  - 송신자 메일 서버에서 수행하는 클라이언트, 수신자 메일 서버에서 수행하는 서버를 가진다

2.4.1 SMTP
- 송신자의 메일 서버로부터 수신자의 메일 서버로 메시지를 전송한다
- 기본 동작
  ![ex_screenshot](/res/nt12.png)
- 클라이언트 SMTP는 서버 SMTP의 25번 포트로 TCP 연결을 설정
- 연결이 설정되면 서버와 클라이언트는 애플리케이션 계층 핸드셰이킹 수행
- SMTP 핸드셰이킹 과정 동안 SMTP 클라이언트는 송신자의 전자메일 주소와 수신자의 전자메일 주소를 제공
  - 소개를 마치면 클라이언트로 메시지를 보냄
- SMTP는 서버에 오류 없이 메시지를 전달하기 위해 TCP의 신뢰적인 데이터 전송 서비스에 의존한다
  - 다른 보낼 메시지가 있으면 같은 TCP 연결 상에서 반복, 없으면 닫을 것을 명령
- SMTP는 지속 연결을 사용한다

2.4.2 HTTP와 비교
- HTTP는 웹 서버로부터 웹 사용자 에이전트로 파일을 전송
- SMTP는 한 메일 서버로부터 다른 메일 서버로 파일을 전송
- 둘 모두 지속 연결을 사용
- HTTP는 원칙적으로 PULL 프로토콜
  - 누군가 서버에 정보를 올리고 사용자가 편의에 의해 서버로부터 정보를 가져오기 위해 HTTP를 사용
  - TCP 연결은 파일을 수신할 컴퓨터가 먼저 초기화
- SMTP는 원칙적으로 PUSH 프로토콜
  - 송신 메일 서버가 파일을 수신 메일 서버로 보낸다
  - TCP 연결은 파일을 보내는 컴퓨터에서 먼저 초기화
- SMTP는 각 메시지가 7비트 ASCII 포맷일 것을 요구, 다른 문자가 포함된 경우 ASCII 포맷으로 인코딩 되어야 함
- HTTP는 이러한 제한이 없다
- HTTP는 자신의 HTTP 응답 메시지에 각 객체를 캡슐화한다
- SMTP은 모든 메시지의 객체를 한 메시지로 만든다

2.4.4 메일 접속 프로토콜


