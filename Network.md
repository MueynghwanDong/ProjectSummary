# 네트워크 (Network)
1. 컴퓨터 네트워크와 인터넷

1.1 인터넷 이란?

1.1.1 구성요소로 본 인터넷
- 종단 시스템 : 통신 링크와 패킷 스위치의 네트워크로 연결됨
  - ISP를 통해 인터넷 접속, 각 ISP는 패킷 스위치와 통신 링크로 이루어진 네트워크
  - ISP는 종단 시스템에게 다양한 네트워크 접속을 제공, 웹 사이트를 인터넷에 직접 연결하도록 CP에 인터넷 접속을 제공
  - 인터넷은 종단 시스템을 서로 연결하는 것이므로 종단 시스템에 접속을 제공하는 ISP들도 서로 연결되어야 함
- 패킷 스위치
  - 라우터 : 네트워크 코어에서 사용
  - 링크 계층 스위치 : 보통 액세스 네트워크에서 사용
  - 두 형태 스위치는 최종 목적지 방향으로 패킷을 전달 
1.1.2 서비스 측면에서 본 인터넷
- 애플리케이션에 서비스를 제공하는 인프라 구조서 인터넷을 기술 
- 인터넷 애플리케이션은 종단 시스템에서 수행
1.1.3 프로토콜
- 어떤 일을 수행하려면 둘 이상의 통신 개체가 함께 인식하는 프로토콜이 필요
- 프로토콜은 둘 이상의 통신 개체 간에 교환되는 메시지 포맷과 순서뿐 아니라, 메시지 송수신과 다른 이벤트에 따른 행동들을 정의

1.2 네트워크의 가장자리

1.2.1 접속 네트워크
- 종단 시스템을 그 종단 시스템으로부터 다른 먼 거리의 종단 시스템까지 경로상에 있는 첫 번째 라우터에 연결하는 네트워크
- 가정 접속(DSL, 케이블, FTTH, 다이얼-업 그리고 위성)    
  - DSL은 다운 스트림과 업 스트림의 전송 속도가 다르기 때문에 접속이 비대칭
  
    ![ex_screenshot](/res/nt1.png)
    - 텔코의 기존로컬 전화 기반 구조 이용
    - 스플리터는 가정에 도착하는 데이터와 전화 신호를 분리하고 데이터 신호를 DSL 모뎀으로 전송
    - 텔코 쪽의 CO에 있는 DSLAM은 데이터와 전화 신호르 분리하고 데이터를 인터넷으로 송신
  - 케이블 인터넷 접속은 케이블 TV 기반 구조 이용
  
    ![ex_screenshot](/res/nt2.png)
    - 케이블 모뎀이 필요하고 접속은 비대칭이며 다운 스트림 채널이 업스트림 채널보다 빠른 전송속도가 할당
    - CMTS는 DSL의 DSLAM과 유사한 기능을 제공
    - 공유 방송 매체라는 특성이 있다
    - 여러 사용자가 다운 스트림 채널에 동시 수신하면, 실제 수신율은 다운 스트림 전송률보다 작아짐
- 기업접속 (이더넷과 와이파이)
  - LAN은 일반적으로 종단 시스템을 가장자리 라우터에 연결하기 위해 사용
  - 이더넷은 이더넷 스위치와 연결하기 위해 꼬임쌍선을 이용하고 더 큰 인터넷으로 연결
  - 무선 랜 환경에서는 기업 네트워크에 연결된 AP로 패킷을 송/수신하고, AP는 유선 네트워크에 다시 연결, 사용자들은 AP의 수십m 반경 내에 있어야함.
- 광역 무선 접속(3G, LTE)
  - 이동 전화망 사업자들이 운영하는 기지국을 통해 패킷을 송수신하는 데 사용하는 것과 같은 무선 기반구조 채택
  - 와이파이와 달리 기지국의 수십km 반경 내에 있으면 됨
  
1.3 네트워크 코어

1.3.1 패킷 교환
- 패킷은 통신 링크와 패킷 스위치를 거치게 되며, 링크의 최대 전송속도와 같은 속도로 각 통신 링크상에서 전소오
- 패킷 스위치가 R bit/sec의 속도로 링크상에서 L bits 패킷 송신하면, 패킷을 전송하는 데 걸리는 시간은 L/R 초

- 저장 후 전달 : 스위치가 출력 링크로 패킷의 첫 비트를 전송하기 전에 전체 패킷을 받아야 함을 의미

  ![ex_screenshot](/res/nt3.png)
  - 라우터가 패킷의 모든 비트를 수신 후 출력 링크로 패킷을 전송하기 시작
  - 라우터는 입력되는 패킷을 출력 링크로 교환한다
  - d 종단간 지연 = N * L/R
  
- 큐잉 지연과 패킷 손실
  - 각 링크에 대해 패킷 스위치는 출력 버퍼를 갖고 있으며 송신하려는 패킷을 저장하고 있다
  - 도착하는 패킷이 왔을 때 다른 패킷이 전송 중이면 출력 버퍼에서 대기 => 큐잉 지연을 겪음
  - 큐잉 지연은 가변적이고 네트워크의 혼잡 정도에 따른다
  - 도착 시 다른 패킷으로 가득 차있을 경우 패킷 손실이 발생할 수 있다 => 도착 패킷 OR 대기 패킷을 폐기
  
  ![ex_screenshot](/res/nt4.png)
  
- 전달 테이블과 라우팅 프로토콜
  - 인터넷에서 모든 종단 시스템은 IP 주소를 갖는다
  - 소스 종단 시스템이 패킷을 목적 종단 시스템으로 보낼 때 소스는 패킷의 헤더에 목적지 IP 주소를 포함
  - 라우터는 패킷의 목적지 주소의 일부를 조사하고 패킷을 이웃 라우터로 전달
  - 각 라우터는 목적지 주소를 라우터의 출력 링크로 맵핑하는 전달 테이블을 랒고 있다
  - 패킷 라우터 도착 시, 라우터는 주소 조사후 목적지 주소를 이용해 전달 테이블을 검색하고 패킷을 출력 링크로 보냄

1.3.2 회선 교환
- 링크와 스위치의 네트워크를 통해 데이터를 이동시키는 방식 => 회선 교환, 패킷 교환
- 회선 교환은 종단 시스템 간 통신을 제공하기 위해 경로 상 필요 자원은 통신 세션 동안 예약
  - 정보 보내기 전 송,수신자 간 연결을 설정해야 한다
  - 송,수신자 간의 경로에 있는 스위치들이 해당 연결 상태를 유지해야 하는 연결(회선)
  - 연결이 이루어지는 동안 네트워크 링크에 일정한 전송률을 예약한다
  - 송신자는 수신자에게 보장된 일정 전송률로 데이터를 보낼 수 있다
- 패킷 교환은 자원을 예약하지 않음
  - 링크중 하나가 혼잡하다면 송신 쪽 버퍼에서 기다려야하고 지연이 발생
  - 일정 시간 내에 전달하는 것을 보장하지 않음

1.4 패킷 교환 네트워크에서 지연, 손실과 처리율

1.4.1 패킷 교환 네트워크에서의 지연 개요 
- 처리 지연 : 패킷 헤더를 조사하고 패킷을 어디로 보낼 지 결정하는 시간
- 큐잉 지연 : 큐에 저장되어 링크로 전송되기를 기다리는 다른 패킷 수에 의해 결정된다
- 전송 지연 : 패킷의 모든 비트를 링크로 밀어내는 데 필요한 시간(L/R -> 패킷 길이/전송률), 라우터가 패킷을 내보내는 데 필요한 시간 
- 전파 지연 : 링크의 처음부터 라우터까지 전파에 필요한 시간 (d/s -> 라우터 간 거리 / 링크 전파 속도), 한 라우터에서 다음라우터로 전파되는 데 걸리는 시간 
- 전체 노드 지연 = 처리 지연 + 큐잉 지연 + 전송 지연 + 전파 지연 

1.4.2 큐잉 지연과 패킷 손실
- R: 전송률, L: 패킷 길이, a: 패킷이 큐에 도착하는 평균율 -> La/R : 비트가 큐에 도착하는 평균율 
- 트랙픽 강도(La/R)은 큐잉 지연 정도를 측정하는 데 매우 중요
- La/R > 1이면, 큐는 끝없이 증가하고 큐잉 지연은 무한대에 도달
- La/R <=1
  - 주기적 도착 -> 큐잉 지연 없음
  - 몰려서 도착 -> 상당한 평균 큐잉 지연 발생 
- 패킷을 저장할 수 없는 경우 패킷을 버리게 된다, 손실 패킷의 비율은 트래픽 강도가 클수록 증가

1.4.3 종단 간 지연
- 종단 간 지연 = N(처리 지연 + 전송 지연 + 전파 지연)

1.4.4 컴퓨터 네트워크에서 처리율 
- 병목 링크의 전송률이 처리율 ( 여러개 링크로 구성된 경우 가장 작은 값의 전송률이 처리율이 된다 )

1.5 프로토콜 계층과 서비스 모델 
  
  ![ex_screenshot](/res/nt5.png)
  ![ex_screenshot](/res/nt6.png)

- 애플리케이션 계층 : 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳
  - HTTP, SMTP, FTP 등 많은 프로토콜 포함
  - 정보 패킷 : 메시지
- 트랜스포트 계층 : 클라이언트와 서버 간 애플리케이션 계층 메시지를 전송하는 서비스 제공
  - TCP : 연결지향형 서비스 제공, 메시지의 전달 보장과 흐름제어 포함 
  - UDP : 비연결형 서비스 제공. 신뢰성, 흐름제어, 혼잡제어를 제공하지 않는 간단한 서비스 
  - 정보 패킷 : 세그먼트
- 네트워크 계층 : 한 호스트에서 다른 호스트로 데이터그램을 라우팅하는 책임을 진다.
  - 출발지 트랜스포트 계층에서 목적지 트랜스포트 계층까지 세그먼트를 운반하는 서비스 제공
  - IP 프로토콜
  - 출발지와 목적지 사이에서 데이터그램이 이동하는 경로를 결정하는 라우팅 프로토콜을 포함
  - 정보 패킷 : 데이터그램
- 링크 계층
  - 네트워크 계층은 출발지와 목적지 간 패킷 스위치를 통해 데이터그램을 라우트 한다
  - 경로상 한 노드에서 다른 노드로 패킷을 이동하기 위해 네트워크 계층은 링크 계층 서비스에 의존해야 한다.
  - 패킷 : 프레임
- 물리 계층
  - 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동하는 것이 기능이다.
  - 실제 전송 매체에 의존한다.
- OSI 모델
  - 프레젠테이션 계층 : 통신하는 애플리케이션들이 교환되는 데이터의 의미를 해석하도록 하는 서비스 제공
    - 데이터 압축, 데이터 암호화를 포함
  - 세션 계층 : 데이터 교환의 경계와 동기화를 제공하는데, 체킹포인트와 회복 방법을 세우는 수단을 포함

1.6 공격받는 네트워크
- 나쁜 친구들은 인터넷을 통해 당신의 호스트에 맬웨어를 침투시킬 수 있다.
  - 맬웨어는 사적인 정보를 모으는 스파이 웨어를 설치해 정보를 모아 나쁜 친구들에게 다시 보낸다.
    - 면역되지 않는 호스트는 비슷한 면역되지 않는 장치들로 구성된 네트워크(봇넷)에 등록 될 수 있다.
    - 목표로 하는 호스트에 대해 스팸 전자메일 분배 OR 분산 DoS 공격을 위해 봇넷을 제어하고 이용한다.
  - 맬웨어는 자기복제를 한다 -> 바이러스 OR 웜의 형태로 퍼질 수 있다.
  - 웜은 사용자의 직접적인 상호작용 없이 장치에 침투하는 맬웨어이다. 
- 나쁜 친구들은 서버와 네트워크 기반구조를 공격할 수 있다.
  - DoS 공격은 네트워크, 호스트 OR 다른 기본구조의 요소들을 정상적인 사용자들이 사용할 수 없게 하는 것
    - 취약성 공격 : 목표 호스트에서 수행되는 공격받기 쉬운 애플리케이션or운영체제에 교묘한 메시지를 보내는 것을 포함하고 서비스가 중단되거나 호스트가 멈출 수 있다.
    - 대역폭 플러딩 : 목표 호스트의 접속 링크가 동작하지 못하게 많은 패킷을 보내 정당 패킷이 서버에 도달하지 못하도록 한다.
    - 연결 플러딩 : 목표 호스트에 반열림 or 전열림된 tcp연결을 설정 -> 호스트는 가짜 연결을 처리하느라 정상적인 연결을 받아들이는 것을 중단하게 된다.
- 나쁜 친구들은 패킷을 탐지할 수 있다.
  - 수동적인 수신자를 무선 전송장치 근처에 두어 전송되는 모든 패킷의 사본을 얻을 수 있다.
  - 패킷에는 민감한 정보를 포함할 수 있다
  - 지나가는 모든 패킷의 사본을 기록하는 수동적인 수신자를 패킷 스니퍼라 한다.
- 나쁜 친구들은 당신이 신뢰하는 사람인 것처럼 위장할 수 있다.
  - IP 스푸핑 : 거짓 출발지 주소를 가진 패킷을 인터넷으로 보내는 능력 -> 한 사용자가 다른 사용자인 것처럼 행동
  -> 이 문제를 해결하기위해 종단 인증 방법이 필요하다. 

2. 애플리케이션 계층

2.1 네트워크 애플리케이션의 원리

2.1.1 네트워크 애플리케이션 구조
- 클라이언트/서버 구조
  - 항상 켜져 있는 호스트 -> 서버
  - 클라이언트라는 다른 많은 호스트의 요청을 받는다
  - 서버가 고정 IP 주소라는 잘 알려진 주소를 갖는다
  - 서버는 항상 동작하므로 클라이언트는 서버 주소로 패킷을 보내 항상 서버에 연결할 수 있다
  - 웹, 파일 전송, 원격 로그인, 전자메일
- P2P 구조
  - 항상 켜져있는 기반구조 서버에 최소로 의존
  - 애플리케이션은 피어라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하도록 한다
  - 트래픽 집중적인 애플리케이션들이 사용
  - 자가 확장성
    - 각 피어들은 or 파일을 다른 피어들에게 분배함으로써 서비스 능력을 추가
  - 비요 효율적
    - 상당한 서버 기반구조와 서버 대역폭을 요구하지 않음
  - 세가지 주요 과제
    - ISP 우호적 
      - 대부분 가정 ISP들은 '비대칭' 대역폭 방식을 제공
      - 업스트릶 트래픽보다 다운스트림 트래픽에 대역폭을 더 많이 제공
      - ISP에 상당한 부하를 야기한다
    - 보안
      - 고도의 분산 및 개방성으로 인해 P2P 응용은 보안에 문제를 야기할 수 있다
    - 보상
      - P2P 응용의 성공은 응요에 대역폭, 저장 장치, 계산 자원을 자발적으로 제공하도록 사용자들을 설득해야한다
  
2.1.2 프로세스 간 통신
- 2개의 다른 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메시지 교환으로 서로 통신
- 클라이언트와 서버 프로세스
  - 웹 애플리케이션에서 클라이언트 브라우저 프로세스는 웹 서버 프로세스와 메시지를 교환한다
  - P2P 파일 공유 시스템에서는 한 피어의 프로세스에서 다른 피어의 프로세스로 파일을 전송
  - P2P 파일 공유에서 파일을 내려받는 피어를 클라이언트, 파일을 올리는 피어를 서버라 한다
  - 두 프로세스 간의 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스 -> 클라이언트
  - 세션을 시작하기 위해 접속을 기다리는 프로세스 -> 서버
  
- 프로세스와 컴퓨터 네트워크 사이의 인터페이스
  - 프로세스는 소켓을 통해 네트워크로 메시지를 보내고 받는다
  - 소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
  - 소켓은 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스 -> 애플리케이션과 네트워크 사이의 API
  
- 주소화 프로세스
  - 한 호스트상에서 수행되고 있는 프로세스가 패킷을 다른 호스트에서 수행되고 있는 프로세스로 패킷을 보내기 위해 수신 프로세스가 주소를 갖고 있을 필요가 있다
  - 수신 프로세스를 식별하기 위해 호스트의 주소와 목적지 호스트 내의 수신 프로세스를 명시하는 식별자가 명시될 필요가 있다
  - 인터넷에서 호스트는 IP 주소로 식별된다
  - 목적지 포트번호는 수신 호스트에 있는 프로세스 식별에 사용된다
  ![ex_screenshot](/res/nt7.png) 
  
2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
- 많은 네트워크들은 하나 이상의 트랜스포트 프로토콜을 제공한다
- 트랜스포트 계층 프로토콜이 그것을 이용하는 애플리케이션에게 제공할 수 있는 서비스
  - 신뢰적 데이터 전송
    - 프로토콜이 보장된 데이터 전송 서비스를 제공한다면 이를 신뢰적 데이터 전송을 제공한다고 한다
    - 트랜스포트 계층 프로토콜이 애플리케이션에 제공할 수 있는 주요 서비스는 프로세스 간 신뢰적 데이터 전송
    - 송신 프로세스는 데이터를 소켓으로 보내고 데이터가 오류 없이 수신 프로세스에 도착할 것이라는 확신을 갖는다
    - 손실 허용 애플리케이션 : 신뢰적 데이터 전송을 제공하지 않는 경우
  - 처리량
    - 두 프로세스 간 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
    - 어느 명시된 속도에서 보장된 가용 처리율을 제공한다는 것(r bps의 보장된 처리율을 보장한다) -> 트랜스포트 프로토콜이 제공할 수 있는 서비스
    - 대역폭 민감 애플리케이션 : 처리율 요구사항을 갖는 애플리케이션
      - 멀티미디어 애플리케이션은 대역폭에 민감
    - 융통성 있는 애플리케이션 : 있는 대로 융통적으로 처리할 수 있는 애플리케이션
      - 전자메일, 파일, 웹 전송 등
  - 시간
    - 시간 보장을 제공할 수 있다
  - 보안 
    - 하나 이상의 보안 서비스를 제공할 수 있다
    - 송신 프로세스가 전송하는 모든 데이터를 암호화 할 수 있고, 수신 프로세스로 전달 전 데이터의 암호를 해독할 수 있다
    - 두 프로세스 사이에 비밀성을 제공한다
    
2.1.4 인터넷 전송 프로토콜이 제공하는 서비스
- 인터넷은 애플리케이션에게 2개의 전송 프로토콜, 즉 UDP/TCP를 제공한다
- TCP 서비스 : 연결 지향형 서비스와 신뢰적인 데이터 전송 서비스 포함
  - 연결 지향형 서비스
    - 애플리케이션 계층이 메시지를 전송하기 전 TCP를 클라이언트와 서버가 서로 전송 제어 정보를 교환하도록 한다
    - 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도달할 것이니 준비하라고 알려주는 역할 수행
    - 핸드셰이킹 단계를 지나면 TCP 연결이 두 프로세스의 소켓 사이에 존재 (전이중 연결)
    - 메시지 전송을 마치면 연결을 끊어야 한다
  - 신뢰적인 데이터 전송 서비스
    - 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존한다
    - TCP는 바이트 스트림을 소켓으로 전달하면 손실하거나 중복되지 않게 수신 소켓으로 전달한다
    - TCP는 혼잡제어 방식, 인터넷의 전체 성능 향상을 위한 서비스를 포함한다 -> 네트워크가 혼잡상태에 이르면 프로세스는 속도를 낮춘다
- UDP 서비스
  - 비연결형이므로 두 프로세스가 통신 전 핸드셰이킹 하지 않는다
  - 비신뢰적인 데이터 전송 서비스를 제공한다 -> 수신 소켓에 도착하는 메시지들의 순서가 뒤바뀔 수 있다
  - UDP는 혼잡제어 방식을 포함하지 않는다
  
2.1.5 애플리케이션 계층 프로토콜
- 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의
  - 교환 메시지 타입(요청 메시지와 응답 메시지)
  - 여러 메시지 타입의 문법
  - 필드의 의미
  - 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙
- HTTP는 브라우저와 웹 서버 사이에서 교환되는 메시지의 포맷과 순서를 정의한다

2.2 웹과 HTTP

2.2.1 HTTP 개요
- 서로 다른 종단 시스템에서 수행되는 클라이언트와 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다
- HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 저으이하고 있다
- 웹 페이지는 객체들로 구성된다
  - 객체는 단일 URL로 지정할 수 있는 하나의 파일
- 대부분 웹페이지는 기본 HTML파일과 여러 참조 객체로 구성
- 기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조
  - 각 URL은 2개의 요소, 즉 ' 객체를 갖고 있는 서버 호스트 네임', '객체 경로 이름'을 갖고 있다
  - http://www.someSchool.edu/someDepartment/picture.gif
  -       호스트 네임          경로 이름
- HTTP의 서버 측을 구현하는 웹 서버는 URL로 각각 지정할 수 있는 웹 객체를 갖고 있다 
- HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다
- 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다
- 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다
- HTTP는 TCP를 전송 프로토콜로 사용한다
  - HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작
  - 연결되면 브라우저와 서버 프로세스는 소켓 인터페이스를 통해 TCP로 접속
  - 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고 소켓 인터페이스로부터 HTTP응답 메시지를 받는다
  - HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다
- HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로, HTTP를 비상태 프로토콜이라고 한다

2.2.2 비지속 연결과 지속 연결
- 비지속 연결 HTTP
  - ex) http://www.someSchool.edu/someDepartment/home.index
  - HTTP 클라이언트는 HTTP의 기본 포트번호 80을 통해 www.someSchool.edu 서버로 TCP 연결을 시도
  - HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다
    - 이 요청 메시지는 /someDepartment/home.index 경로 이름을 포함
  - HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받는다
    - 저장 장치로부터 /someDepartment/home.index 객체를 추출
    - HTTP 응답 메시지에 객체를 캡슐화하여 소켓을 통해 클라이언트로 보낸다
  - HTTP 서버는 TCP에게 TCP 연결을 끊으라 한다
  - HTTP 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단
    - 클라이언트는 응답 메시지로 부터 파일을 추출하고 HTML을 조사하고 10개의 JPGE 객체에 대한 참조를 찾는다
    - 이후 참조되는 각 JPEG 객체에 대해 처음 4단계를 반복
  - 서버가 객체를 보낸후 각 TCP 연결이 끊어지므로 비지속 연결을 사용하고 있다 
  - 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송한다
  ![ex_screenshot](/res/nt8.png)
  - 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어 한다
    - TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다
  - 연결 설정, 핸드셰이킹 하는 시간이 필요
- 지속 연결 http
  - 서버는 응답을 보낸후 TCP 연결을 그대로 유지한다
  - 같은 클라이언트와 서버 간 이후 요청과 응답은 같은 연결을 통해 보내진다
  - HTTP 서버는 일정 기간 사용되지 않으면 연결을 닫는다

2.2.3 HTTP 메시지 포맷
- HTTP 요청 메시지
  - 메시지가 일반 ASCII 텍스트로 쓰여 사람들이 읽을 수 있다
  - 메시지가 다섯줄로 되어 있고 각 줄은 CR, LF로 구별
  - 마지막 줄에 추가 CR, LF가 따른다
  - 요청 메시지의 첫 줄은 요청 라인, 이후를 헤더 라인이라 부름
  - 요청라인은 '방식 필드', 'URL 필드', 'HTTP 버전 필드'를 갖는다
  - 방식 필드는 GET, POST, HEAD, PUT, DELETE를 포함하는 여러 가지 값을 가질 수 있다
    - GET 방식은 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용
  - 헤더 라인에는 개체가 존재하는 호스트를 명시하고 있다
    - Connection : close -> 지속 연결 사용을 원하지 않음
    - Accept-language : fr -> 사용자가 객체의 프랑스 버전을 원함
  - 개체 몸체
    - GET 방식에서는 비어있고 POST 방식에 사용
  - HTTP 클라이언트는 사용자가 폼을 채원 넣을 때 POST 방식을 사용
  - HEAD 방식은 GET과 유사
    - 서버가 HEAD 방식의 요청을 받으면 HTTP 메시지로 응답하는데 요청 객체는 보내지 않는다
    - 디버깅 용도로 많이 사용
  - PUT 방식은 웹 서버에 업로드할 객체를 필요로하는 애플리케이션에 의해 사용
  - DELETE 방식은 사용자 or 애플리케이션이 웹 서버에 있는 객체를 지우는 것 허용
  
  ![ex_screenshot](/res/nt9.png) 
  
- HTTP 응답 메시지
  - 초기 상태 라인, 6개 헤더라인, 개체 몸체로 이루어짐
  - 상태라인은 버전 필드, 상태코드, 상태 메시지로 구성 
    - HTTP/1.1 200 OK
    - 상태 코드 
      - 200 OK -> 요청 성공, 정보가 응답으로 보내짐
      - 301 Moved Permanently -> 요청 객체가 영원히 이동, 새로운 URL은 응답 메시지의 Location 헤더에 있음
      - 400 Bad Request -> 서버가 요청을 이해할 수 없다는 오류 코드
      - 404 Not Found -> 요청문서가 서버에 존재하지 않음
      - 505 HTTP Version Not Supported -> 요청 HTTP 프로토콜 버전을 서버가 지원하지 않음
  - 헤더라인
    - Connection : close -> TCP 연결 닫을 때 사용
    - Data -> HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타냄
    - Server 
    - Last-Modified -> 객체가 생성되거나 마지막으로 수정된 날짜
    - Content-Length -> 송신되는 객체의 바이트 수
    - Content-Type -> 객체 타입을 나타냄
  ![ex_screenshot](/res/nt10.png)
  
2.2.4 사용자와 서버 간의 상호작용 : 쿠키
- HTTP는 쿠리를 사용
  - 사이트가 사용자를 추적하도록 해준다
- 쿠키의 네가지 요소
  - HTTP 응답 메시지 쿠키 헤더 라인
  - HTTP 요청 메시지 쿠키 헤더 라인
  - 사용자 브라우저에 사용자 종단 시스템과 관리를 지속 시키는 쿠키 파일
  - 백 엔드 데이터베이스
  
![ex_screenshot](/res/nt11.png) 
  - 요청이 들어올 때 서버는 유일한 식별번호를 만들고 식별번호로 인덱스되는 백엔드 데이터베이스 안에 엔트리를 만듬
- 쿠키는 사용자 식별에 사용할 수 있음
- 처음 방문 시 사용자는 사용자 확인을 제공 
- 브라우저는 서버에 쿠키 헤더를 전달해 서버에게 사용자를 확인한다
- 쿠키는 비상태 HTTP 위에서 사용자 세션 계층을 생성하는데 이용될 수 있다

2.2.5 웹 캐싱
- 기점 웹 서버를 대신해 HTTP 요구를 충족시키는 네트워크 개체
  - 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존
- 동작 과정
  - 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보냄
  - 웹 캐시는 객체의 사본이 지역적으로 저장되어 있는지 확인, 저장되어 있으면 웹 캐시는 클라이언트 브라우저로 HTTP 응답 메시지와 객체를 전송
  - 웹 캐시가 객체를 가지고 있지 않다면 웹 캐시는 기점 서버로 TCP 연결 설정
    - 웹 캐시는 캐시와 서버간 TCP 연결로 객체에 대한 HTTP 요청을 보냄
    - 요청 받은 후 기점 서버는 웹 캐시로 HTTP 응답 메시지와 객체를 보냄
  - 웹 캐시의 객체를 수신할 때, 객체를 지역 저장 장치에 복사하고 클라리언트 브라우저에 HTTP 응답 메시지와 객체의 사본을 보냄
- 웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다
  - 클라이언트와 기점 서버 사이 병목 대역폭이 클라이언트와 캐시 사이 병목 대역폭에 비해 매우 작을 때 효과적
- 웹 캐시는 인터넷으로의 기관 접속 회선상의 웹 트래픽을 실질적으로 줄일 수 있다
- 웹 캐시를 가진 고밀도 인터넷은 비록 콘텐츠 제공자가 저속도의 접속 회선을 가진 느린 서버에서 자신의 사이트를 운영하더라도 빠른 콘텐츠 분배를 위한 기반 구조를 제공

2.2.6 조건부 GET
- HTTP는 클라이언트가 브라우저로 전달되는 모든 객체들이 최신의 것임을 확인하며 캐싱하도록 해주는 방식을 갖는다
- 조건부 GET
  - HTTP 요청 메시지가 GET 방식을 사용하고 If-Modified-Since 헤더라인을 포함
- 동작 과정
  - 브라우저의 요청 대신 프록시 캐시는 요청 메시지를 웹 서버로 보냄
  - 웹 서버는 캐시에게 객체를 가진 응답 서버를 보냄
    - 캐시는 요청하는 브라우저에게 객체를 보내 주고 자신에게도 객체를 저장
    - 마지막으로 수정된 날짜를 함께 저장
  - 다른 날, 다른 브라우저가 같은 객체를 캐시에게 요청하면 객체는 여전히 저장
    - 이전에 웹서버에서 수정되었으므로 브라우저는 조건부 GET으로 갱신 조사 수행
    - If-Modified-since 헤더 라인 값이 전에 보낸 Last-Modified 헤더 라인 값과 일치하는지 비교
    - 조건부 GET은 서버에게 객체가 명시된 날짜 이후 수정된 경우에만 그 객체를 보낼 것
  - 웹 서버는 클라이언트에게 응답 메시지를 보냄
    - Not Modified를 보냄 -> 캐시된 복사본을 사용하라는 의미

2.3 파일전송 : FTP
- 일반 FTP 세션에서 사용자는 호스트 앞에 앉아 있고 원격 호스트 or 원격 호스트로부터 파일을 전송하기 원한다
- 원격 계정에 접속하기위해 사용자는 사용자 계정과 비밀번호를 제공해야 한다

![ex_screenshot](/res/nt12.png)
- 사용자는 원격호스트의 호스트 네임을 제공해 로컬 호스트에 있는 FTP 클라이언트 프로세스가 원격 호스트에 있는 FTP 서버 프로세스와 TCP 연결을 설정하게 함
- 사용자는 FTP 명령으로 TCP 연결을 통해 전해진는 사용자 계정과 비밀번호를 제공
- 서버가 사용자를 확인하면 사용자는 로컬 파일에 저장된 여러 파일을 원격 파일 시스템 or 반대쪽으로 복사한다

- HTTP와 FTP는 모두 파일 전송 프로토콜
- HTTP와 FTP의 차이점
  - FTP가 한 파일을 전송하는 데 두 TCP 연결, 제어 연결과 데이터 연결을 동시 사용
    - 제어 연결은 두 호스트 간에 제어 정보 (사용자 계정, 비밀번호, 원격 디렉토리 변경, 파일 보내고 가져오는 명령)를 보내는 데 사용
    - 데이터 연결은 실제 파일을 보내는데 사용
  - FTP는 별도 제어 연결을 사용하므로 FTP는 제어 정보를 아웃 밴드로 보낸다 표현
  - HTTP는 인 밴드로 보낸다 표현
- 제어 연결과 데이터 연결
  - FTP는 서버의 21번 포트로 TCP 연결 설정
  - FTP의 클라이언트측은 제어 연결을 통해 사용자 계정과 비밀번호를 보냄
  - 서버 측은 제어 연결상 파일 전송을 위한 명령을 받으면 클라이언트 측에게 TCP 데이터 연결을 초기화
  - FTP는 데이터 연결을 통해 한 파일만 전송하고 연결을 닫음
  - 같은 세션 기간에 다른 파일 전송 시 FTP는 다른 데이터 연결을 개통
  - FTP는 제어 연결은 사용자 세션 시간 동안 계속 연결되어 있으나, 세견의 각 파일이 전송 될 때마다 새로운 데이터 연결이 생성
- FTP 서버는 사용자에 대한 상태를 유지해야 한다
  - 서버는 제어 연결을 특정 사용자 계정과 연계해야 하고 사용자의 현재 디렉터리를 추적해야 한다
- HTTP는 사용자 상태를 유지할 필요가 없는 비상태 유지 애플리케이션이다

2.4 인터넷 전자 메일 

![ex_screenshot](/res/nt13.png)
- 사용자 에이전트, 메일 서버, SMTP라는 3개의 주요 요소가 있다
- 사용자 에이전트는 사용자가 메시지를 읽고, 응답하고, 전잘하고, 저장하고, 구성하게 해준다
- 사용자 에이전트는 메시지를 메일 서버로 보내고, 메시지는 메일 서버의 출력 메시지 큐에 들어간다
  - 수신자가 읽고 싶을 때, 그의 사용자 에이전트는 메일 서버에 있는 메일 박스에서 메시지를 가져옴
- 메일 서버는 전자 메일 기반 구조의 중심을 형성한다
  - 메일 서버안에 메일 박스를 가지고 있다
  - 메일박스는 메시지를 유지하고 관리한다
  - 메일 서버는 사용자 계정과 비밀번호를 이용해 사용자를 인증한다
- 송신자의 메일 서버는 수신자의 메일 서버 고장에도 대처해야 한다
  - 전달할 수 없다면 송신자 서버는 메시지를 메시지큐에 보관하고 나중에 전달 시도를 수행한다(재시도는 30분 마다 수행)
  - 여러 시도에도 성공하지 못하면 서버는 메시지를 제거하고 송신자에게 전자메일로 이를 통보
- SMTP는 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜
  - TCP의 신뢰적 데이터 전송 서비스를 이용
  - 송신자 메일 서버에서 수행하는 클라이언트, 수신자 메일 서버에서 수행하는 서버를 가진다

2.4.1 SMTP
- 송신자의 메일 서버로부터 수신자의 메일 서버로 메시지를 전송한다
- 기본 동작

- 클라이언트 SMTP는 서버 SMTP의 25번 포트로 TCP 연결을 설정
- 연결이 설정되면 서버와 클라이언트는 애플리케이션 계층 핸드셰이킹 수행
- SMTP 핸드셰이킹 과정 동안 SMTP 클라이언트는 송신자의 전자메일 주소와 수신자의 전자메일 주소를 제공
  - 소개를 마치면 클라이언트로 메시지를 보냄
- SMTP는 서버에 오류 없이 메시지를 전달하기 위해 TCP의 신뢰적인 데이터 전송 서비스에 의존한다
  - 다른 보낼 메시지가 있으면 같은 TCP 연결 상에서 반복, 없으면 닫을 것을 명령
- SMTP는 지속 연결을 사용한다

2.4.2 HTTP와 비교
- HTTP는 웹 서버로부터 웹 사용자 에이전트로 파일을 전송
- SMTP는 한 메일 서버로부터 다른 메일 서버로 파일을 전송
- 둘 모두 지속 연결을 사용
- HTTP는 원칙적으로 PULL 프로토콜
  - 누군가 서버에 정보를 올리고 사용자가 편의에 의해 서버로부터 정보를 가져오기 위해 HTTP를 사용
  - TCP 연결은 파일을 수신할 컴퓨터가 먼저 초기화
- SMTP는 원칙적으로 PUSH 프로토콜
  - 송신 메일 서버가 파일을 수신 메일 서버로 보낸다
  - TCP 연결은 파일을 보내는 컴퓨터에서 먼저 초기화
- SMTP는 각 메시지가 7비트 ASCII 포맷일 것을 요구, 다른 문자가 포함된 경우 ASCII 포맷으로 인코딩 되어야 함
- HTTP는 이러한 제한이 없다
- HTTP는 자신의 HTTP 응답 메시지에 각 객체를 캡슐화한다
- SMTP은 모든 메시지의 객체를 한 메시지로 만든다

2.4.4 메일 접속 프로토콜

![ex_screenshot](/res/nt14.png)
- 메일 서버는 보통 사용자들과 공유하고 전형적으로 사용자의 ISP들이 유지 관리한다
- 송신자의 사용자 에이전트는 수신자의 메일 서버로 직접 대화하지 않는다
- 송신자의 메일 서버는 SMTP를 사용해 수신자의 메일 서버로 전자메일 메시지를 중계한다
  - 송신자 메일 서버로 중계하지 않으면 송신자의 사용자 에이전트는 목적지 메일 서버로 도달할 수 없다
- 수신자의 사용자 에이전트는 메시지를 얻기 위해 SMTP를 사용할 수 없다
  - SMTP가 푸시 프로토콜인 반면 메시지를 얻는 것은 풀 동작이기 때문

- POP3
  - 간단하고 아주 한정된 기능을 가진다
  - 사용자 에이전트가 메일 서버의 포트 110번으로 TCP 연결을 열 때 시작한다
  - TCP 연결이 설정돠면 POP3는 3단계 과정으로 진행
    - 인증 : 사용자 에이전트는 메일을 다운로드하는 사용자를 인증하기 위해 사용자 이름과 비밀번호를 보낸다
    - 트랜잭션 : 사용자 에이전트는 메시지를 가져오고 삭제를 위해 메시지를 표시하거나 그 삭제 표시를 지울 수 있으며, 메일 통계를 얻을 수 있다
    - 갱신 : 클라이언트가 POP3 세션을 끝내는 quit 명령이 내려진 후 일어난다, 메일서버는 삭제 포시된 메시지를 삭제한다
  - 응답
    - +OK : 서버 이전 명령을 잘 처리했다는 것을 나타낸다
    - -ERR :  이전 명령에 무언가 잘못 되었다는 것을 나타내는 데 서버가 사용된다
  - 인증
    - user <사용자 이름>
    - pass <비밀번호>
  - 사용자 에이전트와 메일 서버 사이의 POP3 세션 시간 동안 POP3 서버는 여러 상태 정보를 유지한다
    - 어느 메시지가 삭제 표시가 되었는지 유지한다
    - POP3 서버는 세션 사이의 상태 정보를 전달하지 않는다
  - 사용자에게 원격 폴더를 생성하거나 폴더에 메시지를 할당하는 수단을 제공하지 않는다
- IMAP
  - 서버는 폴더에 각각 메시지를 연결한다
  - 메시지가 서버에 도착하면 수신자의 INBOX 폴더와 연결
  - 수신자는 메시지를 생성한 새 폴더로 옮기거나 읽거나 삭제할 수 있다
  - IMAP 프로토콜은 사용자가 폴더를 생성하고 하나의 폴더에서 다른 폴더로 메시지를 옮기는 명령을 제공한다
  - 특정 조건에 맞는 원격 폴더를 찾는 명령도 제공한다
  - IMAP 서버는 IMAP 세션을 통해 사용자 상태 정보를 유지한다
  - 사용자 에이전트가 메시지의 구성요소를 얻을 수 있게 허용하는 명령을 갖는다는 것
    - 메시지의 메시지 헤더만 얻거나, 멀티파트 MIME 메시지의 일부만 얻을 수도 있다
    
2.5 DNS-인터넷의 디렉터리 서비스
- 호스트에 한 하나의 식별자는 호스트 네임이다
  - 호스트 네임은 인터넷에서의 호스트 위치에 대한 정보를 거의 제공하지 않는다
  - 호스트 네임은 가변 길이로 라우터가 처리하는데 어려움이 있다
- 호스트는 IP주소로도 식별된다
- IP 주소는 계층구조여서 주소를 왼쪽에서 오른쪽으로 조사함으로써, 그 호스타가 인터넷의 어디에 위치하는지에 대한 자세한 정보를 얻을 수 있다

2.5.1 DNS가 제공하는 서비스
- 라우터는 고정 길이의 계층구조를 가진 IP주소를 좋아한다
- 호스트 네임을 IP주소로 변환해 주는 디렉터리 서비스가 필요하다
- DNS
  - DNS 서버들의 계층구조로 구현된 분산 데이터 베이스
  - 호스트가 분산 데이터베이스롤 질의하도록 허락하는 애플리케이션 계층 프로토콜
- DNS 프로토콜은 UDP 상에서 수행되고 포트 53번을 이용한다
- DNS는 다른 애플리케이션 프로토콜들이 HTTP, SMTP, FTP 등 사용자가 제공한 호스트 네임을 IP주소로 변환하기 위해 주로 이용한다
- 동작 과정
  - 같은 사용자 컴퓨터는 DNS 애플리케이션 클라이언트 측을 수행
  - 브라우저는 URL로부터 호스트 네임을 추출하고 호스트 네임을 DNS 애플리케이션의 클라이언트 측에 넘김
  - DNS 클라이언트는 DNS 서버로 호스트 네임을 포함하는 질의를 보낸다
  - DNS 클라이언트는 궁극적으로 호스트 네임에 대한 IP주소를 가진 응답을 받는다
  - 브라우저가 DNS로부터 IP주소를 받으면, 브라우저는 그 IP주소의 80번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결을 초기화 한다
- IP 주소는 가까운 DNS 서버에 캐시되어 있어 평균 DNS 지연뿐 아니라 DNS 네트워크 트래픽 감소에 도움을 준다

- 호스트 에일리어싱 
  - 복잡한 호스트 네임을 가진 호스트는 하나 이상의 별명을 가질 수 있다
  - 별칭 호스트 네임에 대한 정식 호스트 네임을 얻기 위해 이용될 수 있다
- 메일 서버 에일리어싱
  - DNS는 호스트의 IP주소뿐 아니라 제공된 별칭 호스트 네임에 대한 정식 호스트 네임을 얻기 위해 메일 애플리케이션에 의해 수행된다
- 부하 분산
  - 여러 중복 서버 사이 부하를 분산하기 위해 사용되고 있다
  - 각 서버가 다른 종단 시스템에서 수행되고 다른 IP주소를 갖는다
  - 중복 웹 서버의 경우, 여러 IP 주소가 하나의 정식 호스트 네임과 연관되어 있다
  - DNS 데이터베이스는 이 IP 주소 집합을 갖고 있다
  - 클라이언트가 주소 집합으로 매핑하는 호스트 네임에 대한 DNS를 질의하면 서버는 IP 주소 집합 전체를 가지고 응답한다
  - 각 응답에서 주소 순서는 매번 회전한다
  - 클라이언트는 주소 집합 내부의 첫 IP주소로 HTTP 요청을 보내므로 DNS 회전은 여러 중복 서버들 사이 트래픽을 분산하는 효과를 낸다
  - DNS 회전은 여러 메일 서버가 동일 별칭을 가질 수 있다

2.5.2 DNS 동작 원리 개요
- 사용자 호스트 DNS는 네트워크에 질의 메시지를 보낸다
- 모든 DNS 질의와 응답 메시지는 포트 53의 UDP 데이터그램으로 보내진다
- 분산 계층 데이터베이스
  ![ex_screenshot](/res/nt15.png)
  - 루트 DNS 서버
    - 각 서버는 보안과 신뢰를 목적으로 복사된 서버들의 클러스터
  - 최상위 레벨 도메인 네임(TLD) DNS 서버
    - com, org. net 등과 같은 상위 레벨 도메인과 kr, uk 등 국가의 상위 레벨 도메인에 대한 책임이 있다
  - 책임 DNS 서버
    - 인터넷에 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 네임을 IP주소로 매핑하도록한다
    - 접근이 쉬운 DNS 레코드를 제공해야 하며 기관의 책임 DNS 서버는 이 DNS 레코드를 갖는다
  - 상호 작용 과정
    - 클라이언트는 루트 서버 중 하나에 접속
    - 루트 서버는 최상위 레벨 도미인을 갖는 TLD 서버에 IP 주소를 보냄
    - 클라이언트는 이 TLD 서버 중 하나에 접속
    - 서버는 도메인을 가진 책임 서버의 IP주소를 보낸다
    - 클라이언트는 도메인의 책임 서버 중 하나로 접속
    - 서버는 호스트 네임의 IP주소를 보낸다
  - 로컬 DNS 서버
    - ISP는 로컬 DNS 서버를 갖는다
    - ISP는 로컬 DNS 서버로부터 IP주소를 호스트에게 제공
    - 호스트가 DNS 질의를 보내면 질의는 먼저 프록시로 동작하는 로컬 DNS 서버로 전달, 로컬 DNS 서버는 질의를 DNS 서버계층으로 전달  
    ![ex_screenshot](/res/nt16.png)
- DNS 캐싱
  - DNS 메시지 수를 줄이기 위해 캐싱을 사용
  - DNS 서버가 응답을 받았을 때 로컬 메모리에 응답에 대한 정보를 저장할 수 있다
  - DNS서버는 어떤 기간 이후 저장된 정보를 제거한다
  - 호스트 네임과 IP주소 쌍이 DNS 서버에 저장되고 다른 호스트 네임으로부터 같은 질의가 도착한다면 DNS서버는 원하는 IP 주소를 제공할 수 있다
2.5.3 DNS 레코드와 메시지
- DNS 서버들은 호스트 네임을 IP주소로 매핑하기 위해 자원 레코드를 저장한다
- 각 DNS는 하나 이상의 자원 레코드를 가진 메시지로 응답한다
- 4개의 투플로 구성(Name, Value, Type, TTL)
  - TTL : 자원 레코드 생존 기간
  - Type = A 이면, NAME은 호스트 네임, Value는 호스트 네임에 대한 IP주소 ->  Type A레코드는 표준 호스트 네임의 IP주소 매핑을 제공한다
  - Type = NS이면, Name은 도메인이고 Value는 도메인 내부의 호스트에 대한 ip주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 네임
  - Type = CNAME이면 Value는 별칭 호스트 네임 Name에 대한 정식 호스트 네임, 이 레코드는 질의 호스트에게 호스트 네임에 대한 정식 이름을 제공
  - Type = MX이면 Value는 별칭 호스트 네임 Name을 갖는 메일 서버의 정식 이름, 메일 서버의 호스트 네임이 간단한 별칭을 갖는 것을 허용한다

- DNS 메시지
  ![ex_screenshot](/res/nt17.png)
  - 첫 12바이트는 헤더 영역으로 여러 필드를 갖는다
    - 질의를 식별하는 16비트 숫자
    - 식별자는 질의에 대한 응답 메시지에 복사되어 클라이언트가 보낸 질의와 수신된 응답 간의 일치를 식별
    - 1비트의 질의/응답 플래그는 메시지가 질의(0)인지, 응답(1)인지를 구별하게 한다
    - 1비트의 책임 플래그는 DNS 서버가 질의 이름에 대해 책임 서버일 때 메시지에 설정
    - 1비트의 재귀 요구 플래그는 DNS 서버가 레코드를 갖지 않을 때 재귀적 질의를 수행하기를 클라이언트가 원할 때 설정
    - 1비트의 재귀-가능 필드는 DNS 서버가 재귀 질의를 지원하면 응답에 설정
    - 4개의 '개수'필드가 있다 -> 헤더 다음에 오는 데이터 영역의 네가지 타입의 발생횟수를 나타낸다
  - 질문 영역은 현재 질의에 대한 정보를 포함
    - 질의 이름 필드, 질문 타입을 나타내는 타입 필드를 포함
  - 답변 영역 (DNS 서버로 부터의 응답)은 원래 질의된 이름에 대한 자원 레코드를 ㅍ함
    - 여러개의 RR을 버낼 수 있다
    - 호스트 네임은 여러 개의 IP주소를 가질 수 있기 때문
  - 책임 영역은 다른 책임 서버의 레코드를 포함
  - 추가 영역은 다른 도움이 되는 레코드를 포함
  
2.6 P2P 애플리케이션
- 파일 분배 : 애플리케이션은 한 출발지에서 많은 수의 피에에게 하나의 파일을 분배
- P2P는 자가 확장성을 잘 보여준다

2.6.1 P2P 파일 분배
- 클라이어트-서버 파일 분배에서 서버는 파일 복사본을 각 피어들에게 보내야 한다
- 각 피어는 수신한 파일의 임의 부분을 다른 피어에 재분배할 수 있어 서버의 분배 프로세스를 도울 수 있다
- P2P 구조의 확장성

  ![ex_screenshot](/res/nt18.png)
  - 분배 시간은 모든 N개의 피어들이 파일의 복사본을 얻는데 걸리는 시간
  - 서버는 파일 복사본을 N개의 피어 각각에게 전송해야 한다
    - 서버는 NF비트를 전송해야 한다
    - 서버의 업로드 속도가 Us이기에 파일 분배 시간은 적어도 NF/Us
  - Dmin 이 가장 낮은 다운로드 속도를 가질 때 최소 분배 시간은 F/Dmin 이다
  - Dcs = max{NF/Us, F/Dmin}
  - 분배 시간은 피어 수 N에 따라 선형적으로 증가한다
  
  - 각 피어들은 서버가 파일을 분배하는 데 도움을 줄 수 있다
    - 분배가 시작되면 서버만 파일을 갖는다
    - 서버는 적어도 한 번 접속 링크로 파일의 각 비트를 보내야 한다 -> 최소 분배 시간은 적어도 F/Us
    - 클라이언트 - 서버 구조도 가장 낮은 다운 속도를 가진 피어는 F/Dmin
    - 시스템의 전체 업로드 용량은 서버의 업로드 속도와 각 피어들의 업로드 속도를 더한 것
      - Utotal = Us + ... + Un
      - 시스템은 각 피더들에 F비트를 전달해야 한다
      - 최소 분배 시간은 적어도 NF/(Us + .... + Un)
      
   ![ex_screenshot](/res/nt19.png)
   
- 비트 토렌트  
  - 특정 파일의 분배에 참여하는 모든 피어들의 모임을 토렌트라 한다
  - 참여 피어들은 서로에게 같은 크기의 청크를 다운로드 한다 (일반적 청크 크기는 256KB)
  - 각 토렌트는 트랙커라 부르는 기반구조 노드를 갖고 있다
  - 한 피어가 토렌트 가입 시 트랙커에 자신을 등록하고 주기적으로 자신이 있음을 알린다
  - 트랙커는 토렌트 참여 피어들을 추적한다
  
  ![ex_screenshot](/res/nt20.png)
  - 새로운 피어A가 토렌트에 참여하면 트래커는 참여 피어 집합에서 피어의 하위 집합을 무작위로 선택하고 피어의 IP주소를 새로운 피어에게 보냄
  - 피어 목록을 소유한 A피어는 목록에 있는 모든 피어와 동시 TCP 연결을 설정하려함
  - 시간이 지남에 따라 이러한 피어중 일부는 더나고 다른 피어는 A와 TCP 연결을 설정 하려고 시도, 피어의 인접 피어는 시간이 지나며 변동
  - 주어진 시간에 각 피어는 파일에서 청크의 부분 집합을 가지며 다른 피어는 다른 부분 집합을 갖는다
    - 주기적으로 A는 인접 피어에게 자신이 가진 청크 목록을 요청
    - A에 L개의 다른 이웃이 있으면 L개 청크 목록을 얻음
  - Rarset First : A가 가지고 있지 않는 청크 중 이웃들 중 가장 희귀한 청크를 결정한 다음 가장 희귀 한 청크 먼저 요청
  - 영리한 거래 알고리즘 : A가 현재 가장 높은 비율로 데이터를 제공하는 이웃에게 우선권을 부여하는 것
    - A는 각 이웃에 대해 지속적으로 비트를 수신하는 속도로 측정하고 가장 높은 속도로 비트를 공급하는 4개 피어를 결정
    - 4개 피어에 청크를 전송해 보답
    - 10초마다 비율을 재계산하여 4개의 피어 셋트 수정,
    - 4개의 피어는 활성화 되었다고 함
    - 0초 마다 추가로 이웃 하나를 무작위로 선택해 청크를 보는데 이는 낙관적으로 활성화되었다고 한다
    
2.6.2 DHT(Distributed Hash Table)
- P2P 시스템에서 각 피어는 (키, 값)의 일부만을 갖고 있다
- 모든 피어가 특정 키로 분산 데이터베이스에 질의하는 것을 허용할 것
- 분산 데이터베이스에 대응되는 (키, 값)쌍을 갖는 피어들을 찾고 질의하는 피어에게 키-값 쌍을 반환
- 모든 피어들은 데이터베이스에 새로운 키-값 쌍을 삽입 가능
-> 이와 같은 분산 데이터베이스를 DHT라고 함
  
  - 각 피어에게 식별자를 할당, 식별자는 일부 고정 n에 대해 [0, 2^(n-1)] 범위의 정수
  - 각 키를 범위 값에 매핑하는 해시 함수를 사용
  - 키의 가장 가까운 후속자로서 가까운 피어 지정
  - 키가 피어 식별자 중 하나와 같으면 일치하는 피어에 (키, 값)쌍을 저장
    - 키가 모든 피어 식별ㅈ라보다 크면 모듈로 2n 규칙을 이용해 가장 작은 식별자를 가진 피어에 (키, 값)쌍을 저장

- 순환 DHT

![ex_screenshot](/res/nt21.png)
- 각 피어는 바로 다음 후계자와 이전 전임자만을 추적한다
- 피어들의 순환 배열은 오버레이 네트워크의 특별한 경우이다
- 오버레이 네트워크에서 피어들은 물리적 링크, 라우터, 호스트로 구성된 '하부'컴퓨터 네트워크 위에 존재하는 추상 논리 네트워크를 형성한다
  - 링크는 피어들 쌍 사이의 가상 연결자
- 원형 오버레이를 사용해 3번 피어가 11에 대해 책임이 누군지 묻는 메시지를 생성
  - 이 메시지를 원 주위로 시계방향으로 보내면 메시지가 피어 12에 도착할 때까지 프로세스가 계속되고 피어에게 쿼리 메시지를 다시 보냄
- 순환 DHT는 각 피어가 관리해야 하는 오버레이 정보 양을 줄이기 위한 매우 우수한 해결책을 제공한다
  - 각 피어는 이후 후계자와 이전 전임자 두 피어들만 알면된다
  - 최악의 경우 키에 대한 책임 있는 노드를 찾기위해 DHT내의 모든 N개의 노드가 순환을 따라 메시지를 전달해야 한다(평균적 N/2개의 메시지를 전송)
  - 순환 주변에 흩어진 상대적으로 작은 수의 '지름길' 피어도 추적하도록 '지름길'을 추가하는 것

- 피어 천
  - 각 피어가 첫 번째 및 두 번째 후속 작업으 추적(즉, IP 주소를 알고 있음)하도록 요구
  - 각 피어는 두 후임자가 살아 있는지 주기적으로 확인해야 함
  - 피어 5가 갑자기 떠나고 피어 4,3이 후속 상태 정보를 업데이트 한다고 가정
  - 피어는 DHT에 참여하기 원하고, 피어1에 메시지를 보내고, 이 메시지는 올바른 메시지에 도달 할 때까지 DHT를 통해 전달되고, 선행 및 후속 정보를 피어에 보낸다
  
  
