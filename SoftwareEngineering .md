# 소프트웨어 공학 정리

### 소프트웨어 개발 과정
- SW 개발과정 : 계획, 요구사항 분석, 설계, 구현, 시험, 유지보수
- 소프트웨어 : 여러 구성요소가 유기적으로 상호작용하는 시스템
- 프로젝트 계획
  - 목표를 세우고 이를 달성하기 위해 체계적인 진행상황 관리를 할 수 있도록 세부 행동방안 마련
  - 소프트웨어 프로젝트의 핵심 활동
  - 소프트웨어 프로젝트 관리에서 가장 중요하게 여겨지는 과정
- 요구사항 분석
  - 시스템이나 소프트웨어 요구사항을 정의하기 위해 사용자의 요구사항을 조사하고 확인하는 과정
  - 가장 중요한 과정 -> 다양한 이해관계자를 참여시켜야 함
  - 시스템의 목표를 확립하는 중요 과정
  - 요구사항 규명 : 사용자 관점에서 시스템 요구사항을 모으는 것
    - 기능 / 성능 / 인터페이스 요구사항 등으로 구분
    - 시스템에 대한 Needs가 나오게된 고객의 내부환경과 외적 요인 파악
  - 정확한 요구 사항 규명
    - 사용자 관점에서 사용자가 제공받기 원하는 것이 무엇인지 분명하고 명확하게...
    - 요구 사항 정의 및 규명에 시간과 노력이 많이 투자되지만 개발과정에 발생하는 비효율적 시간과 노력 절약
    - How to가 아니라 What에 중점!
  - 프로젝트 성공을 위해 프로젝트 관리가 매우 중요!!
  - 요구사항 명세서는 개발 시스템과 이해관계자들이 동의, 서명하고 다음단계로 넘어가야 함(베이스라인 확정!!)
- 설계
  - 분석과정에서 모아진 요구사항을 설계도면에 옮기는 것
  - What이 아니라 How to에 중점!!
  - 서브 시스템들로 이루어지는 시스템 구조를 결정하고, 서브시스템을 하드웨어 및 소프트웨어 등의 구성요소에 할당
  - 품질에 직접적 영향을 줌
- 구현
  - 설계 결과를 사용자가 이용할 수 있는 모습으로 변환
- 시험
  - 우수한 품질의 제품을 얻기 위해 제품이 개발되는 프로세스마다 품질 보증을 위한 절차를 따라야 함
  - 공식적인 검토회 등을 통해 Filtering 작업을 수행해야 함
  - 제품 오류를 발견하고 수정하는 과정
  - 단위 시험 / 통합 시험 / 시스템 시험 / 인수 시험
- 유지 보수
  - 제품의 유지보수는 사용중 발생하는 여러 변경사항에 대해 적응하는 활동이며 변화에 대비하는 과정
  - 유지보수 유형 4가지
    - 잘못된 것을 수정하는 유지보수
    - 시스템을 새 환경에 적응시키는 유지보수
    - 새로운 기능을 추가하는 유지보수
    - 미래 시스템 관리를 위한 유지보수 
### 소프트웨어 개발
- 소프트웨어 공학 정의
  - 효과적으로 작동할 수 있는 소프트웨어를 최적의 비용으로 얻기 위하여 사용하는 견고한 엔지니어링 원칙
  - 소프트웨어 시스템의 개발, 운용 및 관리에 적용되는 체계적 접근방법
  - 예산, 시간 범위내에서 효과적으로 소프트웨어제품의 개발 및 유지보수 활동과 관련된 기술적, 관리적 원리
### 프로젝트와 프로젝트 관리 이해
- 프로젝트
  - 고유한 제품, 서비스 및 결과를 생성하기 위한 한시적 노력
  - 한시성 / 유일성 / 점진성
- 프로젝트 관리
  - 프로젝트 요구사항을 만족시키기 위해 지식, 기능, 도구 및 기법을 프로젝트 활동에 적용시키는 것
  - 프로젝트의 성공과 실패는 기대치와 요구사항의 차이(Gap)를 얼마나 줄이느냐에 따라 결정
- PMBOK
  - 프로젝트 생명주기
    - 지속적인 운영과 적절히 연계되는 방식으로 프로젝트 관리를 통제하기 위해 프로젝트 관리자나 조직은 프로젝트를 여러 단계로 세분화 하는 단계
    - 프로젝트의 시작과 끝을 연결하는 단계 정의
  - 생명 주기 특성
    - 초기에는 인력 및 비용 투입이 적지만 점차 증가하다 종료 시 급격히 하락
    - 이해관계자들의 영향력은 프로젝트 초기에 높고, 사업이 진행됨에 따라 점차 감소
    - 초기에는 위험도, 불확실성이 높아 성공에 대한 확률이 적으나 수행함에 따라 위험, 불확실성이 제거되어 점차 성공에 대한 확률이 높아짐 
  - 프로젝트 이해관계자 
    - 프로젝트에 적극적으로 참여하거나 프로젝트 수행 및 완료 결과가 자신의 이해에 긍정적이거나 부정적으로 영향을 받는 개인이나 조직
### 프로젝트 계획
- 계획 
  - 문제를 해결하거나 목적을 이루기 위해 앞으로 해야할 일을 미리 생각하여 전략을 수립하고, 그 내용을 결정하는일
  - 프로젝트 핵심활동, 프로젝트관리에서 가장 중요한 과정
  - 목표를 세우고 이를 달성하기 위해 체계적인 진행상항을 관리를 할 수 있도록 세부 행동방안을 마련하는 것
  - 프로젝트 실행과 통제의 지침 제공
  - 프로젝트 초기에 얼마나 계획을 잘 만들어 예측을 잘 하느냐에 성공 여부가 달려 있음
  - 목표를 이루기 위해 구체적인 접근 방법을 설정하는 것
  - 프로젝트 제약 조건
    - 3대 제약조건 : 시간 / 돈 / 얻어지는 품질(범위) 
- 계획 단계
  - 프로젝트 헌장이 공식 승인된 후 진행
  - PM은 이를 바탕으로 프로젝트 범위 개발, PMP 등 프로젝트에서 요구하는 다양한 세부 계획 수립
  - 프로젝트 범위와 비용 식별, 일정을 개발하여 프로젝트 관리계획 수립
- 프로젝트 계획 단계
  - 프로젝트의 시작 승인을 받아 프로젝트 실행과 통제를 위한 전략을 세우고 이를 문서화하는 과정
  - 성과 기준을 제시하여 성과 측정의 기준이 되며 동시에 프로젝트 통제 기준!
  - 프로젝트 범위관리계획
    - 요구 사항을 수집하고 범위를 정의한 후 작업분류체계를 작성하는 과정
  - 작업 분할 구조(WBS)
    - 프로젝트 목표를 달성하기 위해 수행해야 할 작업을 인도물 중심으로 계층적으로 작성한 구조
    - 일정과 원가를 산정할 수 있는 수준까지 분할
    - 작업 패키지 : WBS를 통하여 만들어진 최하위 단계의 활동
    - WBS = 가장 중요한 계획 도구 + 효과적인 의사소통 도구
    - 다양한 프로젝트 인도물을 생산하기 위해 요구되는 작업 행위
    - 1~2주 이내(약 80시간) 기간에 수행될 수 있는 활동을 작업 패키지 단위로 잡고 진행하는 것이 일반적
  - 프로젝트 일정 관리 
    - 시간은 원가와 함께 프로젝트 목표를 구성하는 요소
    - 일정 관리 프로세스 
      - 활동 정의 : 활동들이 정의되어 작업 패키지로 식별
        - WBS의 최하위 수준의 산출물을 식별한 작업 패키지를 바탕으로 이루어짐
      - 활동 순서 배열 : 활동 간 논리적 관계와 의존도를 문서화하고 활동 순서로 배열
      - 활동 자원 산정 : 각 일정활동을 수행하기 위해 필요한 자원 소요를 산정
      - 활동 기간 산정 : 각 활동에 배치된 자원을 고려하여 개별 활동 수행에 필요한 시간 추정
      - 일정 개발 : 앞의 4단계 프로세스를 바탕으로 일정 개발 및 반복
  - 프로젝트 원가 관리
    - 각 단계에서 얼만큼의 비용이 투입될 것인지 추산하여 프로젝트 전체에 요구되는 비용을 예상
    - 상향식 추정 방법
      - 원가 추정을 하는 가장 정확한 방법(WBS 활용)
      - 작업 패키지 기준으로 원가 산출 -> 상위단계로 합하여 전체 원가를 산출하는 방법
    - 하향식 추정 방법
      - 정확히 원가를 산출할 수 없는 구체적 근거가 없을 때 전문가 경험과 판단에 의지하는 방법
      - LOC, FP 방법
      - LOC (Line Of Code)
        - 소스 코드에 나타날 물리적 줄 수 사용
      - FP (Functiono Point)
        - 사용자 관점에서 요구되는 소프트웨어 기능들을 측정하여 소프트웨어 개발규모 예측
        - LOC에 비해 매우 정확한 초기 측정치 산정 가능
        - 계획 단계에서 기능점수 측정에 한계가 있으며, 요구사항 정의 단계에서 정확한 기능점수 측정 가능
  - 형상 관리 계획
    - 소프트웨어 형상 관리
      - 형상은 문서이며, 프로젝트를 수행하는 개발과정에서 생산되는 산출물인 문서를 관리하는 것
    - 소프트웨어 형상 변경
      - 변경을 통제하는 절차 매우 중요!! ( 개발 이후, 유지보수 과정에서도 발생)
  - 확인 및 검증 계획
    - 추적성 : 시스템 개발 프로세스 내에서 서로 다른 단계의 요구사항 간 연관관계 제공 기법
    - 확인 : 사용자 요구사항을 올바르게 이해하는 과정
             고객의 기대와 요구사항을 만족시킬 수 있도록 보장하는 활동
    - 검증 : 이해된 요구사항을 소프트웨어에 영하여 올바르게 제품을 만들어 갈 수 있도록 보장하는 활동
             지정된 기능을 정확히 수행할 수 있도록 단계별 점검을 통해 추적하는 활동
    - 소프트웨트웨어 확인 및 검증(V&V)
      - 사용자 요구사항을 만족할 수 있도록 개발 생명주기 전반에 걸쳐 수행되는 점검 및 분석 프로세스
 ### 소프트웨어 개발방법론
- 폭포수 모델 
  - 고전적 수명주기 패러다임 
  - 요구사항 분석, 설계, 구현, 시험, 운영 및 유지보수 순서로 시스템 개발이 이루어짐
  - 단계적으로 정의한 체계적이며 순차적 접근방법 사용
  - 하향식 접근방법을 사용하여 높은 추상화 단계에서 낮은 추상황 단계로 옮겨가는 모델
  - 각 단계 진행 과정에서 문제 발생 시 이전 단계로 피드백 되는 경우 발생
  - 계획 : 프로젝트 목표를 세우고 세부 행동방안 마련 과정으로 결과물은 프로젝트 관리 계획서
  - 요구 사항 분석 :  사용자 요구 사항을 정의하기 위하여 시스템 요구사항 수집
                      시스템 목표를 정하는 과정으로 결과물은 요구사항 명세서
  - 설계 : 요구사항 분석 과정에서 모아진 요구사항을 설계도면에 옮기는 것
           물리적 실현의 첫단계 결과물은 설계 문서
  - 구현 : 시스템 기능이 수행 가능한 모습으로 나타내며 프로그래밍 or 코딩
  - 시험 : 품질보증 활동의 중요한 일부분
           제품의 오류를 발견하고 수정하는 과정
  - 유지보수 : 여러 변경사항에 대해 적응하는 활동이며 변화에 대비하는 과정
  - 폭포수 모델의 장단점
    - 장점 : 프로젝트 진행과정을 세분화하여 관리가 용이함.
             요구사항 변화가 적은 프로젝트에 적합
    - 단점 : 피드백이 발생하여 순차적 흐름을 따라가는데 어려움
             고객이 원하는 요구사항을 초기에 구체적으로 기술하기 어려움
             작동 시스템이 후반부에 보여져 문제점이 개발 후반부에서 발견
- V 모델
  - 소프트웨어 개발 프로세스로 폭포수모델의 확장된 형태
  - 개발 생명주기의 각 단계와 그에 상응하는 소프트웨어 시험 각 단계의 관계를 보여줌
  - 전체적으로 많은 양의 프로젝트 비용과 시간을 감소함
- Prototyping (시제품)
  - 간단한 시제품을 만들어 사용자에게 보여주며 요구사항을 빨리 정의하기 위한 방법 사용
  - 폭포수 모델의 단점을 보안하기 위해 점진적으로 시스템을 개발하여 나가는 접근방법
  - 시제품을 통해 이전에 밝혀지지 않았던 사용자 요구사항을 구체적으로 규명
  - 시제품은 시스템에 대한 이해와 품질 향상에 사용 / 사용자와 시스템 간 인터페이스에 초점
  - 장점
    - 개발자와 사용자 간의 오해 규명, 사용하기 어려벅나 혼돈을 일으키는 기능이 규명되어 명료화
    - 생각지 못한 기능과 서비스를 발견할 수 있다
    - 불완전하거나 일치않는 요구사항을 시제품을 통해 발견 가능
  - 단점
    - 반복적 개발을 통한 투입 인력 및 비용 산정 어려움
    - 불명확한 개발 범위로 인한 개발 종료 및 관리 어려움
  - 과정 : 요구사항분석 -> 시제품 설계 -> 시제품 개발 -> 고객 시제품 평가 -> 시제품 정제 -> 완제품 생산 
  - 요구사항 분석
    - 폭포수 모델의 요구사항 분석과 유사
    - 완전치 않은 요구사항에 대해 윤곽을 잡음 -> 추가적인 정의는 시제품이 개발된 후 계속 정제
  - 시제품 설계
    - 프로토타입에 대한 설계
    - 시제품 개발 목표 확립되고 시제품에 포함될 기능 선택
    - 포함되는 것, 배제되어야 하는 것을 규명하는 것이 중요
    - 사용자들이 볼 수 있는 면에 초점
  - 시제품 개발 단계
    - 성능, 인터페이스 등에 대한것은 중요치 않게 다루어지지 않음
    - 시제품의 신뢰도와 프로그램 품질 수준은 낮음
    - '어떻게 하면 시제품을 빨리 만들 수 있겠는가'가 단계 목표임
  - 시제품 평가단계
    - 원형 패러다임의 가장 중요한 단계
    - 고객에 의해 평가되고, 개발될 소프트웨어 요구사항을 구체적으로 정제하기위해 사용
    - 오류 발견 및 규명이 가능해지며, 추가 요구사항을 찾아 낼 수 있음
  - 시제품 정제단계
    - 시제품이 어떻게 고쳐져야 하는지 결정하고 다음 시제품이 빠르게 만들어 질 수 있게함
    - 다시 고객에 평가되는 순환을 하게되며 고객이 만족할 때까지 계속
  - 완제품 생산단계
    - 원하는 시스템을 개발
  - 시제품을 통해 사용자 교육훈련에 사용되어 실제 사용하기까지 시간 절약 가능
  - 시스템 시험이 연속적으로 사용될 수 있어 시제품과 최종단계 제품에 동일한 시험 적용 가능
- 나선형 패러다임
  - 폭포수 모델과 원형 패러다임의 장점 + 위험 분석
  - 시스템 개발에서 생기는 위험을 관리하고 최소화 목적
  - 나선을 돌며 점진적으로 완벽한 시스템 개발(점증적 + 진화적 + 반복적 = 점진적)
  - 계획 및 정의 단계
    - 요구사항 수집 및 프로젝트 계획 수립
    - 시스템 목표와 제약조건에 대한 차선책 평가 및 고려
    - 프로젝트 위험의 원인 규명에 효과적으로 사용
  - 위험 분석 단계
    - 초기 요구사항에 근거하여 위험 규명
    - 정보를 찾아내는 활동을 통해 불확실성과 위험 축소
    - 프로젝트 Go or No 결정
  - 개발 단계
    - 어떤 패러다임이 적용되어 시스템 개발이 이루어질 것인가 하는 개발 모델 결정
    - 시제품 개발 및 최종 제품을 만드는 과정
  - 고객 평가 단계 
    - 단계별 개발 결과를 사용자가 평가하는 과정
    - 필요시 시스템 수정 요구
  - 비용이 많이 들고 시간이 오래 걸리는 큰 시스템 구축해 나가는데 가장 현실적 접근 방법
  - 성과를 보며 조금씩 투자해 위험부담을 줄일 수 있는 방법
  - 장점
    - 사전 위험 분석을 통한 돌출 위험 요소 감소 -> 프로젝트 중단 확률 감소
    - 사용자 평가에 의한 개발 방식 -> 요구가 충분히 반영 -> 사용자 불만 감소
  - 단점
    - 반복적 개발에 의한 프로젝트 기간 연장 가능성
    - 반복 회수 증가에 따른 프로젝트 관리 어려움
    - 위험 관리 중요 -> 위험 전문가 필요에 따른 부담
- 4세대 기법
  - CASE를 비롯한 자동화 도구들을 이용해 요구사항 명세서로부터 실행코드를 자동으로 생성할 수 있게 해주는 방법
  - 형식규격언어를 사용하면 명세서를 해석하고 이해하는 데 정확성을 기할 수 있어며 개발과정 자동화 가능
  - 성능이 뛰어나지 못하며 불필요한 많은 양의 코드 생성, 유지보수 어려움
- 애자일 방법론
  - 전통적 개발방법을 탈피하여 필요 요구를 그때 그때 추가하고 수정하는 코드 중심의 점진적 개발 방법
  - 협업과 변화에 대한 빠른 대응에 가치를 두고 쪼개진 수행과정을 통해 소규모 목표를 달성해 나감
  - 이터레이션(반복)을 강조!!
  - 기술적 부채
    - 기존 결험들로 인해 새로운 기능의 개발 및 확장에 어려움이 발생하는 것
    - 과거 내린 결정의 결과가 미래에 부정적 영향을 미치는 것
    - 기술적 부채는 쌓아둘수록 추후에 해결하기 어려워지고 유지보수 비용 증가 => 소프트웨어 부패
  - 리팩토링
    - 소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 기존 코드를 설계하는 기술
    - 내부구조를 바꾸며 점진적으로 설계를 향상시키는 기법
    - 중복된 코드 / 긴 매소드 / 거대한 클래스 등이 리팩토링이 필요한 경우!
    - 효과
      - 코드 이해가 쉬어 다른 프로그래머가 코드 변경 시 이해 수준 향상
      - 프로그램 구조를 명확히 해주어 버그 찾는데 도움을 준다.
      - 리팩토링을 위해 별도 절차, 시간 할애할 필요 없으며, 코드 구현작업의 일부분으로 취급
      - 버그를 수정하거나 새로운 기능을 추가할 때 깆곤의 코드에 대한 이해도를 바탕으로 더 빠른 작업속도를 얻을 수 있는 방법
  - 객체지향 기법 적용
    - 점진적 개발이 용이하도록 지원해주는 소프트웨어 개발 기술
    - 재사용성 확장
    - 기존 메소드나 코드에 영향을 최소화하며 새로운 메소드나 코드 추가 가능
    - 적응성과 재사용성 극대화 방법
  - 스크럼 개발 프로세스
    - 소프트웨어 개발보다 팀의 개선과 프로젝트 관리를 위한 애자일 방법론
    - 경험적 관리 기법 중 하나
    - 구체적 프로세스를 명확하게 제시하지 않음
    - 장단점
      - 실행 가능 제품을 통해 사용자와 충분한 의견 조율 가능
      - 일일 회의를 통한 팀원들 간의 신속한 협조와 조율 가능
      - 반복 주기가 끝날 때마다 실행 가능하거나 테스트할 수 있는 제품을 만들어야 함
      - 투입 공수 불측정으로 인해 효율성 평가 불가 / 프로세스 품질 평가 불가
- 익스트림 프로그래밍(XP, eXtreme Programming)
  - 애자일 소프트웨어 개발방법론 중 가장 많이 알려진 방법
  - 의사소통, 단순함, 피드백, 용기, 존중 등 5가지 가치에 기초
  - 개발 속도를 높이는 기술이며 중심사고는 단순한 설계, 시험우선 프로그래밍, 리팩토링
  - 사용자 스토리
    - 스토리를 만들어 고객과 직접 대면하며 이야기 하는 것
    - 고객이 원하는 기능을 짧게 표현 하는 것
    - 개발 초기에 요구사항을 구체적으로 정의하느 단계를 거치지 않고 대화하며 요구사항을 이끌어내는 방식
    - 수행될 작업을 적게 나누어 비교적 짧은 시간에 완료할 수 있는 작업범위를 다룸
    - 좋은 사용자 스토리 6가지 특성 : Independent, Negotiable, Valuable, Estimable, Small, Testable
  - XP에서의 시험 : XP가 가장 중요시 하는 부분
  - XP 시험 특징
    - 시험 관련 활동은 요구사항 분석단계까지 지속된다
    - 시험을 작성 작업은 고객과 함께 협동하여 수행한다
    - 시험자와 개발자는 협력 관계를 유지해야한다.
    - 프로그램을 작게 나누어 시험을 자주 수행
  - XP 개발 프로세스
    - 사용자 스토리 : 고객이 원하는 시스템을 간단한 시나리오로 표현 
    - 릴리즈 계획 수립 : 사용할 수 있는 시스템을 고객에게 제공 
    - 이터레이션 : 릴리즈 계획에 따라 시스템 구현을 위해 리즈의 프로젝트 일정을 더 작게 분할한 것
    - 인수 테스트 : 한번의 이터레이션에서 구현이 완료된 부분에 대한 시험, 고객이 직접 시험하는 것 권장
    - 작은 릴리즈 : 릴리즈 계획에 따라 구현부분을 반복적으로 고객에게 인도하는 것
  - XP의 가치
    - 의사소통 / 단순함 / 피드백 / 용기 / 존중
- 통합 프로세스(UP) 모델
  - 절차
    - 도입 단계
    - 구체화 단계
    - 구축 단계
    - 전이 단계
    - 도입/구체화/구축/전이 단계의 이터레이션
    
  ![ex_screenshot](/res/up1.JPG)
  ![ex_screenshot](/res/up2.JPG)
  
- 컴포넌트 기반 개발(CBD) 방법론
  - CBD 방법론 : 재사용 가능한 컴포넌트를 기반으로 소프트웨어를 개발하는 방법론
  - 컴포넌트 : 특정 기능을 수행하기 위해 독립적으로 개발되고, 잘 정의된 인터페이스를 가지며, 다른 부품과 조립되어 응용 시스템을 구축하기위해 사용되는 소프트웨어 부품(단위)
    - 재사용 가능한 부품, 독립된 배포 단위
    - 하나 이상의 프로그램들을 하나의 단위로 관리하는 패키지
    - 실제 구동될 수 있도록 만들어진 단위, 동적으로 바인딩 할 수 있도록 실행시간에 인터페이스 통해서만 접근
    - 일반적으로 잘 정의된 아키텍처 상에서 특정 기능을 수행하며 독립적이며 대체 가능한 시스템의 부분
  - 컴포넌트 장점
    - 복잡한 소프트웨어를 보다 쉽게 관리
    - 교체 및 재사용이 쉬워 개발 기간과 비용 절감
    - 기존의 검증 컴포넌트를 사용해 고품질 소프트웨어를 만들 수 있음
    - 컴포넌트 단위 재사용
  - CBD 방법론의 개발 단계
    - 컴포넌트 개발 단계 
      - 해당 도메인에 대한 분석 결과 재사용 가능한 부품을 만드는 것
      - 도메인 영역에서 재사용 가능한 기능적 요구사항이 무엇인지 명확하게 정의하느 것 필요
      - 컴포넌트를 저장하고 관리하기 위한 컴포넌트 저장소 필요
      - 컴포넌트 저장소
        - 컴포넌트 자체를 저장하기 위한 공간이 아니라 제작된 컴포넌트를 분류하고 관계에 대한 정보까지 제공해 줄 수 있어야함.
        - 특정 컴포넌트에 대한 변경 이력 발생 시 그에 따른 변경 관리도 수행할 수 있어야함.
    - 컴포넌트 기반 소프트웨어 개발단계(CBSD)
      - 이미 개발된 컴포넌트를 조립해 소프트웨어 시스템을 개발하는 과정
      - 요구사항을 정의하고 적절한 아키텍처 설계가 이루어져야 함
  - 느슨한 결합도와 큰 입자의 특징을 갖는 컴포넌트 기반 소프트웨어 개발 방법론
  - 고객 요구변화에 신속하고 유연하게 대처하는 것을 목표로 하는 방법론
  - 프로세스마다 특정 산출물을 가지며, 산출물을 통해 중복 투자 감소 및 유지보수성 향상
- 소프트웨어 개발 방법론의 공통점
  - 시스템 제작 공통점 : 정의 / 개발 / 유지보수
  - 시스템 정의
    - 요구사항 분석과정 
    - 사용자 관점에서 시스템이 제공해야하는 기능, 데이터, 인터페이스 정의
    - 사용자에게 무엇을 제공할 것인가 초점
    - 사용자 관점, 시스템의 논리적 관점
  - 시스템 개발 
    - 시스템이 제공해야 하는 무엇을 어떻게 만족시킬 수 있을것인가 규명
    - 엔지니어 관점, 시스템 물리적 관점
    - 설계, 구현, 시험의 과정
  - 시스템 유지보수
    - 시스템이 개발 후 오류의 수정, 환경 변화, 기능 향상요구 등과 연관되어 발생하는 변화에 초점
    - 수정 유지보수, 적응 유지보수, 완벽적 유지보수, 예방적 유지보수

### 요구사항 분석 기법
- 요구사항 분석 정의 : 문제에 대한 정의를 내리는 것 / 시스템 목표를 확립하는 과정
  - 요구사항 발견, 정제, 모델링 및 명세화 과정
  - 기능, 성능, 인터페이스 등 규명
  - 고객에게 무엇을 제공할 것인지 정확히 기술하는 것
  - 최종 산출물은 소프트웨어요구사항명세서(SRS)
- 요구사항명세서
  - 요구사항 분석의 최종 목표이자 산출물 중 가장 중요한 문서
  - 초기에 완벽한 요구사항 명세서를 만드는 것이 프로젝트를 성공적으로 수행하는데 필수적
  - 사용자, 개발자 모두 쉽게 이해되도록 작성하고 고객과 개발팀 간의 약속이 된다.(고객과 개발팀간 합의 필요)
  - 시스템 수행 기능과 시스템에 관계된 제약조건을  정확히 기술
  - 시스템 목표만 기록하고 어떻게 달성할 것인가는 기록하지 않음
  - 인수시험의 검증 자료로 사용, SRS가 없으면 시험 불가능(SRS으로부터 시험계획이 도출)
- 요구사항 명세서 조건
  - 고객, 개발자 모두 쉽게 작성 (고객과 개발자 모두가 동의한 것)
  - 시스템이 수행할 모든 기능을 명확히 기술(SRS의 핵심!!)
  - 제안된 시스템에 미치는 모든 제약조건 명시
  - 시스템 사용에 필요한 조항들을 검증할 수 있는 검증 기준 제시
- 요구사항 분석의 문제점
  - 의사소통 문제
  - 요구사항이 계속 변화
  - 분석도구 미비
  - 문서화 어려움
  - 정치적 문제
  - 작업(일) 할당 문제
- 모델링
  - 개발 시스템의 성능분석이나 동작과정을 알아보기 위해 간단한 물리적 모형 및 도해를 만들거나 그 시스템의 특징을 수학적으로 표현하는 과정
  - 추상화 작업
    - 목적과 무관한 부분을 제거, 관심 부분에 집중 
    - 목적이 뚜렷해야하고 무엇이 중요하고 중요치 않은지 결정
    - 중요한 핵심만 포함하고 나머지 것들 생략
  - 모델링 기본 요소 : 표현(정보 모델 표기법) / 규약 / 명세 
- 소프트웨어 시스템의 3가지 관점
  - 기능 / 동적 / 정보(객체) 관점 -> 소프트웨어 3가지 주요 관점
  - 기능 관점 
    - 시스템이 어떤 기능을 수행하는지 관점에서 시스템 기술
    - 입력에 대해 어떤 결과가 나오는가 보여주는 관점이며 연산, 제약조건 묘사
    - 자료흐름도는 데이터 수행되는 계산에 근거하여 시스템을 쪼개며, 중요 구성요소는 기능을 수행하는 프로세스와 자료흐름
    - 기능 모델링 -> 자료흐름도와 자료 사전으로 결과를 기술
  - 동적 관점
    - 시간 변화에 따른 시스템 동작과 제어에 초점을 맞춰 시스템 상태와 상태를 변하게 하는 원인 묘사
    - 동적 모델링 도구로 상태 변화도와 사건 추적도 등 사용
    - 동적 모델링의 주요 구성요소는 상태와 사건
    - 외부와 상호작용이 많은 실시간 시스템은 동적 관점에서 시스템을 기술
  - 정보 관점
    - 시스템에 필요한 정보를 보여줌으로써 시스템의 정적인 정보 구조를 포착하는데 사용
    - 사용되는 정보 객체를 찾고 객체들의 특성, 관계와 연관성을 규명
    - 실세계를 정확히 묘사할 수 있는 장점이 있다.
    - ER 모델 or EER 모델이 대표적인 도구
  - 3가지 관점 통합
    - 3가지 관점이 모아지고 통합되어야만 시스템 요구사항이 완벽히 표현 가능
- 기능 모델링
  - 구조적 분석 기법 : 기능 관점에서 바라보고 요구되는 정보 흐름과 변환을 나타내주는 기능 모델
  - 구조적 기법 발전 단계 : 구조적 프로그래밍 -> 구조적 설계 기법 -> 구조적 분석 기법
  - 자료 흐름도 : 정보가 입력되어 적용되는 변화와 그 결과를 그림으로 묘사해주는 도식적 기법
    - 자료 흐름도 표기법
    
    ![ex_screenshot](/res/dfd.JPG)
    - 프로세스 분할
    
    ![ex_screenshot](/res/dfd2.JPG)
    - 자료 흐름도 분할
      - 시스템을 하나의 프로세스로 놓고 외부와 정보흐름을 표시하는 배경도에서 시작하며 더 이상 쪼갤 필요가 없을 때까지 단계별로 분할
      - 더 이상 쪼개지지 않는 프로세스 : 단위(기본) 프로세스
      - 자료 흐름도 목적은 원시 프로세스와 원시 프로세스들 사이의 정보 흐름을 규명하는 것
    - 배경도
    
      ![ex_screenshot](/res/배경도.JPG)
      
      - 최상위의 하나로 된 프로세스를 그린 그림으로 시스템이 분할이 되기 이전의 프로세스 표현
      - 우리가 개발하여야 할 시스템의 영역을 기술
      - 시스템을 블랙박스로 본 것으로 시스템과 외부 환경과의 인터페이스에 초점
    - DFD 프로세스 번호 : 각 프로세스와 프로세스를 구체적으로 묘사하느느 자료 흐름도에 번호 부여
      - 상위 레벨의 부모 자료 흐름도와 연관된 프로세스로부터 번호 부여
      - 배경도 프로세스 ( 최상위 프로세스로 번호 0 )
    - 단위 프로세스 : 프로세스들 중 더 이상 쪼개지지 않는 하위 프로세스
    - 소단위 명세서 : 단위 프로세스에 대한 상세 설명 (프로세스 명세서)
    
      ![ex_screenshot](/res/소단위 명세서.JPG)
      
      - 한 페이지 요약 분량이 적당
      - 소단위 명세서 번호는 해당 프로세스 번호와 같음
    - 자료 흐름도 균형
      - 부모 자료 흐름도의 정보 입출력은 자식 자료 흐름도의 입출력과 같아야 한다는 제약 조건
      - 정보흐름의 연속성을 유지하기 위해 필요 
      - 균형에 대한 정보는 자료 사전에서 정의
    - 자료 사전 
      - 자료 흐름도에 표시된 시각정보를 체계적이며 조직적으로 모아 놓은 것
      - 메타 데이터, 데이터에 대한 데이터를 모아 놓은 저장소로 데이터 항목, 흐름 등에 관한 정의 포함
  - 구조적 설계로 전환
    - 설계는 요구 사항 분석 결과를 프로그램 구조로 변환시키는 과정
    - 논리적인 관점에서 자료 흐름과 기능 기술
    - 구조적 설계 기법 -> 자료 흐름 중심 설계 기법
    - 분석 -> 설계 과정
      1. 요구 사항 분석 결과를 검토하고 필요 시 수정
      2. 자료 흐름 유형 조사, 변환 흐름 / 트랜잭션 흐름 으로 구분
      3. 자료 흐름 유형에 따라 흐름 경계 식별
      4. 자료 흐름도를 프로그램 구조로 매핑
      5. 분할하여 제어 계층 구조 정의, 하향식 접근 방법
      6. 결과를 설계 가이드 라인과 시스템 특성을 고려해 정제

- 동적 모델링      
  - 시간과 변화의 관점에서 시스템을 묘사하는 것
  - 시스템 제어 흐름, 상호 작용, 동작 순서를 다루고, 제어는 외부 자극에 시스템이 어떤 동작을 수행하는지 나타내는 것 
  - 실시간 시스템 : 제한 시간 내에 외부 사건에 응답 및 자료 처리
    - 신뢰성 높은 실시간 시스템 개발에 많은 연구개발 노력과 동적 모델링이 중요
    - 타 SW 시스템보다 어렵고 복잡하며 특수한 분석, 설계 및 시험 기법 필요
    - 여러 프로세스를 동시 병행 수행하거나 프로세스 처리에 우선순위를 가지며, 자원에 대한 동시 접근 및 할당, 제어 기능 부여
  - 상태 변화도(STD) : 시스템의 제어 흐름, 동작 순서 기술
    - 상태, 사건, 동작
    - 상태와 사건에 의해 시스템 제어를 나타내는 유한 오토마타를 확장하여 도식적으로 표시한 것
    - 사건이 시스템의 특정한 상태에서 반응하는 것
    - 상태 : 시스템이 가지고 있는 속성값으로 결정
    - 사건 : 외부에 주어지는 자극에 의해 발생
    - 활동 : 시간을 두고 일어나는 작용
    - 동작: 시간이 걸리지 않고 일어나는 작용
    
     ![ex_screenshot](/res/상태변화도.JPG)
    - 상태 변화도 작성 절차
      - 시나리오 작성 -> 사건추적도 작성 -> 상태변화도 작성
      - 시나리오 : 시스템이 작동하며 일어나는 사건들의 순서
      - 사건추적도 : 사건 순서와 사건을 주고 받는 객체, 시스템 표현
      - 상태변화도 : 상태, 사건들을 종합하여 상태변화도 작성
  - 복합 분석 모델 : 기능 관점 + 동적 관점 + 정보 관점
- 정보 모델링
  - 시스템에 필요한 엔티티(객체)들을 정의하고 엔티티 사이의 연관성 규명 작업 
  - EER 모델 : 시스템에 요구된 기본 객체를 나타내는 엔티티와 엔티티 간 연관성을 나타내는 관계로 구성
  - 엔티티 : 독리적으로 존재하는 현실세계의 사물, 객체
  - 분류화 : 비슷한 엔티티를 묶는 작업 -> 같은 종류의 속성, 제약조건 및 동작 유형 공유
  - 실례화 : 분류화의 역작용으로 엔티티 타입에 속해있는 엔티티를 구별하여 참조에 사용
  - 키 : 각 엔티티를 구별할 수 있는 속성 모임
    - Primary Key / Alternate Key
  - 관계 타입 : 같은 형태를 갖는 관계들의 집합 (마름모)
  - 매핑 제약 조건 : 데이터들 사이 지켜져야 할 제약조건 지정
    - 사상 유형 : 일대일 / 일대다 / 다대다
  - 참여 제약 조건 : 엔티티가 관계에 참여하는 것이 필수인지 선택인지 지정하는 제약조건
  - 참조 무결성 : 두 엔티티 사이 관계에 작용하는 제약조건, 데이터 일관성 유지에 필요!!
  - 관계 타입 차수 : 참여하는 엔티티 타입의 수
  - EER 모델 : ER 모델에 일반화, 특수화, 집단화 등 계층적 개념을 추가하여 확장한 것
    - 일반화 : 엔티티 타입 간 유사성 존재시, 이 유사성을 모아 하나의 새로운 엔티티 타입을 정하는 것
    - 일반화 관계 : is_a or kind_of 관계로 표현
      - 클래스들 사이 유사성 표시 기법
      - 상위 클래스 정보가 하위 클래스에 상속
      - 상속은 엔티티 타입 정의를 단순화, 기존 정의된 엔티티 타입을 이용해 새로운 클래스를 쉽게 정의
    - 특수화
      - 일반화의 역진행
      - 한 엔티티 타입이 세분화된 하위 클래스로 나뉨

### 구조적 방법론 보충
- 구조적 분석 모형화 절차 
  - 현 물리적 모형화
    - 사용자 업무수행 절차 및 환경을 있는 그대로 모형화, 시스템 문제점 인식이 중요
  - 현 논리적 모형화
    - 현 물리적 모형에 존재하는 구현 의존적 물리적 특성을 제거
    - 구현 방법에 상관없이 시스템에서 수행하는 논리적 기능 및 유지할 자료 모형화
  - 신 논리적 모형화
    - 현 논리적 모형에 새롭게 추가할 기능이나 변경 및 개선기능을 반영
    - 새로운 시스템에서 수행될 모든 기능 및 자료 모형화
    - 사용자 요구사항을 논리적으로 표현한 최종 분석 명세서
  - 신 물리적 모형화
    - 신 논리적 모형을 기반으로 현실적 물리적 환경을 감안해 최종 적용할 모형 제시 단계
- 자료 흐름도 효과
  - 사용자 업무 및 요구사항 쉽게 문서화
  - 사용자, 분석가의 의사소통을 위한 공용어 역할
- 자료흐름도 작성 원칙
  - 자료 보존 원칙 : 어떤 처리의 출력자료 흐름은 반드시 입력 자료 흐름을 이용해 생성된 것이어야 함.
    - 블랙 홀 : 입력만 되는 자료 저장소
    - 화이트 홀 : 출력만 되는 자료 저장소
  - 최소 자료 입력 원칙 : 어떤 처리가 출력자료 흐름을 산출하는 데 반드시 필요로 하는 최소 자료 흐름만 입력해야 한다는 것
  - 독립성 원칙 : 자기의 처리는 오직 자신의 입력 자료와 출력 자료 자체에 대해서만 알면됨 -> 시스템 변경 시 영향 최소화
  - 지속성 원칙 : 처리는 항상 수행되어야 하며, 일시적으로 어떤 자료 흐름을 기다릴 때를 제외하고 다시시작이나 멈추면 안됨
  - 순서 처리 원칙 : 입력 자료 순서는 출력되는 자료 흐름에서도 지켜져야함
  - 영구성의 원칙 : 자료 저장소의 자료는 입력으로 사용해도 제거되지 않음
  - 자료변환 원칙 : 자료 본질의 변환, 자료 합성의 변환, 자료 관점의 변환, 자료 구성의 변환
## 소프트웨어 설계
- 시스템 설계
  - 구현을 위해 시스템을 여러 서브시스템으로 나누고 서브시스템 요소를 HW와 SW에 할당하는 것
  - 시스템 전체 구조를 먼저 결정 후 구체적 설계 진행
  - 분석에서 규명된 요구사항을 골격으로 살을 붙여가는 과정
- 서브 시스템 : 일반적으로 상위 수준에서 시스템을 분할한 시스템 구성요소
  - 자료 구조 + 제어 구조로 구성
  - 독립적으로 기능을 수행할 수 있고 컴파일 될 수 있는 프로그램 구성요소
- 관리적 관점
  - 기본 설계 : 시스템의 구조와 데이터를 규명하며 사용자 인터페이스 정의
  - 상세 설계 : 모듈의 구체적인 알고리즘에 초점
- 기술적 관점
  - 데이터 설계 : 정모 모델링에서 밝혀진 정보를 이용해 자료구조와 데이터베이스 설계
  - 구조 설계 : 기능 및 동적 모델링에 나타는 결과를 이용해 프로그램 구조상에 있는 구성요소간 관계 기술
  - 프로시저 설계 : 각 모듈 내부가 구체적으로 밝혀지며 어떤 알고리즘 사용할지 결정
  - 사용자 인터페이스 설꼐 : 사용자가 시스템 기능에 접근할 수 있도록 하는 사용자 인터페이스 설계
- 모듈 간, 외부 환경과의 인터페이스가 최소화 되도록 설계되어야 하며, 모듈 내부의 응집도는 높이고, 모듈 간의 결합도와 인터페이스는 최소화
- 설계 고려사항 
  - 품질에 직접적인 영향을 미치며 구현, 시험, 유지보수와 밀접한 관계
  - 주요 설계 원칙 : 추상화, 정보 은닉, 단계적 정제, 모듈화
  - 추상화 : 높은 추상화 단계에서 낮은 추상화 단계로 진행하며 단계적 정제가 이루어짐
    - 제어 추상화 / 절차 추상화 / 데이터 추상화
  - 정보 은닉 : 필요하지 않은 정보는 접근할 수 없도록 한 모듈 or 하부시스템이 다른 모듈의 구현에 영향을 받지 않도록 설계되는 것
    - 설계 전략에 변경이 발생하는 경우 최소한의 모듈에만 영향이 미치도록 하는 것
    - 모듈 간 독립성을 보장, 모듈 내부의 자료구조, 수행방법을 변경 시 외부 모듈은 영향 받지 않도록 함
    - 구성 요소 간 독립성 유지 차원에서 중요!!
  - 단계적 정제
    - 하향식 설계 방법에 주로 사용
    - 기본 설계 단계에서 나타나는 프로그램 구조에서 점차 모듈에 대한 세부사항을 내려가며 구체화
    - 추상화 수준은 낮아지며, 각 기능은 분해되어 해결방안 제시
  - 모듈화
    - 하향식 접근 방법을 사용하여 기능 단위로 쪼개 나가는 것이 일반적
    - 시스템을 지능적으로 관리하게 해주며, 복잡도 문제를 해결
    - 문자를 작은 단위인 모듈로 분할하여 정복
    - 시스템 유지보수 및 수정 용이
    - 모듈 수 증가 -> 각 모듈 크기 감소 -> 상호교류 증가 -> 성능 저하 및 과부하 현상 발생
- 구조도 : 모듈 구조를 나타낼 때 사용
- 순서도 : 프로그램 구조가 만들어진 후, 각 모듈들에 대한 구체적 절차 규명 및 모듈 내부의 작업 절차 표현에 이용
- 좋은 설계
  - 효율적으로 프로그램을 할 수 있게 하는 설계
  - 변화에 쉽게 적응할 수 있는 설계
  - 모듈들은 서로 독립적이며, 구성요소 내부 응집력 최대화 / 결합도 최소화
  - 모듈 간 결합도가 약할 수록 모듈 독립성 증가, 새로운 환경에 적응할 수 있는 적응력 증가
  - 모듈의 기능적 독립성 및 응집도를 극대화 하고 모듈 간 결합도를 줄이는 것이 우수한 설계 원칙

  - 설계 응집도 : 모듈 내부가 얼마나 단단히 뭉쳐져 있는지 나타내는 성숙도의 측정치 
    ![ex_screenshot](/res/응집도.JPG)
    - 우연적 응집도 : 모듈 내 구성요소가 뚜력한 연결성을 가지고 있지 않음
    - 논리적 응집도 : 논리적으로 연관된 임무, 비슷한 기능을 묶어 한 모듈 구성
    - 시간적 응집도 : 모듈 내 구성요소들이 서로 다른 기능을 같은 시간대 함께 실행하는 경우
    - 절차적 응집도 : 모듈 내 구성요소 간 연관성이 있고 특정 순서에 의해 수행되어야 하는 경우
    - 대화적 응집도 : 모듈이 여러 기능을 수행하며 모듈 내 구성요소들이 같은 입력자료 이용하거나 동일 출력 데이터를 만들어 내는 경우
      - 프로세스 절차와 데이터를 동시에 고려하여 모듈화 된 것
    - 함수적 응집도 : 한 기능을 수행하기 위해 각 구성요소들이 필요한 경우
    - 높은 응집도는 모듈의 기능적 독립성을 높이며 수정, 확장이 용이하여 고품질 소프트웨어를 만드는 기준
  - 결합도 : 모듈 사이의 상호 연관성의 복잡도
    - 모듈 간 상호교류가 많고 의존이 많을 수록 모듈 간 결합도 증가
    - 프로그램 요소 간 상호 연관성을 표시하여 주는 방법
    - 결합도가 높을 수록 다른 모듈에 영향을 주어 파문(잔상) 효과 일으킴
    - 결합도에 영향을 미치는 4가지 요소
      - 모듈들 사이의 연결 유형
      - 인터페이스의 복잡도
      - 정보 흐름의 유형
      - 바인딩 시간 
      
    ![ex_screenshot](/res/결합도.JPG)
    - 직접적 결합 없음 : 서로 독립적이고 교류가 없는 경우, 다른 모듈에 속해있어 직접 연결되지 않은 경우
    - 데이터 결합도 : 한 모듈이 간단한 데이터들을 매개 변수를 통해 다른 모듈과 주고 받는 경우
    - 스탬프 결합도 : 레코드 or 배열과 같은 복잡한 데이터 구조를 모듈 인터페이스를 통해 주고받는 경우
    - 제어 결합도 : 모듈 사이 제어 신호를 주고 받아 다른 모듈의 행위를 변경할 수 있는 경우
    - 외부 결합도 : 다른 시스템 구성요소와 결합되어 있는 경우(입출력-통신 프로토콜, 운영체제, 컴파일러)
    - 공통 결합도 : 모듈들이 간단한 타입을 갖고 있는 전역 변수 사용할 경우
    - 내용 결합도 : 한 모듈이 다른 모듈 내부에 있는 데이터, 제어 신호를사용하는 경우나 다른 모듈의 중간에 뛰어어 들어 가는 경우
  - 이해도 : 다른 프로그램 요소나 정보를 참조 않고 프로그램 및 문서를 이해할 수 있는 용이성
    - 응집도가 높을 수록 프로그램 요소들을 쉽게 이해할 수 있으며 고쳐나가기 쉬움
  - 적응도 : 새로운 환경에 적절히 대응할 수 있도록 소프트웨어를 변경시킬 수 있는 용이성
    - 적응도 높은 시스템
      - 각 구성요소 간 결합도가 낮아야함
      - 문서들은 이해하기 쉬워야하고 프로그램과 일치하도록 관리
      - 환경 독립성을 높여 수정되어야 할 부분을 지역화
      - 환경과 연관된 부분을 지역화하여 이해도, 이식성 높여야함 
      
- 구조적 설계
  - 프로그램 구조 : 소프트웨어 모듈 간의 제어를 보여주는 계층적 구조
  - 구조 도표 : 모듈 간 자료와 제어 정보의 교환, 주요 루프, 의사 결정을 나타내며 모듈 체계와 모듈 간의 상호교류 내용을 나타내주는 모델 
  
  ![ex_screenshot](/res/구조도표.JPG)
  - 정보 흐름의 유형
    - 변환 흐름 : 입력을 가공처리 하여 출력을 만들어 내는 프로세스
    - 트랜잭션 흐름 : 입력값에 의해 결정 내리며 서로 다른 처리동작을 수행하여 출력하는 프로세스
  - 자료 흐름 -> 프로그램 구조
    1. 요구 사항 분석 결과 검토, 필요 시 수정
    2. 자료 흐름 유형 조사, 변환 흐름 / 트랜잭션 흐름으로 구분
    3. 자료 흐름 유형에 따라 흐름의 경계 설정
    4. 프로그램 구조로 매핑
    5. 분할하여 제어 계층 구조 정의, 하향식 접근방법 사용
    6. 설계 가이드라인과 시스템 특성을 고려하여 정제
  - 변환 흐름 중심 설계
    - 
    
    
  
  
  
