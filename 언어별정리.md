## 사용했던 언어 정리
### Java, C++, Node.js, Python 

1. JAVA
- 플랫폼 독립적
  - HW, OS 등 플랫폼에 종속되지 않은 독립적인 바이트코드로 컴파일되며 JVM만 있으면 HW, OS를 가리지 않고 자바 프로그램의 실행이 가능
- 객체지향적 언어
  - 캡슐화, 상속, 다형성, 계층 구조 등을 지원
- 이식성 높은 언어
  - 소스 파일을 수정하지 않아도, 자바 실행 환경(JRE)이 설치되어 있는 모든 운영 체제에서 실행 가능
- 클래스로 캡슐화
  - 객체의 속성, 메서드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것
  - 접근 제한자 사용
- 소스, 클래스 파일
  - 컴파일 된 클래스(.class)에는 반드시 하나의 자바 클래스만 들어있다
  - 하나의 자바 소스 파일에 여러 클래스 작성시 컴파일하면 클래스마다 별도 클래스 파일이 생성
- 실행 모듈 
  - 자바 응용프로그램은 한 개의 클래스 파일 or 다수 클래스 파일로 구성
  - 자바의 실행은 main에서 시작되며 하나의 클래스파일에 두 개이상 main이 있을 수 없다
- 멀티 스레드 
  - 하나의 자바 프로그램에서 다수 스레드가 동시에 실행할 수 있는 환경을 지원
  - 운영체제 도움 없이 멀티스레드 프로그래밍이 가능하기에 멀티 스레드를 지원하지 않는 운영체제도 자바를 이용하면 멀티스레드 프로그램을 개발할 수 있다.
- 가비지 컬렉션 
  - 메모리를 할당 받는 기능은 있으나 반환하는 기능은 없다.
  - JVM이 가비지 컬렉션 기능에 의해 사용하지 않는 메모리를 자동으로 회수
- 실시간 응용 시스템에 부적합
  - 실행 도중 예측할 수 없는 시점에 가비지 컬렉션이 실행되므로, 프로그램 실행이 일시적 중단되고, 일정 시간 내에 실행 결과를 내야하는 실시간 시스템에는 부적합
- 자바 프로그램의 안정성
  - 물리적 주소를 사용하는 포인터 개념이 없기에 잘못된 프로그램으로 인해 시스템 중단 되는 일이 없다
- 프로그램 작성이 쉽다
  - 포인터 개념이 없어 프로그램 작성에 부담이 적다
  - 다양한 라이브러리 GUI 라이브러리 지원
- 다양한 애플리케이션 개발 
- 함수적 스타일 코딩 지원
  - 람다식을 자바 8부터 지원
  - 컬렉션 요소를 필터링, 매핑, 집계처리하는게 쉬워지고, 코드가 간결해진다
- 동적 로딩을 지원한다
  - 객체가 필요한 시점에 클래스를 동적 로딩해서 생성
  - 유지보수 시 해당 클래스만 수정하기 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요없다
- 오픈소스 라이브러리가 풍부
  - 개발 시간을 단축하면서 안정성 높은 애플리케이션을 쉽게 개발이 가능하다
- 불편한 예외처리

JVM(Java Virtual Machine)
- Java와 OS사이에서 중개자 역할을 수행하며 OS에 구에 받지 않고 재사용을 가능하게 해준다
- 메모리 관리, Garbage collection을 수행
- 스택 기반 가상머신 
- 자바프로그램 실행과정
  - 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로하는 메모리를 할당
  - JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리
  - 자바 컴파일러(javac)가 자바 소스코드를 읽어들여 자바 바이트코드(.class)로 변환
  - Class Loader를 통해 class파일들을 JVM으로 로딩
  - 로딩된 class 파일들은 Execution engine을 통해 해석
  - 해석된 바이트코드는 Runtime Date Areas에 배치되어 실질적인 수행이 이루어지게됨
  - 실행과정속 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업 수행
  
  ![ex_screenshot](/res/jvm.JPG)
- JVM 구성
  - Class Loader(클래스 로더)
    - JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업 수행하는 모듈
    - Runtime시에 동적으로 클래스를 로드한다
    - jar파일 내 저장된 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제
    - 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것
  - Execution Engine(실행 엔진)
    - 클래스를 실행시키는 역할
    - 클래스 로더가 JVM내 런타임 데이터 영역에 바이트 코드를 배치하고 실행엔진에 의해 실행된다
    - 바이트 코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경
  - Interpreter(인터프리터)
    - 실행엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행(인터프리터의 단점을 그대로 가짐)
  - JIT(Just In Time)
    - JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고 일정 정도 넘을 때에만 컴파일 수행
  - Runtime Data Area : 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간
  
    ![ex_screenshot](/res/jvm2.JPG)
    - PC Register : Thread가 시작될 때 생성되며 생설 시 마다 생성되는 공간으로 스레드마다 하나씩 존재
      - Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분 - 현재 수행중인 JVM 명령 주소를 갖음
    - JVM 스택 영역 
      - 임시로 할당되었다 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역
    - Native method stack 
      - 실제 실행할 수 있는 기계에로 작성된 프로그램을 실행시키는 영역
      - Java가 아닌 다른 언어로 작성된 코드를 위한 공간
    - Method Area(Class area = Static area)
      - 클래스 정보를 처으므 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간
      - Runtime Constant Pool - 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행하는 영역 존재
    - Heap
    
      ![ex_screenshot](/res/jvm3.JPG)
      - Permanent Generation : 생성된 객체들의 정보의 주소값이 저장된 공간
        - Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용
      - New/Young 
        - Eden : 객체들일 최초로 생성되는 공간
        - Survivor 0 / 1 : Eden에서 참조되는 객체들이 저장되는 공간
      - Old
        - New area에서 일정 시간 참조되고 있는 살아남은 객체들이 저장되는 공간
        - Eden영역에 객체가 가득차면 첫번째 GC 발생
        - Eden영역에 있는 값들을 Survivor1에 복사하고 나머지 영역 객체 삭제
    

Garbage Collector
- 정리되지 않은 메모리, 유효하지 않은 메모리 주소
- 메모리가 부족할 때 가비지들을 메모리에서 해제시켜 다른 용도로 사용할 수 있게해준다
- Stop The World : GC 실행을 위해 JVM이 애플리케이션 실행을 멈추는 것
- GC 과정 = Mark and Sweep
  - GC가 스택의 모든 변수 or Reachable 객체를 스캔하며 각각 어떤 객체를 참조하는지 찾는 과정(Mark)
  - Stop the world 발생
  - 이후 Mark되어있지 않은 객체들을 힙에서 제거하는 과정(Sweep)
- Minor GC와 Major GC
  - JVM의 Heap은 Young, Old, Perm 세 영역으로 나뉨
  - Young 영역에서 발생한 GC를 Minor GC
  - 나머지 영역에서 발생한 GC를 Major GC
  - Young 영역 : 새롭게 생성한 객체가 위치, 객체가 금방 unreachable 상태가 되기에 많은 객체가 생성되고 사라짐
  - Old 영역 : Young영역에서 reahable 상태를 유지해 살아남은 객체가 복사되며 Young영역보다 크게 할당, GC는 적게 발생
  - Perm 영역 : Method Area라고하며, 클래스와 메소드 정보와 같이 자바언어 레벨에서는 거의 사용되지 않음
- GC 4가지 방식
  1. 시리얼 콜렉터 
    - Young, Old 영역이 시리얼하게(연속적으로) 처리되며 하나의 CPU를 사용
    - stop the world
  2. 병렬 콜렉터
    - throughput collector, 다른 CPU가 대기 상태로 남아 있는 것을 최소화 하는 것
    - 많은 CPU를 사용하기에 GC 부하를 줄이고 애플리케이션 처리량을 증가할 수 있다
  3. 병렬 컴팩팅 콜렉터
    - old 영역에서 Mark - Sweep - Compact 3단계를 거쳐 수행
    - Mark : 살아 있는 객체를 식별해 표시해 놓은 단계
    - Sweep : 이전 GC를 수행하여 컴팩션된 영역에 살아 있는 객체의 위치를 조사
    - Compact : 컴팩션을 수행하는 단계, 수행 이후 컴팩션된 영역과 비어 있는 영역으로 나뉨
  4. CMS 콜렉터 
    - low-latency collector, 힙 메모리 영역의 크기가 클 때 적합
    - old 영역에서 4단계 수행
    - mark : 매우 짧은 대기 시간으로 살아 있는 객체를 찾는 단계
    - sweep : 서버 수행과 동시에 살아 있는 객체에 표시해 놓는 단계
    - remark : Concurrent 표시 단계에서 표시하는 동안 변경된 객체에 대해 다시 표시하는 단계
    - Concurrent Sweep : 표시되어 있는 쓰레기를 정리하는 단계
    
OOP(Object Oriented Programing)
- 컴퓨터 로그램을 "객체"들의 모임으로 파악하고자하는 프로그래밍의 패러다임 중 하나
- 각 객체들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다
- 장점
  - 프로그램을 유연하고 변경을 용이하게 만든다
  - 프로그램의 개발과 보수를 간편하게 만든다
  - 직관적인 코드 분석을 가능하게 한다
  - 강한 응집력과 약한 결합력을 지향한다
  - 유지보수 용이성
  - 잘 만들어진 객체는 재사용이 가능하다
- 단점 
  - 처리속도가 느리다
  - 설계하기가 쉽지 않다
- 기본 구성 요소
  - 클래스 : 같은 종류의 집단에 속하는 속성과 행위를 정의한 것
  - 객체 : 클래스의 인스턴스, 상위 클래스 속성을 가지고 있으며 개별적 특성과 행위를 가짐
  - 메서드 : 클래스로부터 생성된 객체를 사용하는 방법, 객체의 속성을 조작하는데 사용
- OOP 특성
  - 캡슐화 : 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게하는 작업
    - 내부의 구현은 감추고 모듈 내에서 응집도를 높이며 외부로 부터 노출을 줄여 모듈간 결합도를 떨어뜨리는 개념
    - 강한 응집력, 약한 결합력
  - 추상화 : 객체들이 가진 공통의 특성을 파악하고 불필요한 특성들을 제거하는 과정
    - 표현 대상의 특징에 대한 서술
    - 속성 위주가 아닌 동작 위주로 정의하는 작업을 하는 것을 주의해야함
    - 동작에 필요한 속성들을 먼저 정의하느 것이 좋다
  - 상속
    - 하나의 클래스가 가지고 있던 특징을 그대로 다른 클래스가 물려 받는것
    - 재사용, 유연성 증가
    - Overriding
      - 부모 클래스의 메서드와 같은 메서드를 재정의 하는것
      - 같은 이름의 메서드가 여러 클래스에서 다른 기능을 하는 것
  - 다형성
    - 한 요소에 여러 개념을 넣어 놓는 것
    - 상속 계층을 따라 각각의 클래스에 한가지 이름을 줄 수 있다, 같은 명령을 다른 오브젝트에 줄 수 있다
    - Overriding : 같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것
    - Overloading : 같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것
    - 객체 관계를 조직적으로 나타낼 수 있다.
    - 다형성 구현 방법 : 인터페이스 / 추상 클래스 / 메서들 오버라이딩 / 메서드 
- SOLID 원칙
  - SRP(Single Responsibility Principle) : 단일 책임 원칙
    - 객체는 하나의 책임만 맡아야 한다
    - DB 정규화와 ㅏ비슷
    - 목적 : 변화에 대한 유연성 확보
    - 낮은 결합도, 높은 응집도 추구 
  - OCP(Open Closed Principle) : 개발-폐쇄 원칙
    - 모듈은 확장에는 열려있어야하고 변경에는 닫혀 있어야함
  - LSP(Liscov Substitution Principle) : 리스코프 치환 원칙
    - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙
    - 인터페이스만 알면 구현체를 몰라도 사용 가능해야 함
    - 다형성
  - ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
    - 클라이언트에서 사용하지 않는 메서드는 사용해서 안된다 ( 인터페이스를 다시 작게 나누어 만듬)
    - 하나의 일반적인 인터페이스 보다 구체적인 여러개의 인터페이스가 나음
    - 파생 클래스 입장에서 사용할 때 100% 구현할 수 있는 인터페이스만 사용해야한다
    - 두개 이상의 인터페이스가 필요한 경우 다중 인터페이스 상속으로 구현하는 것이 좋다
  - DIP(Dependency Inversion Principle) : 의존성 역전 원칙
    - 상위 모듈은 하위 모듈에 의존해서 안됨, 상위 모듈과 하위 모듈 추상화에 의존해야 한다
    - 추상화는 세부 사항에 의존해서 안됨, 세부사항이 추상화에 의존해야 한다

인터페이스와 추상클래스    
- 인터페이스
  - 상수와 추상메서드의 집합
  - 생성자를 가질 수 없으며 객체화가 불가능하다
  - 다중 상속을 지원하며, 구현체에 여러개의 인터페이스를 구현할 수 있다
  <pre><code>
    interface Printable {
      public abstarct void paper();
      // Default Method : 실행 내용까지 있음
      public default void setPrint(boolean color){
        if(color){
          System.out.println("컬러 출력");
        }
        else {
          System.out.println("흑백 출력");
        }
      }
    }
  </code></pre> 
  - 디폴트 메서드의 목적은 기존 인터페이스 기능을 확장하며 구현체에 공통적으로 들어갈 기능을 디폴트 메서드 내부에 작성함으로 반복되는 코드의 작성을 줄여줌
- 추상 클래스
  - 필드, 생성자, 추상 메서드를 가질 수 있다
  - 생성자를 가지기 때문에 객체화가 가능
  - 추상 클래스는 상속을 통해서만 사용이 가능하며, 하위 클래스의 생성자에서 super()변수를 사용해 추상 클래스의 생성자를 부르고 초기화 시킨다
  - 단, "추상 메서드를 하나라도 가지는 클래스는 추상 클래스가 되어야한다"
  <pre><code>
    	public abstract class AbstractClass {
      		// Field
	        private String name;
	        private String id;

      		// Constructor 
        	public AbstractClass(String name, String id){
            		this.name = name;
            		this.id = id;
        	}
	
	        // Abstract Method
        	public method() { }
    	}

    	public class RealClass extends AbstractClass {
      		private String number;

      		public RealClass(String name, String id, String number) {
        		super(name, id); 
        		this.number = number;
      		}
   	}
  </code></pre>
  
Serializable과 transient
- Serializable
  - 데이터를 파일에 쓰거나, 네트워크를 타고 다른 곳에 전송할 때는 바이트 단위로 분해하여 순차적으로 보내야함 -> 직렬화(Serialization)
  - 기본 자료형은 정해진 바이트 변수이기 때문에 바이트 단위로 전송 후 조립하는 데 문제가 없다
  - 객체 크기는 가변적이며, 객체를 구성하는 자료형들으리 종류와 수에 따라 객체 크기는 다양하게 바뀔 수 있다 -> 이러한 객체를 직렬화 하기위해 Serializable 인터페이스를 구현
- 직렬화가 가능한 객체 조건
  - 기본형 타입
  - Serializable 인터페이스를 구현한 객체여야 한다
  - 해당 객체의 멤버들 중 Serializable 인터페이스가 구현되지 않은게 존재하면 안됨
  - transient가 사용된 멤버는 전송되지 않는다
- transient
  - 객체의 데이터 중 일부 데이터는 여러가지 이유로 전송 하지 않을 수 있다 -> 직렬화에 제외하기 위해 transient 변수를 선언함
  - 직렬화 조건 중 객체의 멤버들 중 Serializable 인터페이스 구현되지 않은 객체가 있으면, 직렬화 할 수 없다
  - 직렬화 해야하는 객체 안의 객체 중 Serializavle 인터페이스 구현되지 않으면 전송하지 않아도 되는 객체 앞에 transient를 선언 
  <pre><code>
	public class UserClass implements Serializable{
	
		private static final long serialVersionUID = 4220461820168818967L;
	
		String name;
	
		// age 비 전송
		transient int age;
	
		// NonSerializable 클래스
		transient NonSerializableClass nonSerializable;
	
	
		public UserClass() {		
		}
	
		public UserClass(String name, int age){
			this.name = name;
			this.age = age;
			this.nonSerializable = new NonSerializableClass(false);
		
		}

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public int getAge() {
			return age;
		}

		public void setAge(int age) {
			this.age = age;
		}

		public NonSerializableClass getNonSerializable() {
			return nonSerializable;
		}

		public void setNonSerializable(NonSerializableClass nonSerializable) {
			this.nonSerializable = nonSerializable;
		}

		@Override
		public String toString() {
			return "UserClass [name=" + name + ", age=" + age
					+ ", nonSerializable=" + nonSerializable + "]";
		}
	
	}
  </code><pre>

call(pass) by reference / pass by value
- call by value : 메소드 호출 시 사용되는 인자의 메모리에 저장되어 있는 값을 복사하여 보냄(자바의 기본형)
- call by reference :  메서드 호출 시 사용되는 인자가 아닌 주소를 넘겨줌으로, 주소를 참조하여 데이터를 변경할 수 있다   

Wrapper 클래스

자바 콜레션 프레임워크

comparable / comparator

2. C++

3. Node.js / JavaScript 
Node.js
- 확장성 있는 네트워크 애플리케이션개발에 사용되는 소프트웨어 플랫폼
- 자바스크립트를 활용하며 Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능을 가짐
- 내장 http 서버 라이브러리를 포함하고 있어 웹 서버에서 아파치등 별도 sw없이 동작 가능
- 특징
  - v8 엔진
    - 빠른 프로퍼티 접근 
    - 동적인 기계어 코드 생성
    - 효율적인 가비지 콜렉션
  - 쓰레드 기반 동기방식
    - 하나의 쓰레드가 request를 받으면 모든 처리가 완료될때까지 기다리다 처리결과가 완료되면 다시 응답보냄
    - 기존 업무 처리가 완료되기전 또다른 request가 있으면 새로운 쓰레드가 업무를 처리
    - 동시 reqeust가 많은 경우 많은 쓰레드가 필요하게되어 서버 과부하
  - 단일 쓰레드 이벤트 루프 기반 비동기 방식
    - 하나의 스레드가 request를 받으면 바로 다음 처리에 요청을 보내놓고 다른 작업 처리하다 먼저 요청한 작업이 끝나면 이벤트를 받아 응답을 보냄
    - 동시 request가 오더라도 처리가 완료될때까지 기다리지 않아도 되기 때문에 서버 부하가 작다
- Node.js 비동기 처리
  - Node.js는 비동기 I/O를 지원하며 Single-Thread 기반으로 동작하는 서버
    ![ex_screenshot](/res/node1.png)
    
  - 이벤트 기반 
    - 클라이언트 요청을 비동기로 처리하기위해 이벤트가 발생하며 서버 내부에 메시지 형태로 전달
    - 서버 내부에서는 메시지를 Event Loop가 처리
    - Event Loop가 처리하는 동안 제어권은 다음 요청으로 넘어가고 처리 완료되면 Callback을 호출하여 처리완료를 호출측에 알림
    - Event Loop는 요청을 처리하기위해 내부적으로 약간의 Threhad와 프로세스를 사용
    - Non-Blocking IO 또는 내부 처리를 위한 목적으로만 사용, 요청 자체를 Thread로 하지 않음
    - Multi-Threard 방식의 서버에 비해 Thread수와 오베헤드가 훨씬 적음
    - Event Loop는 Single-Thread로 이루어짐 (요청 처리는 하나의 Thread안에서 처리됨을 의미)
    - 이벤트 호출 측에 비동기로 처리되지만 처리 작업 자체가 오래걸리면 전체 서버 처리에 영향을 줌
- 장점
  - 자바스크립트를 동일하게 사용해 서버단 로직을 처리 할 수 있다
  - 새로운 언어를 습득하지 않고도 자바스크립트를 활용해 서버기술을 빨리 개발/응용할 수 있다
  - 개발이 빠르고 쉽다
  - Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능
  - 이벤트 기반 비동기 방식 -> 서버 무리가 작다
  - npm을 통한 다양한 모듈(패키지)제공 -< 개발 속도와 효율성 향상
- 단점
  - 서버단 로직이 복잡할 경우 콜백함수 늪에 빠질 수 있다
  - 비동기 방식을 이벤트를 보내기에 java 개발 방식으로 설계하고 프로그래밍하면 문제가 발생
  - 단일 스레드이기에 하나의 작업 자체가 많이 걸리는 웹서비스는 어울리지 않음
  - 코드가 수행되어야 코드에 에러가 있는지 알수 있으며, 에러날 경우 프로세스가 내려가기 때문에 테스트가 엄청 중요하다 -> 반드시 모든 케이스에 대해 소스코드를 검증해야 한다.
- 간단한 로직, 대용량(동시에 여러 request처리), 빠른 응답시간 및 개발 요구, 비동기 방식에 어울리는 서비스에는 node.js로 개발하는 것이 좋음
- 단일 처리가 오래걸리거나 서버 체크로직이 많은 경우 싱글스레드, 비동기 방식이기에 node.js는 적절하지 않음, 업무 복잡도/난이도가 높은 경우에도 적절하지 않음 -> 에러 발생시 서버가 죽기 때문에
- Node.js를 어디서 사용할까?
  - 입출력이 잦은 어플리케이션
  - 데이터 스트리밍 어플리케이션
  - 데이터를 실시간으로 다루는 어플리케이션
  - JSON API기반 어플리케이션
  - 싱글페이지 어플리케이션
- Node.js를 쓰지 말아야 할 곳
  - CPU 사용률이 높은 어플리케이션

4. Python
- 대화 기능의 인터프리터 언어 : 객체지향 기능을 강력히 지원하는 대화형 인터프리터 언어
  - 컴파일 과정이 필요없고 실행결과를 바로 확인하며 코딩할 수 있다
  - 속도향상을 위해 byte 코드를 일부 생성하거나 JIT를 사용
- 동적인 데이터 타입 결정 지원
- 멀티패러다임 프로그래밍 언어
  - 절차적 언어 지원, 객체지향, 함수형 프로그래밍 언어
- 플랫폼에 독립적인 언어
- 간단하고 쉬운 문법
- 고수준의 내장 객체 자료형을 제공
- 메모리 자동 관리 - 가비지 콜렉션 기능을 사용
- 모듈 단위의 코드를 쉽게 작성하고 결합할 수 있다
- 많은 수의 라이브러리를 제공
- 높은 확장성
- 다른 언어로 작성된 모듈을 연결하는 Glue Language로 이용(CPyton, Jython, IronPython, Pypy)
- 웹 프로그래밍, 데이터베이스 프로그래밍, 수치연산 등 다양한 분야 개발 가능


5. 언어 공통적인 부분
동적 바인딩 / 정적바인딩
