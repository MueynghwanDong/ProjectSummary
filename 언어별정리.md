## 사용했던 언어 정리
### Java, C++, Node.js, Python 

1. JAVA
- 플랫폼 독립적
  - HW, OS 등 플랫폼에 종속되지 않은 독립적인 바이트코드로 컴파일되며 JVM만 있으면 HW, OS를 가리지 않고 자바 프로그램의 실행이 가능
- 객체지향적 언어
  - 캡슐화, 상속, 다형성, 계층 구조 등을 지원
- 이식성 높은 언어
  - 소스 파일을 수정하지 않아도, 자바 실행 환경(JRE)이 설치되어 있는 모든 운영 체제에서 실행 가능
- 클래스로 캡슐화
  - 객체의 속성, 메서드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것
  - 접근 제한자 사용
- 소스, 클래스 파일
  - 컴파일 된 클래스(.class)에는 반드시 하나의 자바 클래스만 들어있다
  - 하나의 자바 소스 파일에 여러 클래스 작성시 컴파일하면 클래스마다 별도 클래스 파일이 생성
- 실행 모듈 
  - 자바 응용프로그램은 한 개의 클래스 파일 or 다수 클래스 파일로 구성
  - 자바의 실행은 main에서 시작되며 하나의 클래스파일에 두 개이상 main이 있을 수 없다
- 멀티 스레드 
  - 하나의 자바 프로그램에서 다수 스레드가 동시에 실행할 수 있는 환경을 지원
  - 운영체제 도움 없이 멀티스레드 프로그래밍이 가능하기에 멀티 스레드를 지원하지 않는 운영체제도 자바를 이용하면 멀티스레드 프로그램을 개발할 수 있다.
- 가비지 컬렉션 
  - 메모리를 할당 받는 기능은 있으나 반환하는 기능은 없다.
  - JVM이 가비지 컬렉션 기능에 의해 사용하지 않는 메모리를 자동으로 회수
- 실시간 응용 시스템에 부적합
  - 실행 도중 예측할 수 없는 시점에 가비지 컬렉션이 실행되므로, 프로그램 실행이 일시적 중단되고, 일정 시간 내에 실행 결과를 내야하는 실시간 시스템에는 부적합
- 자바 프로그램의 안정성
  - 물리적 주소를 사용하는 포인터 개념이 없기에 잘못된 프로그램으로 인해 시스템 중단 되는 일이 없다
- 프로그램 작성이 쉽다
  - 포인터 개념이 없어 프로그램 작성에 부담이 적다
  - 다양한 라이브러리 GUI 라이브러리 지원
- 다양한 애플리케이션 개발 
- 함수적 스타일 코딩 지원
  - 람다식을 자바 8부터 지원
  - 컬렉션 요소를 필터링, 매핑, 집계처리하는게 쉬워지고, 코드가 간결해진다
- 동적 로딩을 지원한다
  - 객체가 필요한 시점에 클래스를 동적 로딩해서 생성
  - 유지보수 시 해당 클래스만 수정하기 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요없다
- 오픈소스 라이브러리가 풍부
  - 개발 시간을 단축하면서 안정성 높은 애플리케이션을 쉽게 개발이 가능하다
- 불편한 예외처리

JVM(Java Virtual Machine)
- Java와 OS사이에서 중개자 역할을 수행하며 OS에 구에 받지 않고 재사용을 가능하게 해준다
- 메모리 관리, Garbage collection을 수행
- 스택 기반 가상머신 
- 자바프로그램 실행과정
  - 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로하는 메모리를 할당
  - JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리
  - 자바 컴파일러(javac)가 자바 소스코드를 읽어들여 자바 바이트코드(.class)로 변환
  - Class Loader를 통해 class파일들을 JVM으로 로딩
  - 로딩된 class 파일들은 Execution engine을 통해 해석
  - 해석된 바이트코드는 Runtime Date Areas에 배치되어 실질적인 수행이 이루어지게됨
  - 실행과정속 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업 수행
  
  ![ex_screenshot](/res/jvm.jpg)
- JVM 구성
  - Class Loader(클래스 로더)
    - JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업 수행하는 모듈
    - Runtime시에 동적으로 클래스를 로드한다
    - jar파일 내 저장된 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제
    - 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것
  - Execution Engine(실행 엔진)
    - 클래스를 실행시키는 역할
    - 클래스 로더가 JVM내 런타임 데이터 영역에 바이트 코드를 배치하고 실행엔진에 의해 실행된다
    - 바이트 코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경
  - Interpreter(인터프리터)
    - 실행엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행(인터프리터의 단점을 그대로 가짐)
  - JIT(Just In Time)
    - JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고 일정 정도 넘을 때에만 컴파일 수행
  - Runtime Data Area : 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간
  
    ![ex_screenshot](/res/jvm2.jpg)
    - PC Register : Thread가 시작될 때 생성되며 생설 시 마다 생성되는 공간으로 스레드마다 하나씩 존재
      - Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분 - 현재 수행중인 JVM 명령 주소를 갖음
    - JVM 스택 영역 
      - 임시로 할당되었다 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역
    - Native method stack 
      - 실제 실행할 수 있는 기계에로 작성된 프로그램을 실행시키는 영역
      - Java가 아닌 다른 언어로 작성된 코드를 위한 공간
    - Method Area(Class area = Static area)
      - 클래스 정보를 처으므 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간
      - Runtime Constant Pool - 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행하는 영역 존재
    - Heap
    
      ![ex_screenshot](/res/jvm3.jpg)
      - Permanent Generation : 생성된 객체들의 정보의 주소값이 저장된 공간
        - Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용
      - New/Young 
        - Eden : 객체들일 최초로 생성되는 공간
        - Survivor 0 / 1 : Eden에서 참조되는 객체들이 저장되는 공간
      - Old
        - New area에서 일정 시간 참조되고 있는 살아남은 객체들이 저장되는 공간
        - Eden영역에 객체가 가득차면 첫번째 GC 발생
        - Eden영역에 있는 값들을 Survivor1에 복사하고 나머지 영역 객체 삭제
    

Garbage Collector
- 정리되지 않은 메모리, 유효하지 않은 메모리 주소
- 메모리가 부족할 때 가비지들을 메모리에서 해제시켜 다른 용도로 사용할 수 있게해준다
- Stop The World : GC 실행을 위해 JVM이 애플리케이션 실행을 멈추는 것
- GC 과정 = Mark and Sweep
  - GC가 스택의 모든 변수 or Reachable 객체를 스캔하며 각각 어떤 객체를 참조하는지 찾는 과정(Mark)
  - Stop the world 발생
  - 이후 Mark되어있지 않은 객체들을 힙에서 제거하는 과정(Sweep)
- Minor GC와 Major GC
  - JVM의 Heap은 Young, Old, Perm 세 영역으로 나뉨
  - Young 영역에서 발생한 GC를 Minor GC
  - 나머지 영역에서 발생한 GC를 Major GC
  - Young 영역 : 새롭게 생성한 객체가 위치, 객체가 금방 unreachable 상태가 되기에 많은 객체가 생성되고 사라짐
  - Old 영역 : Young영역에서 reahable 상태를 유지해 살아남은 객체가 복사되며 Young영역보다 크게 할당, GC는 적게 발생
  - Perm 영역 : Method Area라고하며, 클래스와 메소드 정보와 같이 자바언어 레벨에서는 거의 사용되지 않음
- GC 4가지 방식
  1. 시리얼 콜렉터 
    - Young, Old 영역이 시리얼하게(연속적으로) 처리되며 하나의 CPU를 사용
    - stop the world
  2. 병렬 콜렉터
    - throughput collector, 다른 CPU가 대기 상태로 남아 있는 것을 최소화 하는 것
    - 많은 CPU를 사용하기에 GC 부하를 줄이고 애플리케이션 처리량을 증가할 수 있다
  3. 병렬 컴팩팅 콜렉터
    - old 영역에서 Mark - Sweep - Compact 3단계를 거쳐 수행
    - Mark : 살아 있는 객체를 식별해 표시해 놓은 단계
    - Sweep : 이전 GC를 수행하여 컴팩션된 영역에 살아 있는 객체의 위치를 조사
    - Compact : 컴팩션을 수행하는 단계, 수행 이후 컴팩션된 영역과 비어 있는 영역으로 나뉨
  4. CMS 콜렉터 
    - low-latency collector, 힙 메모리 영역의 크기가 클 때 적합
    - old 영역에서 4단계 수행
    - mark : 매우 짧은 대기 시간으로 살아 있는 객체를 찾는 단계
    - sweep : 서버 수행과 동시에 살아 있는 객체에 표시해 놓는 단계
    - remark : Concurrent 표시 단계에서 표시하는 동안 변경된 객체에 대해 다시 표시하는 단계
    - Concurrent Sweep : 표시되어 있는 쓰레기를 정리하는 단계
    
OOP


2. C++

3. Node.js

4. Python
