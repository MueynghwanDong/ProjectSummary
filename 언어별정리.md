## 사용했던 언어 정리
### Java, C++, Node.js, Python 

1. JAVA
- 플랫폼 독립적
  - HW, OS 등 플랫폼에 종속되지 않은 독립적인 바이트코드로 컴파일되며 JVM만 있으면 HW, OS를 가리지 않고 자바 프로그램의 실행이 가능
- 객체지향적 언어
  - 캡슐화, 상속, 다형성, 계층 구조 등을 지원
- 이식성 높은 언어
  - 소스 파일을 수정하지 않아도, 자바 실행 환경(JRE)이 설치되어 있는 모든 운영 체제에서 실행 가능
- 클래스로 캡슐화
  - 객체의 속성, 메서드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것
  - 접근 제한자 사용
- 소스, 클래스 파일
  - 컴파일 된 클래스(.class)에는 반드시 하나의 자바 클래스만 들어있다
  - 하나의 자바 소스 파일에 여러 클래스 작성시 컴파일하면 클래스마다 별도 클래스 파일이 생성
- 실행 모듈 
  - 자바 응용프로그램은 한 개의 클래스 파일 or 다수 클래스 파일로 구성
  - 자바의 실행은 main에서 시작되며 하나의 클래스파일에 두 개이상 main이 있을 수 없다
- 멀티 스레드 
  - 하나의 자바 프로그램에서 다수 스레드가 동시에 실행할 수 있는 환경을 지원
  - 운영체제 도움 없이 멀티스레드 프로그래밍이 가능하기에 멀티 스레드를 지원하지 않는 운영체제도 자바를 이용하면 멀티스레드 프로그램을 개발할 수 있다.
- 가비지 컬렉션 
  - 메모리를 할당 받는 기능은 있으나 반환하는 기능은 없다.
  - JVM이 가비지 컬렉션 기능에 의해 사용하지 않는 메모리를 자동으로 회수
- 실시간 응용 시스템에 부적합
  - 실행 도중 예측할 수 없는 시점에 가비지 컬렉션이 실행되므로, 프로그램 실행이 일시적 중단되고, 일정 시간 내에 실행 결과를 내야하는 실시간 시스템에는 부적합
- 자바 프로그램의 안정성
  - 물리적 주소를 사용하는 포인터 개념이 없기에 잘못된 프로그램으로 인해 시스템 중단 되는 일이 없다
- 프로그램 작성이 쉽다
  - 포인터 개념이 없어 프로그램 작성에 부담이 적다
  - 다양한 라이브러리 GUI 라이브러리 지원
- 다양한 애플리케이션 개발 
- 함수적 스타일 코딩 지원
  - 람다식을 자바 8부터 지원
  - 컬렉션 요소를 필터링, 매핑, 집계처리하는게 쉬워지고, 코드가 간결해진다
- 동적 로딩을 지원한다
  - 객체가 필요한 시점에 클래스를 동적 로딩해서 생성
  - 유지보수 시 해당 클래스만 수정하기 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요없다
- 오픈소스 라이브러리가 풍부
  - 개발 시간을 단축하면서 안정성 높은 애플리케이션을 쉽게 개발이 가능하다
- 불편한 예외처리

JVM(Java Virtual Machine)
- Java와 OS사이에서 중개자 역할을 수행하며 OS에 구에 받지 않고 재사용을 가능하게 해준다
- 메모리 관리, Garbage collection을 수행
- 스택 기반 가상머신 
- 자바프로그램 실행과정
  - 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로하는 메모리를 할당
  - JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리
  - 자바 컴파일러(javac)가 자바 소스코드를 읽어들여 자바 바이트코드(.class)로 변환
  - Class Loader를 통해 class파일들을 JVM으로 로딩
  - 로딩된 class 파일들은 Execution engine을 통해 해석
  - 해석된 바이트코드는 Runtime Date Areas에 배치되어 실질적인 수행이 이루어지게됨
  - 실행과정속 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업 수행
  
  ![ex_screenshot](/res/jvm.JPG)
- JVM 구성
  - Class Loader(클래스 로더)
    - JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업 수행하는 모듈
    - Runtime시에 동적으로 클래스를 로드한다
    - jar파일 내 저장된 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제
    - 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것
  - Execution Engine(실행 엔진)
    - 클래스를 실행시키는 역할
    - 클래스 로더가 JVM내 런타임 데이터 영역에 바이트 코드를 배치하고 실행엔진에 의해 실행된다
    - 바이트 코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경
  - Interpreter(인터프리터)
    - 실행엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행(인터프리터의 단점을 그대로 가짐)
  - JIT(Just In Time)
    - JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고 일정 정도 넘을 때에만 컴파일 수행
  - Runtime Data Area : 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간
  
    ![ex_screenshot](/res/jvm2.JPG)
    - PC Register : Thread가 시작될 때 생성되며 생설 시 마다 생성되는 공간으로 스레드마다 하나씩 존재
      - Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분 - 현재 수행중인 JVM 명령 주소를 갖음
    - JVM 스택 영역 
      - 임시로 할당되었다 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역
    - Native method stack 
      - 실제 실행할 수 있는 기계에로 작성된 프로그램을 실행시키는 영역
      - Java가 아닌 다른 언어로 작성된 코드를 위한 공간
    - Method Area(Class area = Static area)
      - 클래스 정보를 처으므 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간
      - Runtime Constant Pool - 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행하는 영역 존재
    - Heap
    
      ![ex_screenshot](/res/jvm3.JPG)
      - Permanent Generation : 생성된 객체들의 정보의 주소값이 저장된 공간
        - Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용
      - New/Young 
        - Eden : 객체들일 최초로 생성되는 공간
        - Survivor 0 / 1 : Eden에서 참조되는 객체들이 저장되는 공간
      - Old
        - New area에서 일정 시간 참조되고 있는 살아남은 객체들이 저장되는 공간
        - Eden영역에 객체가 가득차면 첫번째 GC 발생
        - Eden영역에 있는 값들을 Survivor1에 복사하고 나머지 영역 객체 삭제
    

Garbage Collector
- 정리되지 않은 메모리, 유효하지 않은 메모리 주소
- 메모리가 부족할 때 가비지들을 메모리에서 해제시켜 다른 용도로 사용할 수 있게해준다
- Stop The World : GC 실행을 위해 JVM이 애플리케이션 실행을 멈추는 것
- GC 과정 = Mark and Sweep
  - GC가 스택의 모든 변수 or Reachable 객체를 스캔하며 각각 어떤 객체를 참조하는지 찾는 과정(Mark)
  - Stop the world 발생
  - 이후 Mark되어있지 않은 객체들을 힙에서 제거하는 과정(Sweep)
- Minor GC와 Major GC
  - JVM의 Heap은 Young, Old, Perm 세 영역으로 나뉨
  - Young 영역에서 발생한 GC를 Minor GC
  - 나머지 영역에서 발생한 GC를 Major GC
  - Young 영역 : 새롭게 생성한 객체가 위치, 객체가 금방 unreachable 상태가 되기에 많은 객체가 생성되고 사라짐
  - Old 영역 : Young영역에서 reahable 상태를 유지해 살아남은 객체가 복사되며 Young영역보다 크게 할당, GC는 적게 발생
  - Perm 영역 : Method Area라고하며, 클래스와 메소드 정보와 같이 자바언어 레벨에서는 거의 사용되지 않음
- GC 4가지 방식
  1. 시리얼 콜렉터 
    - Young, Old 영역이 시리얼하게(연속적으로) 처리되며 하나의 CPU를 사용
    - stop the world
  2. 병렬 콜렉터
    - throughput collector, 다른 CPU가 대기 상태로 남아 있는 것을 최소화 하는 것
    - 많은 CPU를 사용하기에 GC 부하를 줄이고 애플리케이션 처리량을 증가할 수 있다
  3. 병렬 컴팩팅 콜렉터
    - old 영역에서 Mark - Sweep - Compact 3단계를 거쳐 수행
    - Mark : 살아 있는 객체를 식별해 표시해 놓은 단계
    - Sweep : 이전 GC를 수행하여 컴팩션된 영역에 살아 있는 객체의 위치를 조사
    - Compact : 컴팩션을 수행하는 단계, 수행 이후 컴팩션된 영역과 비어 있는 영역으로 나뉨
  4. CMS 콜렉터 
    - low-latency collector, 힙 메모리 영역의 크기가 클 때 적합
    - old 영역에서 4단계 수행
    - mark : 매우 짧은 대기 시간으로 살아 있는 객체를 찾는 단계
    - sweep : 서버 수행과 동시에 살아 있는 객체에 표시해 놓는 단계
    - remark : Concurrent 표시 단계에서 표시하는 동안 변경된 객체에 대해 다시 표시하는 단계
    - Concurrent Sweep : 표시되어 있는 쓰레기를 정리하는 단계
    
OOP
추상화
캡슐화
상속
다형성
Composition/Assosiation/Aggregation
autoboxing / unboxing
오바라이딩/ 오버로딩
복사 생성자 
인터페이스 / 추상클래스
pass by reference, pass by value
transsient 변수 
동적 /정적 바인딩
래퍼 클래스
자바 콜레션 프레임워크


comparable / comparator
2. C++

3. Node.js
- 확장성 있는 네트워크 애플리케이션개발에 사용되는 소프트웨어 플랫폼
- 자바스크립트를 활용하며 Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능을 가짐
- 내장 http 서버 라이브러리를 포함하고 있어 웹 서버에서 아파치등 별도 sw없이 동작 가능
- 특징
  - v8 엔진
    - 빠른 프로퍼티 접근 
    - 동적인 기계어 코드 생성
    - 효율적인 가비지 콜렉션
  - 쓰레드 기반 동기방식
    - 하나의 쓰레드가 request를 받으면 모든 처리가 완료될때까지 기다리다 처리결과가 완료되면 다시 응답보냄
    - 기존 업무 처리가 완료되기전 또다른 request가 있으면 새로운 쓰레드가 업무를 처리
    - 동시 reqeust가 많은 경우 많은 쓰레드가 필요하게되어 서버 과부하
  - 단일 쓰레드 이벤트 루프 기반 비동기 방식
    - 하나의 스레드가 request를 받으면 바로 다음 처리에 요청을 보내놓고 다른 작업 처리하다 먼저 요청한 작업이 끝나면 이벤트를 받아 응답을 보냄
    - 동시 request가 오더라도 처리가 완료될때까지 기다리지 않아도 되기 때문에 서버 부하가 작다
- 장점
  - 자바스크립트를 동일하게 사용해 서버단 로직을 처리 할 수 있다
  - 새로운 언어를 습득하지 않고도 자바스크립트를 활용해 서버기술을 빨리 개발/응용할 수 있다
  - 개발이 빠르고 쉽다
  - Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능
  - 이벤트 기반 비동기 방식 -> 서버 무리가 작다
  - npm을 통한 다양한 모듈(패키지)제공 -< 개발 속도와 효율성 향상
- 단점
  - 서버단 로직이 복잡할 경우 콜백함수 늪에 빠질 수 있다
  - 비동기 방식을 이벤트를 보내기에 java 개발 방식으로 설계하고 프로그래밍하면 문제가 발생
  - 단일 스레드이기에 하나의 작업 자체가 많이 걸리는 웹서비스는 어울리지 않음
  - 코드가 수행되어야 코드에 에러가 있는지 알수 있으며, 에러날 경우 프로세스가 내려가기 때문에 테스트가 엄청 중요하다 -> 반드시 모든 케이스에 대해 소스코드를 검증해야 한다.
- 간단한 로직, 대용량(동시에 여러 request처리), 빠른 응답시간 및 개발 요구, 비동기 방식에 어울리는 서비스에는 node.js로 개발하는 것이 좋음
- 단일 처리가 오래걸리거나 서버 체크로직이 많은 경우 싱글스레드, 비동기 방식이기에 node.js는 적절하지 않음, 업무 복잡도/난이도가 높은 경우에도 적절하지 않음 -> 에러 발생시 서버가 죽기 때문에
4. Python
- 대화 기능의 인터프리터 언어 : 객체지향 기능을 강력히 지원하는 대화형 인터프리터 언어
  - 컴파일 과정이 필요없고 실행결과를 바로 확인하며 코딩할 수 있다
  - 속도향상을 위해 byte 코드를 일부 생성하거나 JIT를 사용
- 동적인 데이터 타입 결정 지원
- 멀티패러다임 프로그래밍 언어
  - 절차적 언어 지원, 객체지향, 함수형 프로그래밍 언어
- 플랫폼에 독립적인 언어
- 간단하고 쉬운 문법
- 고수준의 내장 객체 자료형을 제공
- 메모리 자동 관리 - 가비지 콜렉션 기능을 사용
- 모듈 단위의 코드를 쉽게 작성하고 결합할 수 있다
- 많은 수의 라이브러리를 제공
- 높은 확장성
- 다른 언어로 작성된 모듈을 연결하는 Glue Language로 이용(CPyton, Jython, IronPython, Pypy)
- 웹 프로그래밍, 데이터베이스 프로그래밍, 수치연산 등 다양한 분야 개발 가능
