## 기술 개념 정리

1. Spring
- Spring (Spring Framework)
  - 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크
  - 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공
  - Spring 특징
    - 경량 Container
    - DI(Dependency Injection)
      - 의존성에 의한 문제점
        - Unit Test가 어려워진다 -> 내부에서 직접 생성하는 객체에 대해 mocking을 할 방법이 없음
        - Code 변경이 어려워진다 -> 객체간의 강한 결합력이 생긴다(모듈화의 목적에 해가 되는 행위)
      - 의존성 주입(Spring 사용전)
        - 생성자를 통해 전달 받음
        - setter를 통해 전달 방법
      - DI(Spring 사용)
        - DI 방식을 이용하여 모듈간 결합도를 낮춰준다.
        - IOC Container가 개발자 대신 xml 파일에 정의된 대로 Bean 객체를 생성하고 의존성을 대신 주입하는 것
        - IOC(제어의 역전) : 사용자가 직접 객체를 생성하고 관리하던 것을 spring IOC Container가 대신 해준 다는 말
    - 제어 역행(IoC: Inversion of Control)
      - 애플리케이션의 느슨한 결합을 도모
      - 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어 필요에 따라 스프링에서 사용자의 코드를 호출
      - IoC Conatiner : 사용자가 작성한 메타데이터(xml or @(어노테이션))에 따라 Bean클래스를 생성 및 관리하는 Spring 핵심 컴포넌트
        - Bean 정의를 읽어들이고, Bean을 구성하고 제공
      - IoC Container의 설정 방법
        - XML 파일 기술 : Code와 의존성을 주입하는 부분을 분리할 수 있다.
          - 유지보수성을 높일 수 있다.
          - 각 객체들의 의존관계를 한눈에 볼 수 있다.
          - 규모가 커짐에 따라 XML에 기술할 내용이 많아지면 생산성이 저하되고 유지보수가 어려워진다.
        - @(어노테이션)사용
          - 더 직관적인 코드 작성이 가능해진다
          - 메타데이터와 소스코드를 같이 기술 -> 개발 생산성이 증대
        - BeanFactory : Bean의 생성과 설정, 관리를 맡고 있음
        - ApplicationContext : BeanFactory를 상속받고 있기 때문에 BeanFactory와 같은 일 수행
        - Bean : 컨테이너 안에 들어 있는 객체들
          - 의존성 주입을 하기위해 Bean이 되어야하며 의존성 주입은 bean끼리만 가능
    - 관전지향 프로그래밍(AOP : Aspect-Oriented Programming)
      - 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리 가능
      - 핵심 기능외 부수 기능들을 분리 구현함으로 모듈성을 증가시키는 방법 (공통된 기능을 재사용하는 기법)
      - 어플리케이션 전체에 흩어진 공통 기능이 하나의 장소에 관리
      - 다른 서비스 모듈이 본인 목적에 충실하고 그 외 사항을 신경쓰지 않음
    - Container : 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리
      - iBatis, myBatis나 Hibernate 등 완성도 높은 데이터베이스처리 라이브러리와 연결 할 수 있는 인터페이스 제공
    - 트랜잭션 관리 프레임워크
      - 추상화된 트랜잭션 관리를 지원하며 설정 파일(xml, java, property 등)을 이용한 선언적 방식 및 프로그래밍을 통한 방식 모두 지원
    - MVC 패턴
      - DispatcherServlet이 Controller 역할을 담당하며 각종 요청을 적절한 서비스에 분산시켜주며 각 서비스들이 처리를 하여 결과를 생성하고 다양한 형식의 View 서비스들로 화면에 표시
    - 배치 프레임워크
      - 특정 시간대 실행 or 대용량의 처리하는데 쓰이는 일괄처리를 지원하는 프레임워크 제공
    - POJO(plain old java object) 방식 프레임워크
      - Java의 객체지향적 특징을 살려 비즈니스 로직에 출시해 개발이 가능하도록 하는 것
      - 특정 규약과 환경에 종속되지 않음.
      - 단일 책임 원칙을 지키는 클래스
      - 코드의 간결하며 자동화 테스트에 유리하다
  - 스프링 모듈
    - Spring Core : Spring 프레임워크의 근간이 되는 요소. IoC 기능을 지원하는 영역 담당
      - BeanFactory를 기반으로 Bean 클래스들을 제어할 수 있는 기능 지원
    - Spring Context 
      - Spring Core 바로위에 있으며 Spring Core에서 지원하는 기능외 추가적 기능과 더 쉬운 개발이 가능하도록 지원
      - JNDI, EJB등을 위한 Adaptor들 포함
    - Spring DAO
      - JDBC 기반하의 DAO개발을 좀 더 쉽고, 일관된 방법으로 개발하는 것이 가능하도록 지원
      - Spring DAO를 이용할 경우 지금까지 개발하던 DAO보다 적은 코드, 쉬운방법으로 dao개발하는것 가능
    - Spring ORM
      - Object Relation Mapping 프레임워크인 Hibernate, Ibatis, JDO와 결합을 지원하기위한 기능
    - Spring AOP
      - Aspepct Oriented Programming을 지원하는 기능(AOP Alliance기반하에 개발)
    - Spring Web
      - Web Application 개발에 필요한 Web Application Context와 Mutipart Request등의 기능 지원
      - Struts, Webwork와 같은 프레임워크의 통합을 지원하는 부분 담당
    - Spring Web  MVC
      - Spring 프레임워크에서 독립적으로 Web UI Layer에서 Modle-View-Controller를 지원하기 위한 기능
   
  - EJB(Enterprise JavaBean)
    - Java EE는간편하고 견고하고 확장가능하며 안전한 서버측 자바 애플리케이션을 위한 산업 표준
    - Java EE에는 웹 애플리케이션 개발을 위한 Servlet, JSP, EJB 등 다양한 기능을 포함
  - Java EE의 기능
    - 비동기 메시지 처리를 위한 JMS(Java Message Service)
    - 데이터베이스 처리용 API JDBC(Java Database Connectivity)
    - 트랜잭션 처리를 위한 JTA (Java Trasaction Api)
    - 분산 트랜잭션 지원 및 디렉토리 서비스를 위한 JNDI(Java Naming and Directory Interface)
  - EJB 기능
    - 분산 애플리케이션ㅇ르 지원하는 컴포넌트 기반의 객체 --> 재사용성 있음.
  - EJB 장단점
    - 대량의 트랜잭션을 안정적으로 처리 가능
    - 분산 트랜잭션을 지원
    - 인증과 접근제어에 용이
    - 복잡한 프로그래밍 모델
    - 특정 환경 및 기술에 종속적인 코드
    - 컨테이너 안에서만 동작할 수 있는 객체구조
    - 자동화된 테스트가 매우 어렵거나 불가능
    - 객체지향적이지 않고 형편없는 개발생산성
      
2. Spring Boot
  - Spring Framework를 사용하기 위한 설정의 많은 부분을 자동화하여 사용자가 정말 편리하게 스프링을 활용할 수 있도록 도움을 줌.
  - 자동설정 : 필요한 설정 자동으로 구성 -> 버전 문제 발생률 줄어듬
  - XML 없는 환경 구축 -> 자바 코드로 설정 가능
  - Tomcat 내장 -> 서버를 빠르게 구동 가능 
  - Spring Boot 장단점
    - 애플리케이션을 신속하게 설정, 스프링 구동 애플리케이션을 빌드하기위한 기본 구성 제공 유틸리티
    - 상용화에 필요한 통계, 상태 체크, 외부 설정 등을 제공, 기본설정된 starter 컴포넌트 제공
    - WAS 설치 없이 embeded container에서 자신의 애플리케이션 실행 가능
    - Tomcat, Jetty, Undertow 가 기본 내장되어 있다. -> 웹 프로젝트 띄우는 시간 단축
    - .jar 파일 형태로 간단히 배포가능하다.
    - 의존라이브러리의 버전을 일일이 지정않아도 되며 스프링 부트가 권장 버전을 관리
    - 내장 톰캣 관리가 어려움
    - 같은 서버 포트번호로 다르게 배포시 boot 버전을 맞춰야한다.

3. Spring Security
- 스프링 기반의 애플리케이션 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크 
  - 서블릿 필터와 이들로 구성된 필테체인으로의 위임 모델 사용 
  - Spring Security는 전적으로 Servlet Filter를 기반으로 한다
  - Filter는 요청과 응답을 가로채고 해당요청/응답 전후에서 필요한 처리를 할 수 있다
- 사용자 정의가 가능한 인증 및 접근 제어/권한 프레임워크
  - 인증 : id/pw, 공인인증서 등
  - 권한 : admin, user, guest 등
- 간략한 과정
  
  ![ex_screenshot](/res/security2.JPG)
  
  1. Authorization(권한) : 권한이 없는 User가 접근 시 자동으로 Login Page 띄어줌
  2. Authentication(인증) : 사용자가 입력한 id/pw가 일치하는지 Authentication Providers를 통해 확인
  3. id/pw가 일치하지 않으면 반복
  4. 인증과 권한이 통과도면 Secured Area에 접근 허용
- 1) Security Architecture
  - Form 기반 로그인에 대한 플로우
  
  ![ex_screenshot](/res/security.png)
  1. 사용자가 Form을 통해 로그인 정보 입력 후 인증 요청
  2. AuthenticationFilter가 HttpServletRequest에서 사용자가 보낸 id/pw를 인터셉트
    - 유효성 검사
    - HttpServletRequest에서 꺼내온 사용자 id/pw를 AuthenticationManaver 인터페이스(구현체-ProviderManager)에 인증용 객체(UsernamePawsswordAuthentication Token)로 만들어 위임
  3. AuthenticationFilter에게 인증용 객체를 전달 받음.
  4. 실제 인증할 AuthenticationProvider에게 Authenticatin객체를 다시 전달 
  5. DB에서 사용자 인증 정보를 가져올 UserDetailService 객체에게 사용자 아이디 넘겨주고 DB에서 인증에 사용할 사용자정보(id, 암호화된 pw, 권한 등)를 UserDetials(인증용 객체와 도메인 객체를 분리하지 않기 위해 실제 사용되는 도메인 객체에서 UserDetails를 상속하기도 함)라는 객체로 전달 받는다. 
  6. AuthenticationProvider는 UserDetails 객체를 전달 받은 이후 실제 사용자 입력정보와 UserDetails 객체를 가지고 인증을 시도
  7. 인증이 완료되면 사용자 정보를 가진 Authentication 객체를 SecurityContextHolder에 담은 이후 AuthenticationSuccessHandle를 실행(실패시 AuthenticationFailureHandler를 실행)

- 2)security filter들
  - SecurityContextPersistenceFilter : SecurityContextRepository에서 Security를 가져오거나 저장
  - LogoutFilter : 설정된 로그아웃 URL로 오는 요청을 감시하며, 해당 유저를 로그아웃 처리
  - (UsernamePassword)AuthenticationFilter : 설정된 로그인 URL로 오는 요청을 감시하며 유저 인증 처리
    - AuthenticationManager를 통한 인증 실행
    - 인증 성공 시, Authentication 객체를 SecurityContext에 저장 후 AuthenticationSuccessHandler 실행
    - 인증 실패 시, AuthenticationFaiureHandler 실행
  - DefualtLoginPageGeneraterFilter : 인증을 위한 로그인폼 URL을 감시
  - BasicAuthenticationFilter : HTTP 기본 인증 헤더를 감시하여 처리
  - RequestCacheAwareFilter : 로그인 성공 후, 원래 요청 정보를 재구성하기 위해 사용
  - SecurityContextHolderAwareRequestFilter : HttpServletRequestWraaper를 상속한 SecurityContextHolderAwareRequestWrapper 클래스로 HttpServletRequest정보를 감싼다. SecurityContextHolderAwareRequestWrapper 클래스는 필터 체인상의 다임 필터들에게 부가정보를 제공
  - AnonymousAuthenticatonFilter : 이 필터가 호출되는 시점까지 사용자 정보가 인증되지 않는다면 인증토큰에는 익명 사용자로 나타남
  - SesseionManagementFilter : 인증된 사용자와 관련된 모든 세션을 추적
  - ExceptionTranslationFilter : 보호된 요청을 처리하는 중에 발생할 수 있는 예외를 위임하거나 전달하는 역할 수행
  - FilterSecurityInterceptor : AcessDecisionManager로 권한부여 처리를 위윔하므로 접근 제어 결정을 쉽게한다. 
- 3) Authentication
  - 접근 주체는 Authentication 객체 생성, SecurityContext에 보관되고 사용된다
  <pre>
  <code>
  public interface Authentication extends Principal, Serializable { 
      Collection<? extends GrantedAuthority> getAuthorities(); 
      // Authentication 저장소에 의해 인증된 사용자의 권한 목록 
      Object getCredentials(); // 주로 비밀번호 
      Object getDetails(); // 사용자 상세정보 
      Object getPrincipal(); // 주로 ID 
      boolean isAuthenticated(); //인증 여부 
      void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException; 
  }
  
  </code>
  </pre>
  
- 4) AuthenticationManager

  ![ex_screenshot](/res/security3.png)
- 유저의 요청을 AuthenticationFilter에서 Authentication객체로 변환하여 AuthenticationManager(ProvidrMnager)에게 넘겨주고, AuthenticationProvider가 실제 인증을 한 후 인증이 완료되면 Authentication 객체를 반환
  - AbstractAuthenticationProcessingFilter : 웹 기반 인증요청에서 사용되는 컴포넌트
    - POST 폼 데이터를 포함하는 요청을 처리
    - 사용자 비밀번호를 다른 필터로 전달하기 위해 Authentication 객체를 생성하고 일부 프로퍼티를 설정
  - AuthenticationManager : 인증요청을 받고 Authentication을 채워준다
  - AuthenticationProvider : 실제 인증이 일어나고 인증 설공시 Authentication 객체의 authenticated=true 설정
- Spring Securitiy는 ProviderManager라는 AuthenticationManager 인터페이스의 유일한 구현체를 제공
- ProviderManager는 하나 or 여러 개의 AuthenticationProvider 구현체를 사용할 수 있다
- AuthenticationProvider는 많이 사용되고 ProviderManager(AuthenticationManager의 구현체)와도 잘 통합되기때문에 기본적으로 어떻게 동작하는지 이해하는 것이 중요!

- 5) 비밀번호 인증과정
  ![ex_screenshot](/res/security4.png)
  - DaoAuthenticationProvider는 UserDetailService 타입 오브젝트로 위임
  - UserDetailService는 UserDetails 구현체를 리턴하는 역할 
    - Authentication : 사용자 id, pw와 인증 요청 컨텍스트에 대한 정보를 가짐, 인증 이후의 사용자 상세정보와 같은 UserDetails 타입 오브젝트를 포함 할 수도 있음
    - UserDetails : 이름, 이메일, 전화번호와 같은 사용자 프로파일 정보를 저장하기 위한 용도로 사용
- 6) 인증예외
  - 인증과 관련되 모든 예외는 AuthenticationException을 상속 
    - authentication : 인증 요청관련 Authentication 객체를 저장
    - extrainformation : 인증 예외 부가 정보 저장

- 접근 권한 부여
  - FilterSecurityInterceptor : 요청의 수락 여부 결정 
    - Authentication의 getAuthorities 메소드 참조하여 해당 요청의 승인 여부를 결정 
    - AccessDecisionManager 컴포넌트가 인증 확인 처리

- JavaConfig
자료 출처 : https://coding-start.tistory.com/153
<pre>
<code>
@EnableWebSecurity // 스프링 시큐리티를 사용하겠다는 선언
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter{
    
//    private UserDetailsService userDetailsService;
//    private PasswordEncoder passwordEncoder;
    private AuthenticationProvider authenticationProvider;
    
    public SpringSecurityConfig(/*UserDetailsService userDetailsService, 
                                PasswordEncoder passwordEncoder,*/
                                AuthenticationProvider authenticationProvider) {
//        this.userDetailsService = userDetailsService;
//        this.passwordEncoder = passwordEncoder;
        this.authenticationProvider = authenticationProvider;
    }
    
    /*
     * 스프링 시큐리티가 사용자를 인증하는 방법이 담긴 객체.
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        /*
         * 인증을 담당할 프로바이더 AuthenticationProvider 구현체를 설정하는 메소드 
         */
        auth.authenticationProvider(authenticationProvider); // Custom한 Provider
//        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
    }
    
    /*
     * 스프링 시큐리티 룰을 무시하게 하는 Url 규칙.
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring()
            .antMatchers("/resources/**")
            .antMatchers("/css/**")
            .antMatchers("/vendor/**")
            .antMatchers("/js/**")
            .antMatchers("/favicon*/**")
            .antMatchers("/img/**")
        ;
    }
    
    /*
     * 스프링 시큐리티 룰.
     * 권한 설정, Handler 등록, Custom Filter 등록, 예외 핸들러 등록 등 수행
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .antMatchers("/login*/**").permitAll()
            .antMatchers("/logout/**").permitAll()
            .antMatchers("/chatbot/**").permitAll()
            .anyRequest().authenticated()
        .and().logout()
              .logoutUrl("/logout")
              .logoutSuccessHandler(logoutSuccessHandler())
        .and().csrf()
              .disable()
        .addFilter(jwtAuthenticationFilter())
        .addFilter(jwtAuthorizationFilter())
        .exceptionHandling()
              .accessDeniedHandler(accessDeniedHandler())
              .authenticationEntryPoint(authenticationEntryPoint())
//        .and().sessionManagement()
//              .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        ;
    }
    
    /*
     * SuccessHandler bean register
     */
    @Bean
    public AuthenticationSuccessHandler authenticationSuccessHandler() {
        CustomAuthenticationSuccessHandler successHandler = new CustomAuthenticationSuccessHandler();
        successHandler.setDefaultTargetUrl("/index");
        return successHandler;
    }
    
    /*
     * FailureHandler bean register
     */
    @Bean
    public AuthenticationFailureHandler authenticationFailureHandler() {
        CustomAuthenticationFailureHandler failureHandler = new CustomAuthenticationFailureHandler();
        failureHandler.setDefaultFailureUrl("/loginPage?error=error");
        return failureHandler;
    }
    
    /*
     * LogoutSuccessHandler bean register
     */
    @Bean
    public LogoutSuccessHandler logoutSuccessHandler() {
        CustomLogoutSuccessHandler logoutSuccessHandler = new CustomLogoutSuccessHandler();
        logoutSuccessHandler.setDefaultTargetUrl("/loginPage?logout=logout");
        return logoutSuccessHandler;
    }
    
    /*
     * AccessDeniedHandler bean register
     */
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        CustomAccessDeniedHandler accessDeniedHandler = new CustomAccessDeniedHandler();
        accessDeniedHandler.setErrorPage("/error/403");
        return accessDeniedHandler;
    }
    
    /*
     * AuthenticationEntryPoint bean register
     */
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return new CustomAuthenticationEntryPoint("/loginPage?error=e");
    }
    
    /*
     * Form Login시 걸리는 Filter bean register
     */
    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {
        JwtAuthenticationFilter jwtAuthenticationFilter = new JwtAuthenticationFilter(authenticationManager());
        jwtAuthenticationFilter.setFilterProcessesUrl("/login");
        jwtAuthenticationFilter.setUsernameParameter("username");
        jwtAuthenticationFilter.setPasswordParameter("password");
        
        jwtAuthenticationFilter.setAuthenticationSuccessHandler(authenticationSuccessHandler());
        jwtAuthenticationFilter.setAuthenticationFailureHandler(authenticationFailureHandler());
        
        jwtAuthenticationFilter.afterPropertiesSet();
        
        return jwtAuthenticationFilter;
    }
    
    /*
     * Filter bean register
     */
    @Bean
    public JwtAuthorizationFilter jwtAuthorizationFilter() throws Exception {
        JwtAuthorizationFilter jwtAuthorizationFilter = new JwtAuthorizationFilter(authenticationManager());
        return jwtAuthorizationFilter;
    }
}
</code>
</pre>

4. MVC 패턴

5. Security + Oauth 2.0

6. myBatis vs sequalize 

7. JPA

8. REST API

9. GraphQL

