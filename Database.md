# 데이터베이스(DB)
1. 데이터베이스 환경
- 데이터 : 현실 세계로부터 단순한 관찰이나 측정을 통해 수집된 사실이나 값
- 정보 : 어떤 상황에 대한 적절한 결정을 할 수 있게 하는 지식으로 데이터의 유효한 해석이나 데이터 상호간의 관계
- 정보가 유용성을 갖기 위해서 정확성과 현재성을 가지고 있어야함
  -> 정확성과 현재성을 갖기 위해서는 데이터가 정확하고 현재의 것이어야함
- 정보시스템 : 한 조직체의 활동에 필요한 데이터를 수집, 조직, 저장해 두었다 필요시 처리해 의사 결정에 유효한 정보를 생성해 분배하는 수단
  - 목적 : 현재의 정확한 정보를 적시에 제공하여 조직체로 하여 유용한 의사 결정을 하도록 하는 것
- 데이터 웨어하우스 : 다양한 소스의 데이터를 별도로 추출해 관리하는 것
- 데이터 마이닝 : 데이터 웨어하우스 규모가 대형화되고 복잡하게 될 때 관련된 데이터를 찾아내고 필요한 정보, 지식을 생성하는 과정

- 일괄 처리 시스템
  - 유사한 트랜잭션을 한데 모아 일정 시간에 한꺼번에 처리하여 사용자의 요구를 만족시키고 시스템 효율성을 높이는데 목적이 있음
  - 트랜잭션 : 논리적 작업 단위로 하나의 단위로 처리되어야 하는 분리될 수 없는 연산 그룹
  - 장점 : 각 트랜잭션 당 처리 비용이 적게 들게 되고 시스템 성능을 높일 수 있다
  - 단점 : 대기 시간이 길어지고 사전작업을 거쳐야함
- 온라인 처리 시스템
  - 곧바로 데이터를 처리하는 방식
  - 대기시간이 없어 사용자는 편리 -> 사용자 중심 처리 방식
  - 응답시간을 최소화 해야함 -> 시스템을 계속 가동 상태 유지하고 이는 작업 당 처리 비용을 높게 만듦
  - 테스트, 유지보수가 어렵게되고 회복도 매우 복잡
  - 시스템 오보헤드로 연결되어 시스템 성능 저하의 직접적 원인
- 분산 처리 시스템
  - 지리적으로 분산되어 있는 처리기와 데이터베이스를 네트워크로 연결시켜 사용자는 마치 하나의 시스템을 사용하는 것처럼 데이터 처리해주는 시스템
  - 분산 데이터베이스 : 지리적으로 분산 저장되어 있는 형태의 데이터베이스
  - 신속한 조치, 지역 업무에 대한 책임 구분, 모듈식 구축의 용이, 다원적 재편성을 통한 신뢰성 증대 등 이점이 있음
  
- 데이터 베이스 : 어느 한 조직의 여러 응용 시스템이 공용할 수 있도록 통합, 저장된 운영 데이터 집합
  - 통합 데이터 : 원칙적으로 중복되어 있지 않음
  - 저장 데이터 : 컴퓨터가 접근 할 수 있는 저장 매체에 저장된 데이터
  - 운영 데이터 : 기능을 수행하기 위해 반드시 유지해야 할 데이터
  - 공용 데이터 : 여러 응용 시스템들이 공동으로 소유, 이용하는 공용 데이터, 서로 다른 목적으로 데이터베이스의 데이터를 공동으로 이용한다는 것
  - 데이터베이스 특성
    - 실시간 접근성 : 응답 시간은 단 몇 초를 넘지 않아야 함
    - 계속적인 변환 : 변화 속에서 현재의 정확한 데이터를 유지해야함
    - 동시 공용 : 여러 사용자가 동시에 원하는 데이터에 접근하여 이용할 수 있어야함
    - 내용에 의한 참조 : 사용자가 요구하는 데이터의 내용, 데이터가 가지는 값에 따라 참조
  - 개체 : 데이터베이스에서 표현하려고 하는 유형, 무형의 객체로 서로 구별되는 것
    - 하나 이상이 속성(애트리뷰트)으로 구성되고 각 속성은 개체의 특성이나 상태를 기술
    - 속성은 이름을 가진 데이터의 가장 논리적 단위
    - 개체 인스턴스 : 개체를 구성하고 있는 속성들이 어떤 구체적인 값을 가진 상태 -> 인스턴스 집합을 개체 집합이라함
  - 관계
    - 속성 관계 : 어느 한 개체를 기술하는 속성들 간의 관계(개체 내 관계)
    - 개체 관계 : 개체 집합과 개체 집합 사이의 관계(개체 간 관계)
  - 데이터베이스 구조 
    - 논리적 구조 : 사용자가 생각하는 데이터의 논리적 표현 (일반 사용자나 응용 프로그래머의 입장에서 보는 구조, 가상적인 구조)
    - 논리적 구조에서 취급하는 데이터 레코드 -> 논리적 레코드
    - 물리적 구조 : 저장 장치 위에 물리적으로 저장 되어 있는 데이터의 실제 구조
    - 물리적 구조에서 취급하는 데이터 레코드 -> 저장 레코드

2. 데이터베이스 관리 시스템
- 데이터 종속성 : 응용 프로그램과 데이터 간의 상호 의존 관계, 데이터 구성 방법이나 접근 방법을 변 경시 자연히 이것을 기초로 한 응요 프로그램도 같이 변경해야 하는 데 이것을 데이터 종속성이라 함
- 데이터 중복성 : 한 시스템 내에 내용이 같은 데이터가 중복되게 저장 관리 되는 것
  - 데이터 중복성으로 인해 야기되는 문제점
    - 데이터 일관성 : 동일성을 유지하기 어렵고 데이터 간 불일치 발생
    - 보안성 : 같은 내용의 데이터에 대해 같은 수준의 데이터 보안이 유지 되어야함
    - 경제성 : 중복 시 추가적으로 필요한 저장 공간에 대한 비용이 더 들게 됨
    - 무결성 : 중복 시 제어가 분산되게 되어 데이터의 정확성 유지가 어려움
- 데이터베이스 관리 시스템(DBMS) : 응용 프로그램과 데이터의 중재자로 모든 응용 프로그램들이 데이터베이스를 공용할 수 있게 관리해주는 SW 시스템
  - DBMS 필수 기능
    - 정의 기능 : 다양한 응용 프로그램과 데이터베이스가 서로 인터페이스 할 수 있는 방법 제공
      - DB의 논리적 구조와 특성이 DBMS가 지원하는 데이터 모델에 맞게 기술되어야함
      - DB를 물리적 저장 장치에 저장하기 위한 데이터의 물리적 구조의 명세도 포함되어야함
      - 데이터의 논리적 구조와 물리적 구조 사이에 상호 변환이 가능하도록 구조 사이의 사상을 명세해야함
    - 조작 기능 : 사용자와 인터페이스 사이의 인터페이스를 위한 수단 제공
      - 모든 사용자에게 사용하기 쉽고 자연스러워야 함
      - 명확하게 명세할 수 있어야하고,  합법적인 범위내에서 완전히 명세할 수 있어야함
      - 효율적이어야 함
    - 제어 기능 : DB의 내용에 대해 항상 정확성과 안정성을 유지할 수 있는 데이터 제어 기능을 가져야함
      - 데이터의 무결성이 파괴되지 않도록 제어할 수 있어야함
      - 권한 검사하고 보안을 유지할 수 있어야 함
      - 여러 사용자가 동시에 접근해 처리하더라도 DB와 처리결과는 항상 정확성이 유지되도록 병행 제어 기능을 가져야함
  - DBMS의 장점 
    - 데이터 중복 최소화 / 데이터 공용 / 데이터 일관성 유지 / 데이터 무결성 유지 / 데이터 보안 보장 / 표준화 / 전체 데이터 요구의 조정
  - DBMS 단점
    - 운영비 증대 / 특정 응용 프로그램의 복잡화 / 복잡한 백업과 회복 / 시스템 취약성 
  - 데이터 독립성 : 논리적 구조나 물리적 구조가 변경 되더라도 응요 프로그램이 영향 받지 않도록 제공해야함
    - 논리적 데이터 독립성 : DBMS가 DB의 논리적 구조를 변경하더라도 기존 응용 프로그램들에 아무런 영향을 주지 않는 것
    - 물리적 데이터 독립성 : 기존 응용 프로그램, 논리적 구조에 아무런 영향을 주지 않고 DBMS이 DB의 물리적 구조를 변경할 수 있는 것

3. 데이터베이스 시스템의 구성
- 1) 3단계 데이터 베이스

    ![ex_screenshot](/res/db1.png)
    
  - 스키마 : DB 구조와 제약조건에 대한 명세를 기술 한 것(개체, 관계, 제약 조건, 속성에 대한 정의 포함)
  - 외부 스키마(외부 단계)
    - 데이터베이스의 개인 사용자나 응용 프로그래머가 접근하는 데이터베이스를 정의한 것
    - 데이터베이스 전체의 한 논리적 부분이 되는 것이기에 서브 스키마라고도 함
    - 하나의 데이터베이스 시스템은 여러 외부 스키마가 존재
  - 개념 스키마
    - 범 기관적 입자에서 데이터베이스를 정의한 것
    - 응용 시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 데이터베이스를 기술한 것
  - 내부 스키마
    - 저장 장치의 입장에서 데이터베이스 전체가 저장되는 방법을 명세한 것
    - 개념 스키마에 대한 저장 구조를 정의한 것
  - 외부/개념 사상
    - 특정 외부 스키마와 개념 스키마간의 대응 관계 정의 (응용 인터페이스) -> 논리적 데이터 독립성 제공
  - 개념/내부 사상
    - 개념 스키마와 내부 스키마간의 대응 관계 정의(저장 인터페이스) -> 개체의 각 속성이 내부 필드와 어떻게 대응 되는가를 정의 -> 물리적 데이터 독립성 제공
  - 시스템 카탈로그 : 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정의나 명세에 관한 정보를 유지하는 시스템
  - 데이터 디렉토리 : 데이터베이스에 수록된 데이터로 접근하는 데 필요한 위치 정보를 관리하는 시스템
  -> 두 개다 시스템 데이터베이스이지만, 시스템 카탈로그는 사용자가 접근해 검색 가능하지만 데이터 디렉토리는 시스템만 접근 가능
  
- 2) DBMS
  - 사용자의 데이터베이스 사이에 위치해 데이터베이스를 관리하고 사용자가 요구하는 연산을 수행해 정보를 생성해주는 소프트웨어
  
    ![ex_screenshot](/res/dbms.png)
    
    - DDL 컴파일러 : DDL로 명세된 스키마 정의를 내부 형태로 변환해 시스템 카탈로그에 저장
    - 질의어 처리기 : 사용자가 제출한 고급 질의문 처리(질의문 팡싱하고 분석해 컴파일)
    - DML 예비 컴파일러 : 응용 프로그램 속에 삽입된 DML 명령문들을 추출하고 그 자리에 함수 호출문 삽입
    - DML 컴파일러 : DML 명령문을 파싱하고 컴파일하여 효율적인 목적 코드 생성
    - 런타임 데이터베이스 처리기 : 실행 시간에 데이터베이스 접근을 관리함
    - 트랜잭션 관리자 : 무결성 제약조건이 만족하는지 검사, 권한 검사, 병행제어, 회복 작업 수행
    - 저장 데이터 관리자 : 디스크에 저장된 사용자가 데이터베이스나 시스템 카탈로그 접근을 책임 
    
- 3) 데이터 언어
  - 데이터 정의어 : 데이터베이스를 정의하거나 정의를 수정할 목적으로 사용하는 언어
    - 기술된 데이터 스키마는 DDL 컴파일러가 컴파일하여 시스템 카탈로그에 저장해 놓고 필요한 경우 시스템이 활용
  - 데이터 조작어 : 사용자가 DBMS로 하여금 원하는 데이터를 처리하게끔 명세하는 도구로 사용자와 DBMS 간 인터페이스 제공
    - 절차적 데이터 조작어 : 사용자가 모슨 데이터를 원하고 어떻게 접근해야 하는지 명세해야되는 저급 데이터 언어
      - 한번에 하나의 레코드를 검색해 호스트 언어와 함께 처리 -> 응용 프로그램 속에 삽입되어 사용됨
    - 비 절차적 데이터 조작어 : 사용자가 무슨 데이터를 원하는지만 명세하고 어떻게 접근해 처리할지는 명세할 필요 없이 DBMS에 위임하는 고급 데이터 언어 
      - 선언적 언어라고하며 한번에 여러 개의 레코드를 검색해 처리함
  - 데이터 제어어 : 데이터 제어에 관해 정의하고 기술하는 언어
    - 데이터 보안, 무결성, 회복, 병행 수행 제어를 명세할 수 있는 명령어 포함
  - 데이터 언어의 완정성 : 사용자가 원하는 데이터베이스의 어떤 객체도 추출하고 처리할 수 있어며 어떤 연산도 표현할 수 있는 데이터 언어의 능력

4. 관계 데이터베이스
- 1) 관계 데이터 모델

  ![ex_screenshot](/res/db2.png)
  
  - 테이블의 열은 속성(Attribute), 행은 튜플(tuple)
  - 데이터의 가장 작은 논리적 단위는 Attribute 값 -> 원자값만 허용
  - 하나의 Attribute가 취할 수 있는 같은 타입의 모든 원자 값들의 집합을 Attribute의 Domain이라 함
  - 각 Attribute는 어는 한 Domain으로부터만 값을 취할 수 있음
- 2) Relation(릴레이션)
  - Relation Schema는 이름과 Attribute 집합으로 구성되어 있음
  - Relation Schema는 한 릴레이션의 논리적 구조를 정의한 것
  - 관계 데이터 베이스 스키마는 한 관계 데이터베이스의 논리적 구조를 정의한 것, 하나 이상의 릴레이션 스키마가 포함 된다
  - 릴레이션, 데이터베이스 인스턴스는 동적 성질을 가지고 릴레이션, 데이터베이스 스키마는 정적 성질을 가짐
  - 카티션 프로덕트를 기술하는 도메인 순서는 결과에 영향을 주기에 중요함
  - 릴레이션 정의에 사용된 도메인 개수를 차수, 투플의 수를 카디널리티라 함
- 3) 릴레이션의 특성 
  - 투플의 유일성
  - 투플의 무순서성 
  - 애트리뷰트의 무순서성
  - 애트리뷰트의 원자성 
  - 널 값도 관계 데이터 모델에서는 원자 값으로 취급
- 4) 관계 데이터베이스 개념
  - 관계 데이터베이스 스키마는 릴레이션 스키마 집합과 무결성 제약 조건으로 구성
  - 관계 데이터베이스 인스턴스는 관계 데이터베이스 스키마에 정의된 릴레이션 인스턴스들의 집합
- 5) 데이터베이스 키 
  - 투플을 유일하게 식별할 수 있는 애트리뷰트 집합을 릴레이션의 키라고 함
  - 유일성 : 릴레이션에 있는 모든 투플에 대해 값이 상이하고 유일하다
  - 최소성 : 유일성을 가진 k가 둘 이상의 애트리뷰트로 구성되어 있을 때 어느 한 애튜리뷰트라도 제외하는 경우 유일성이 깨진다
    - k는 모든 투플을 유일하게 식별하는 뎅 필요한 애트리뷰트들로만 구성
    
  - 슈퍼키 : 유일성만 만족하고 최소성을 만족하지 못한 경우
  - 기본키 : 투플을 식별하기 위한 도구로 db 설계자가 지정한 하나의 후보키 -> 널 값을 가질 수 없다
  - 대체키 : 기본키로 지정되지 않은 나머지 후보키들
  - 외래키 : 릴레이션 R에 속한 어떤 애트리뷰트 집합 FK가 있을 때 FK 값은 반드시 어떤 릴레이션 S의 기본키 값이어야 할 때 FK를 릴레이션 R의 외래키라 함 ( R을 참조 릴레이션, S를 피참조 릴레이션)
    - 외래키와 기본키의 도메인은 같아야함
- 6) 무결성 제약
  - 무결성 종류 
    - 널 무결성 : 릴레이션 특정속성 값이 NULL이 될 수 없도록 하는 규정
    - 고유 무결성 : 릴레이션의 특정 속성에 대해 각 튜플이 갖는 값들이 서로 달라야하는 규정
    - 참조 무결성 : 외래키 값은 NULL이거나 참조 릴레이션의 기본 키 값과 동일해야 한다는 규정
    - 도메인 무결성 : 특정 속성 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
    - 키 무결성 : 하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정
  - 널 값
    - 알려지지 않은(모르는 값)
    - 값이 있지만 아직 모름
    - 해당 없음 등
    - 이러한 이유로 정보 부재를 명시적으로 표시하기 위해 사용하는 특수 데이터 값
  - 개체 무결성 제약 : 기본 키에 속해 있는 애트리뷰트는 널 값을 가질 수 없음
  - 참조 무결성 제약 : 참조할 수 없는 외래 키 값을 가져서는 안된다는 것을 의미
    - 널이 아니면서 참조된 릴레이션의 어떤 기본 키값과도 일치하지 않는 값을 의미

5. 관계 대수와 관계 해석
- 1) 관계 대수 : 원하는 목표 데이터를 얻기 위해 어떻게 해야 되는지 일련의 연산을 순서대로 명세해야 하는 절차 언어
  
  ![ex_screenshot](/res/db3.png)
  - 일반 집합 연산자     
    - 합집합 : 차수는 r or s의 차수, 카디널리티는 r+s 보다 크지 않아야함
    - 교집합 : 차수는 r or s의 차수, 카디널리티는 r과 s의 카디널리티보다 크지 않음
    - 차집합 : 차수는 r or s의 차수, 카디널리티는 r의 카디널리티보다 크지 않음
    - 카티션 프로덕트 : 차수는 r+s, 카디널린티는 r*s
    - 합,교,차 집합은 합병 가능해야함 ( 합병 가능은 두 릴레이션의 차수가 같고 대응 애트리뷰트별로 도메인이 같음)
    - 합/교집합, 카티션 프로덕트는 결합적이고 교환적
  - 순수 관계 연산자 
    - 실렉트 : 수평적 부분 집합
    - 프로젝트 : 수직적 부분 집합
    - 조인 
      - ⍬로 표현될 수 있는 조인을 세타조인
      - ⍬가 =인 동일 조인
      - 동일 조인 결과에서 중복 애트리뷰트 제거하는 연산을 자연 조인
    - 디비전 : s의 모든 투플에 연관된 r의 투플을 선택
    - 개명 연산 
  - 기본 연산과 복합 연산 
    - 기본 연산 : 합, 차집합, 카티션 프로덕트, 실렉트, 프로젝트
    - 복합 연산 : 조인, 교집합, 디비전
  - 관계 대수 확장
    - 세미 조인 : s와 자연조인에 참여할 수 있는 r의 투플만 선택하는 것을 의미
    - 외부 조인 : 조인 상대 릴레이션에 대응되는 투플이 없을 경우 이를 제외않고 상대를 널 투플로 만들어 결과 릴레이션에 포함하는 연산
    - 외부 합집합 : 완전하게 합병 가능하지 않은 두 릴레이션을 합집합으로 만드는 것
      - 확장 애트리뷰트에 해당되는 값이 없는 경우 널 값으로 채움
    - 집계 연산 : SUM, AVG, MAX, MIN, COUNT 등이 있고 특별히 지정한 애트리뷰트 값에 따라 투플들을 그룹 짓게하는 GROUP이 있음
    
- 2) 관계 해석 : 원하는 정보가 무엇이라는 것만 선언하는 비절차적 언어
  - 투플 관계 해석
  - 도메인 관계 해석

6. SQL
- 1) SQL 데이터 정의문 
  - 스키마와 카탈로그 
    - SQL 스키마 : 스키마 이름을 식별되고 허가권자와 스키마의 각 요소에 대한 기술자 포함
      - 테이블, 뷰, 도메인, 기타 허가권이나 무결성 등에 관한 요소 포함
      - CREATE SCHEMA UNIVERSITY AUTHORIZATION SHLEE; -> 이름이 UNIVERSITY이고 허가권자가 SHLEE인 스키마 생성
    - 카탈로그 : 한 SQL 시스템 내의 스키마들의 집합 
      - 각 카탈로그는 반드시 INFORMATION_SCHEMA라는 스키마를 포함하며 카탈로그에 포함된 모든 스키마들의 정보와 스키마들의 모든 요소들에 대한 정보를 제공하기 위한 것
  - 도메인 정의문   
    - SQL이 지원하는 데이터 타입으로만 정의
		
    - CREATE DOMAIN 도메인_이름 데이타 타입
             [기정_값_정의]                
								=> DEFAULT 값 OR NULL											
             [도메인_제약조건_정의리스트]   
								=> 무결성 제약 조건, CONSTRAINT, CHECK로 명세
											
    - EX) CREATE DOMAIN DEPT CHAR(4)
                 DEFAULT '???'
                 CONSTRAINT VALID_DEPT
                 CHECK( VALUE INT
                   ('COMP', 'ME', 'EE','ARCH','???'));
									 
    - ALTER DOMAIN 으로 변경 가능 -> 도메인 수정
    - DROP DOMAIN 도메인_이름 옵션; -> 도메인 삭제
      - 옵션 RESTRICT : 이 도메인을 참조하고 있는 것이 없을 때만 삭제
      - CASCADE : 도메인을 참조하고 있는 뷰나 제약조건도 함께 삭제되지만 참조 열은 삭제되지 않고 다른 형태의 타입으로 변경
  - 기본 테이블 생성
    - 기본 테이블 : CREATE TABLE로 만들어지는 테이블로 독자적으로 존재하는 테이블
    - 가상 테이블 : CREATE VIEW로 만들어지는 테이블로 독자적 존재 불가, 기본 테이블로 유도되어 만들어 지는 테이블
    - 임시 테이블 : 질의문 처리 과정의 중간 결과로 만들어 지는 테이블
    - CREATE TABLE SQL문
    
    	     CREATE TABLE 기본 테이블
             ({열_이름 데이타 타입 [NOT NULL] [DEFAULT 값],}+   
			=> [] 생략 가능, {} 중복 가능 '+'는 1번 이상, * 는 0번 이상								
             [PRIMARY KEY(열_이름_리스트),]                   
			=> 기본키 명세, 개체 무결성 정의								
             {[UNIQUE (열_이름_리스트).]}                    
			=> 대체키(후보키 명세)							
             {[FOREIGN KEY(열_이름_리스트)
                  REFERENCES 기본테이블[(열_이름_리스트)]
                  [ON DELETE 옵션]
                  [ON UPDATE 옵션],]}*
                  [CONSTRAINT 이름] [CHECK(조건식)]);          
			=> 외래키로 참조 무결성 유지
			   옵션 NO ACTION, CASCADE, SET NULL, SET DEFAULT
			   CHECK절은 행 갱신, 삽입 시 유지되어야 할 무결성 제약 조건
											
    - 예제
    	CREATE TABLE ENROL(Sno INT NOT NULL,
         		Cno CHAR(6) NOT NULL,
         		Grade INT,
         PRIMARY KEY(Sno, Cno),
         FOREIGN KEY(Sno) REFERENCES STUDENT(Sno)
                ON DELETE CASCADE
                ON UPDATE CASCADE,
         FOGEIGN KEY(Cno) RREFERENCES COURSE 
                ON DELETE CASCADE
                ON UPDATE CASCADE,
         CHECK(Grade>=0 AND Grade<=100));
         
  - 기본 테이블 제거와 변경 
    - DROP TABLE COURSE CASCADE;
      - CASCADE : 참조하는 다른 뷰 정의, 제약조거너이 있으면 함께 자동 삭제
      - RESTRICT : 다른 뷰 정의에서나 조약조건에서 참조되고 있는 경우 실행되지 않음
			
    - DROP SCHEMA UNIVERSITY CASCADE;
      - CASCADE : 스키마뿐 아니라 연관 객체들 모두 삭제
      - RESTRICT : 스키마가 공백인 경우에만 삭제
			
    - ALTER TABLE ENROL ADD Final CHAR DEFAULT 'F';
    - ALTER TABLE ENROL ALTER Grade SET DEFAULT '0'; -> 기정 값 변경
    - DROP CONSTRAINT 이름 -> 제약 조건 삭제
		
- 2) SQL 데이타 조작문
  - 데이타 갬색
    - SELECT [ALL|DISTINCT] 열_리스트
      FROM 테이블_리스트
      [WHERE 조건]
      [GROUP BY 열_리스트]
      [HAVING 조건]
      [ORDER BY 열_리스트] ASC|DESC]];
    
    - SELECT Sno AS 학번, '중간시험 =' AS 시험, Midtern+3 AS 점수
      FROM ENROL
      WHERE Cno='c312';
      
      SELECT S.Sname, S.Dept, E.Grade
      FROM STUDENT S, ENROL E
      WHERE S.Sno = E.Sno and E.Cno = 'C413';
      
    - 조인 조건의 3가지 형식
      - 테이블1 JOIN 테이블2 ON 조건식
      - 테이블1 JOIN 테이블2 USING(열_리스트)
      - 테이블1 NATURAL JOIN 테이블2
    
      - SELECT Sname, Dept, Grde
        1)FROM STUDNET JOIN ENROL ON(STUDENT.Sno = ENROL.Sno)
        2)FROM STUDNET JOIN ENROL USING(Sno)
        3)FROM STUDNET NATURAL JOIN ENROL
        WHERE ENROL.Cno ='C413;
				
    - GROUP BY 이용 검색 
      - SELECT Cno, AVG(Final) AS 기말평균
        FROM ENROL
        GROUP BY Cno                       
					=> GROUP BY 절에 명세된 열의 값에 따라 그룹으로 분할 
					
        HAVING COUNT(*)>=3         
					=> 각 그룹의 구성 요건 명세 
				
    - Subquery 사용 검색
      - SELECT Sname 
        FROM STUDENT 
        WHERE Sno IN (SELECT Sno FROM ENROL WHERE Cno =’C413’);
      - SELECT Sname 
        FROM STUDENT 
        WHERE Sno NOT IN (SELECT Sno FROM ENROL WHERE Cno =’C413’);
      - SELECT Sname, Dept 
        FROM STUDENT 
        WHERE Dept = (SELECT Dept FROM STUDENT WHERE Sname =’정기태‘); 
				
    - Like 사용 검색
      - SELECT Cno, Cname 
        FROM COURSE
        WHERE Cno LIKE ‘C%’;
      - LIKE 프레디킷은 서브 스트링 패턴을 비교하는 비교 연산자 
        - %는 서브 스트링 패턴을 명세 
        - C% -> C로 시작, S__ -> S로 시작 세문자 스트링, LIKE '$S$' -> S포함 스트링
				
    - NULL 사용 검색
      - SELECT Sno, Sname
        FROM STUDENT
        WHERE Dept IS NULL;
				
    - EXISTS 사용 검색
      - SELECT Sname
        FROM STUDENT
        WHERE EXISTS(NOT EXIST도 가능) 
          (SELECT * 
           FROM ENROL
           WHERE Sno = STUDENT.Sno AND Cno = ‘C413’);
					 
  - 데이타 갱신 
    - UPDATE 테이블 
      SET {열_이름 = 산술식}`+
      [WHERE 조건];
			
    - UPDATE ENORL
      SET Final = Final + 5
      WHERE Sno IN (SELECT Sno 
                    FROM STUDENT
                    WHERE Dept = ‘컴퓨터’);
										
  - 데이터 삽입
    - INSERT
      INTO 테이블[(열_이름_리스트)]
      VALUES (열_값_리스트);
			
    - INSERT
      INTO 테이블[(열_이름_리스트)]
      SELECT문;
			
    - INSERT
      INTO STUDENT(Sno, Sname, Year, Dept)
      VALUE(600, ‘박상철’, 1, ‘컴퓨터’);
			
    - INSERT
      INTO COMPUTER(Sno, Sname, Year)
        SELECT Sno, Sname, Year
        FROM STUDENT
        WHERE Dept= ‘컴퓨터’;
				
  - 데이터 삭제
    - DELETE
      FROM 테이블
      [WHERE 조건];
			=> WHERE 절 없으면 투플이 모두 삭제 된 빈 테이블이 됨.
			
    - DELETE
      FROM STUDENT
      WHERE Sno = 100; 
			
    - DELETE
      FROM ENROL; 
			=> 빈 테이블이 됨.
			
    - DELETE
      FROM ENROL
      WHERE Cno = ‘C413’ AND Final <60 AND ENROL.Sno IN 
                                                     (SELECT Sno 
                                                      FROM STUDENT 
                                                      WHERE Dept = ‘컴퓨터’);
  
- 3) SQL 뷰
  - 뷰는 다른 테이블로부터 유도된 이름을 가진 가상 테이블
  - 뷰 정의만 시스템 내에 저장해 두었다가 필요시 실행 시간에 테이블을 구축
  - ALTER문 을 이용한 변경 불가
  - 뷰 생성 
    - CREATE VIEW 뷰_이름[(열_이름_리스트)] 
          AS SELECT문                       
        [WITH CHECK OPTION];                
					=> 뷰에 대한 갱신, 삽입 연산 시 뷰 정의 조건 위반 시 실행 거부 되는 제약 조건
					
			=> AS SELECT문에 UNION, ORDER BY 사용 불가
			
    - CREATE VIEW CSTUDENT 
          AS SELECT Sno, Sname, Year 
             FROM STUDENT 
             WHERE Dept = ‘컴퓨터’ WITH CHECK OPTION;
    - CREATE VIEW HONOR(Sname, Dept, Grade)
          AS SELECT STUDENT.Sname, STUDENT.Dept, ENROL.Final      
             FROM STUDENT, ENROL 
             WHERE STUDENT.Sno = ENROL.Sno AND ERNOL.Final >90;  
  - 뷰 제거 
    - DROP VIEW 뷰_이름 {RESTRICT | CASCADE};
      - RESTRICT -> 다른곳에 참조되고 있지 않는 한 데이터베이스에서 제거되어 없어진다.
      - CASCADE -> 해당 뷰 뿐만 아니라 뷰가 사용된 다른 모든 뷰나 제약 조건이 함께 제거
   
  - 뷰의 조작 연산
    - 뷰는 검색문을 사용할 수 있으나 삽입, 삭제, 갱신문에는 제한이 있다
    - 기본키를 포함하지 않는 뷰일 경우 삽입 불가
    - 둘 이상의 테이블로 동일 조인으로 정의되었다면 갱신 시 많은 문제점 발생 가능
    - 통계요약을 위해 정의된 경우에 변경 연산은 많은 문제점을 야기 할 수 있다
    
    - 변경이 허용되지 않는 경우
      - 뷰의 열이 상수, 산술연산자, 함수가 사용된 산술 식으로 만들어지면 변경 불가
      - 집계함수가 관련되어 정의된 뷰는 변경 불가
      - DISTINCT, GROUP BY, HAVING이 사용되어 정의된 뷰는 변경 불가
      - 두 개 이상의 테이블이 관련되어 정의된 뷰는 변경 불가
      - 변경할 수 없는 뷰를 기초로 정의된 뷰는 변경 불가 
  - 뷰의 장단점
    - 데이터의 논리적 독립성을 어느 정도 제공할 수 있다.
    - 데이터의 접근을 제어함으로써 보안을 제공할 수 있다.
    - 사용자의 데이터 관리를 간단하고 쉽게 해준다.
    - 여러 사용자의 상이한 응용이나 요구를 지원해 줄 수 있다.
    - 뷰의 정의를 변경할 수 없다.
    - 삽입, 삭제, 갱신 연산에 많은 제한을 가지고 있다. 
    
- 4) 삽입 SQL
  - 응용 프로그램 특징 
    - 삽입 SQL문은 명령문 앞에 ‘EXEC SQL’을 붙여 다른 호스트 언어의 명령문과 쉽게 구별, 끝에는 세미콜론과 같은 특별한 종료 심벌을 붙여 표시
    - 삽입 SQL 실행문은 호스트 언어의 실행문이 사용되는 곳이면 어디나 나타날 수 있고 실행문, 비 실행문이 있는데 DECLARE CURSOR, BEGIN, END, DECLARE SECTION은 비실행문이다.
    - 삽입 SQL문은 호스트 변수를 포함 할 수 있고 다른 SQL 필드 이름과 구별하기위해 콜론을 앞에 붙인다. 호스트 변수는 검색 결과를 저장하는 장소를 나타내기 위해 INTO 절에 나타날 수 있다.
    - SQL문에서 사용할 호스트 변수는 사용전 반드시 삽입 SQL 선언부인 BEGIN/END DECLARE SECTION속에서 선언되어야 한다. 여러개 있어도 무방하다
    - SQLSTATE라는 스트링 타입의 호스트 변수를 포함한다. 실행 상태 표시가 SQLSTATE 변수를 통해 프로그램에 전달된다.
      - 변수 값이 “00000” -> 성공적으로 실행, “02000” -> 실행 했지만 아무런 데이터도 검색하지 못함을 의미
    - 삽입 SQL문의 호스트 변수의 데이터 타입은 이에 대응하는 데이터베이스 필드의 SQL 데이터 타입과 일치해야한다. 
    - 호스트 변수와 데이터베이스 필드 이름은 같아도 된다.
    - SQL문 실행 후 SQLSTATE 변수에 반환된 값을 검사해야한다.
      - EXEC SQL WHENEVER <조건> <행동>;
      - 조건은 SQLERROR이거나 NOT FOUND, 행동은 CONTINUE, GOTO문
  - 커서 
    - SQL 레코드 집합 단위 처리와 호스트 언어의 개별 레코드 단위 처리 사이에 어떤 교량 시설
    - 응용 프로그램의 삽입 SQL에만 사용되는 새로운 객체, 레코드 집합을 처리하는 데 사용되는 일종의 포인터
  - 커서가 필요 없는 데이터 조작
    - 단일 레코드 검색
      - EXEC SQL SELECT Sname, Dept 
             INTO :sname, :dept 
             FROM STUDENT
             WHERE Sno = :sno;
    - 갱신 
      - EXEC SQL UPDATE ENROL
                 SET Final = Final + :new 
                 WHERE Cno = ‘C413’; 
    - 삭제
      - EXEC SQL DELETE
                 FROM ENROL
                 WHERE SNO = :sno
    - 삽입		
			- EXEC SQL INSERT
                 INTO STUDENT(Sno, Sname, Dept)
                 VALUES(:sno, :sname, :dept); 
		                 
  - 커서를 이용하는 데이터 조작
  
    - EXEC SQL DECLARE C1 CURSOR FOR 
    	=> 커서 C1 정의, 커서를 FOR 뒤의 SELECT 문과 연결				
               SELECT Sno, Sname, Year 
 	             FROM STUDENT
               WHERE DEPT= :dept;
	       		=> 커서가 OPEN 될 때 실행							
      EXEC SQL OPEN C1;                     
      	=> C1으로 접근되는 모든 레코드에 대해 질의문 실행									
              DO                
	      	EXEC SQL FETCH C1 INTO :sno, :sname, :year; .....
               		=>  활동 세트 내의 다음레코드를 지시하게 하고 레코드의 필드 값을 호스트 변수들에 각각 저장 								
              END
      EXEC SQL CLOSE C1;
      	=> 커서 C1 활동 종료 
      
    - EXEC SQL UPDATE SUTDENT
               SET Year = :year
               WHERE CURRENT OF C1;  
				=> 현재 가리키고 있는 레코드의 Year 값을 호스트변수가 가진 값으로 변경
    - EXEC SQL DELETE
  	       FROM STUDENT
	       WHERE CURRENT OF C1;
				=> 현재 가리키고 있는 레코드를 삭제 
		
  - 다이내믹 SQL
    - 온라인 응용을 실행 시간에 구성할 수 있는 삽입 SQL			
		
    	```sql		
			varchar dynamicSQL[256]; ( 문자 스트링 변수로 SQL문을 저장함 )
			dynamicSQL = “DELETE FROM ENROL 
    	              WHERE Cno = ‘C413’ AND Final <= 60”;
			EXEC SQL PREPARE objSQL FROM :dynamicSQL;
			(dynamicSQL에 저장된 SQL문 예비컴파일 후 바인드 해 목적 코드 생성해 objSQL에 저장 )
			EXEC SQL EXECUTE objSQL;                         		
			(objSQL에 자장된 목적 코드의 SQL문을 실행)			
			```
			
      - PREPARE문과 EXECUTE문을 하나의 IMMEDIATE문으로 표현 가능
        - EXEC SQL EXECUTE IMMEDIATE :dynamicSQL;
        
      - 스트링으로 표현되는 SQL문에는 호스트 변수를 포함 시킬 수 없음							
			```sql
      		dynamicSQL = “DELETE FROM ENROL WHERE Cno = ? AND Final <= ?”;
        	EXEC SQL PREPARE objSQL FROM :dynamicSQL;
	          	  	cno = “C413”; 
		            	grade= 60;
					( ?인 값들인 터미널로부터 입력 받을 수 있음)
	    	EXEC SQL EXECUTE objSQL USING :cno, :grade;
				( ?를 가진 매개변수가 포함된 명령문 실행 시 USING절을 가진 EXECUTE 문에 이자 값을 명세 )
			```
			
7. 데이터 종속성과 정규화
- 데이터베이스 설계에서 중요한 사항 : 현실 세계를 가장 정확하게 표현할 수 있는 데이터의 논리적 구조를 결정하는 것
- 고려사항
	- 애트리뷰트들 사이 존재하는 관계성 (데이타 종속성)
	- 효율적인 데이타 처리
	- 데이터의 일관성 유지
- 데이터 논리적 표현
	- 삭제 이상 : 한 투플을 삭제함으로써 유지해야 될 정보까지 삭제되는 연쇄 삭제 현상이 일어나게 되어 정보 손실이 발생하게 되는 현상
		- 삭제해야하는 정보가 기본 키의 일부 값이라 투플 전체를 삭제하는 경우
	- 삽입 이상 : 데이터 삽입 시 불필요하고 원하지 않는 데이터도 함께 삽입해야만 되고 그러지 않으면 삽입되지 않은 현상
	- 갱신 이상 : 중복된 투플들 중 일부 투플의 애트리뷰트 값만을 갱신시킴으로써 정보의 모순성이 생기는 현상
- 이러한 이상이 생기는 이유
	- 여러 가지 상이한 종류의 정보를 하나의 릴레이션으로 표현하려 하기 때문에 발생
	- 애트리뷰트 간 존재하는 여러 데이터 종속 관계를 무리하게 하나의 릴레이션으로 표현하려는 데서 발생하게 된 것
	-> 정규화 과정을 통해 하나의 릴레이션에 하나의 종속성이 표현되도록 분해하는 것으로 해결
	
- 스키마 변환 : 만들어진 릴레이션들 보다 바람직한 형태의 릴레이션들로 다시 변환하는 것
	- 정보 표현의 무손실 : 변환 시 정보 손실이 있어서 안됨
	- 최소의 데이타 중복성
	- 분리의 원칙 : 하나의 독립된 관계성은 별도 릴레이션으로 분리시켜 표현

- 함수 종속 : 어떤 릴레이션 R에서 X,Y를 각각 R의 애트리뷰트 집합의 부분집합이라 할 때 애트리뷰트 X의 값 각각에 대해 시관과 관계없이 항상 애트리뷰트 Y값이 오직 하나만 연관되었을 때 Y를 X에 함수종속 이라함
	- 기본 키라면 릴레이션 R의 모든 애트리뷰트 Y는 반드시 X에 함수 종속이어야 한다
	- X->Y 관계에서 X를 결정자, Y를 종속자라 함
	
	![ex_screenshot](/res/db4.png)
	- {학번, 과목번호} -> 성적
		- 성적 애트리뷰트는 학번, 과목번호 애트리뷰트에 완전 함수 종속
	- {학번} -> {학년} 
		- 학년 애트리뷰트는 학번 애트리뷰트에 완전 함수 종속이지만 학번, 과목번호 애트리뷰트에는 부분 함수 종속
	- 완전 함수 종속 : 릴레이션 R의 어던 애트리뷰트 Y가 다른 애트리뷰트 X에 함수 종속이며 X의 진부분 집합에는 함수 종속이 아닐 때 Y는 X에 완전 함수 종속 
		- 결정자가 두 개 이상의 애트리뷰트로 구성된 경우 완전 함수 종속 문제가 발생할 수 있음
		
- 기본 정규형 
- 제1 정규형 : 어떤 릴레이션 R에 속한 모든 도메인이 원자값만으로 되어 있다면 제1 정규형에 속한다

	![ex_screenshot](/res/db5.png)
	- 지도교수와 학과 애트리뷰트 값들에 불필요하게 많은 데이타의 중복을 포함하고 있어 문제를 야기 시키고 있음
	- 키가 아닌 애트리뷰트들이 기본 키에 완전 함수 종속되지 못하고 부분 함수 종속이 되어 있기에 발생
	
	![ex_screenshot](/res/db6.jpg)
	
- 제2 정규형 : 어떤 릴레이션 R이 제1 정규형이고 키에 속하지 않은 애트리뷰트 모두가 기본 키에 완전 함수 종속이면 제2 정규형에 속한다
	- 학과는 학번에 완전 함수 종속이면서 지도교수를 통해 이행적 함수 종속 되고 있어 이상이 발생할 수 있다
	- 두 개의 상이한 정보를 하나의 릴레이션으로 혼합해 표현하려고 하는 데서 발생
	- 이행적 함수 종속을 제거해 두 개의 릴레이션으로 분해하여 해결
	
	![ex_screenshot](/res/db7.png)
	
- 제3 정규형 : 어떤 릴레이션 R이 2정규형이고 기본 키에 속하지 않은 모든 애트리뷰트들이 기본 키에 이행적 함수 종속이 아닐 때 제3 정규형에 속한다
	- 복수의 후보키를 가지고 있고 후보 키들이 두개 이상의 애트리뷰트로 구성되고 후보 키의 애트리뷰트가 서로 중첩되는 경우 적용할 수 없다
	- BCNF에 속하는 릴레이션은 모두 제3 정규형에 속하지만 역은 성립하지 않음
- 보이스/코드 정규형 : 릴레이션 R의 결정자가 모두 후보키이면 릴레이션 R은 보이스/코드 정규형에 속한다
	
	![ex_screenshot](/res/db8.png)

- 제4 정규형 : 릴레이션 R에 다치 종속을 만족하는 애트리뷰트 부분 집합 A,B가 존재할 때 R의 모든 애트리뷰트들이 A에 함수 종속(R의 모든 애트리뷰트 X에 대해 A->X이고 A가 후부키)이면 R은 제4 정규형에 속한다
	- 다치 종속 : A,B,C를 릴레이션 R의 애트리뷰트 부분집합이라 할 때 애트리뷰트 쌍 (A,C)-값에 대응되는 B-값의 집합이 A-값에만 종속되고 C-값에는 독립이면 B는 A에 다치종속이라 하고 A->>B로 표기
	- 애트리뷰트 값 하나를 경정하는 것이 아니라 몇 개의 값, 집합을 결정한다는 의미
	- R(A,B,C)에서 A->>B가 성립하면 A->>C도 동시 성립 (A->>B|C)
	
- 제5 정규형 : 릴레이션 R에 존재하는 모든 조인 종속이 릴레이션 R의 후부키를 통해서만 만족된다면 R은 제 5정규형 or PI/NF에 속한다
	- 조인 종속 : 어떤 릴레이션 R의 애트리뷰트에 대한 n개의 부분집합이 있을 때 이 릴레이션 R이 프로젝션을 모두 조인한 결과와 똑같게 된다면 R은 조인 종속을 만족
	- 릴레이션 R(A,B,C)가 조인 종속 *(AB,AC)를 만족하기만 하면 릴레이션 R은 두개의 다치종속 A->>B|C를 만족
	- 다치 종속은 조인 종속의 한 특수한 경우
	
- 정규형 간 관계

	![ex_screenshot](/res/db9.png)

8. 데이터 모델링
- 데이터 모델 : 컴퓨터에 저장할 데이터의 구조를 논리적으로 표현하기 위해 사용하는 지능적 도구

	![ex_screenshot](/res/db11.png)
	
	![ex_screenshot](/res/db10.png)
	- 개념적 모델링 : 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정, 개념적 모델링으로부터 얻은 결과를 개념적 구조라 함
	- 데이터 모델링 : 레코드 타입을 기초로 한 논리적 개념을 이용해 어떤 논리적 구조, 즉 데이터 모델로 표현하는 것이 필요한데 이 변환 과정을 데이터 모델링이라 함
	- 데이터 구조화 : 논리적 데이터 구조가 결정되면 컴퓨터가 접근할 수 있는 저장 장치 위에 데이터가 표현될 수 있도록 물리적 데이터 구조로 변환하는 과정 

- 데이터 모델 개념
	- 개념적 데이터 모델 : 속성들로 기술된 개체 타입과 개체 타입들 간 관계를 이용해 현실 세계를 표현하는 방법
	- 논리적 데이터 모델 : 데이터 필드로 기술된 레코드 타입과 레코드 타입 간 관계를 이용해 현실 세계 표현하는 방법
- 데이터 모델은 데이터 구조, 연산, 제약조건에 대해 명세를 기술한 것
	- 구조 : 데이터베이스에 표현될 대상으로 개체타입과 관계를 명세한 것, 데이터베이스의 정적 성질
	- 연산 : 데이터베이스에 표현된 개체 인스턴스를 처리하는 작업에 대한 명세, 데이터베이스의 동적 성질
	- 제약조건 : 데이터베이스에 허용될 수 있는 개체 인스턴스에 대한 논리적 제약을 명세한 것
		- 구조적 제약과 의미상 제약이 모두 포함
- 개체 타입 : 이름과 애트리뷰트로 정의되고 애트리뷰트들은 개체의 특성을 기술
	- 개체 집합 : 특정 개체타입에 대한 인스턴스들의 집합
		- 공통 애트리뷰트들을 갖지만 각 애트리뷰트에 대해 자신의 값을 가진
	- 단순 애트리뷰트 : 더 이상 작은 구성요소로 분해할 수 없는 애트리뷰트
	- 복합 애트리뷰트 : 몇 개의 기본적인 단순 애트리뷰트로 분해할 수 있는 애트리뷰트
	- 단일 값 애트리뷰트 : 특정 개체에 대해 하나의 값을 갖는 애트리뷰트
	- 다중 값 애트리뷰트 : 어느 한 개체에 대해 몇 개의 값을 가지는 애트리뷰트
	- 유도 애트리뷰트 : 다른 관련된 애트립류트나 개체가 가지고 있는 값으로부터 유도되어 결정되는 애트리뷰트
	- 저장 애트리뷰트
	- 널 애트리뷰트 : 어떤 개체 인스턴스가 특정 애트리뷰트에 대한 값을 가지고 있지 않을 때 명시적으로 표시하기 위해 사용
		- 해당 되지 않는 경우, 알수 없는 경우, 누락된 경우, 모르는 경우 등..
- 관계 타입 : 개체 타입의 모든 인스턴스들, 개체 집합들 사이의 대응, 사상을 말함
	- 개체 타입과 개체 타입 간 성립할 수 있는 관계
	- 관계 집합은 개체 집합과 개체 집합 간에 실제로 나타나 있는 관계 인스턴스
	- 유형 : 1:1 / 1:N / N:1 / N:M
	- 특성
		- 개체 집합 A와 B 사이에 정의된 A-B 관계에서 개체 집합 A의 모든 개체가 A-B 관계에 참여해야 된다면 개체 집합 A-B 관계에서 전체 참여, 일부 개체만 참여해도 되면 부분 참여라 함
		- 어떤 개체 b의 존재가 개체 a의 존재에 달려 있다면 b는 a에 존재 종속이라 하며 a를 주개체, b를 종속 개체라 함

- E-R 모델 
	- 개체 집합 내에서 각 개체들이 서로 상이한 값만을 갖는 애트리뷰트가 있어야 한다 -> 키 애트리뷰트
	- 키는 각 개체 인스턴스를 유일하게 식별하는 데 사용
	- 약한 개체 타입 : 자기 자신의 애트리뷰트만으로 키를 명세할 수 없는 개체 타입
	- 강한 개체 타입 : 자신의 애트리뷰트로 구성된 키를 가진 개체 타입
	- 강한, 약한 개체 타입은 주 개체와 종속 개체 간의 존재 종속과 관련
	- 강한 개체 타입이 주 개체, 약한 개체 타입 개체가 종속 개체가 된다
	- 약한 개체 타입에 키가 없더라도 강한 개체가 지정되면 연관된 약한 개체를 식별할 수 있지만 약한 개체 집합 내에 개체를 서로 구별할 수 있는 방법이 필요함
		- 약한 개체 타입의 구별자는 강한 개체가 주어졌을 때 연관된 약한 개체들을 서로 구별할 수 있게 하는 애트리뷰트이며 부분키라고도 함
		
	- 다이어그램 표기법
	
	![ex_screenshot](/res/db12.jpg)
		
- 논리적 데이터 모델 
	- 관계 데이터 모델 : 데이터 베이스를 구성하는 개체, 관계 모두 테이블로 표현된다는 특성을 가짐
		- 개체, 관계에 대한 릴레이션을 명세한 릴레이션 스키마 
		
	![ex_screenshot](/res/db13.png)
	
	- 네트워크 데이터 모델 : 데이터 구조도 형태가 네트워크, 그래프라는 의미
		- 일대다 관계에 연관된 두 레크드 타입을 오너, 멤버라고 함 (오너-멤버 관계)
	- 계층 데이터 모델 : 데이터 구조도가 트리 형태 인 것
		- 루트 레코드 타입을 가지고 타입 간 하나의 관계만 허용
		- 사이클이 허용되지 않으며 레코드 타입 간 상하위 레벨 관계가 성립
		- 일대다 관계를 맺는 레코드 타입을 부모, 자식 레코드 타입이라 함(부모-자식 관계)
		
9. 데이터베이스 설계
- 데이터베이스 설계 환경
- 데이터베이스 생명 주기
	![ex_screenshot](/res/db14.png)
	
	- 요구조건 분석 단계 : 데이터베이스에 저장할 데이터 범위를 정의하기 위해 사용자와 응용을 식별하고 필요로 하는 요구 사항을 분석하는 것
	- 설계 단계 : 개념적 설계에서 시작해 논리적 설계를 거쳐 목표 DBMS에 구현할 수 있는 물리적 설계까지 모두 포함
		- 사용자의 요구조건에서 데이터베이스 구조를 도출해 내는 과정
		- 데이터베이스의 논리적 물리적 구조를 어떻게 설계하느냐 하는 것이 근본적 문제
		- 데이터베이스 설계 5 단계
		![ex_screenshot](/res/db15.png)
			- 요구 조건 분석 : 데이터 및 처리 요구 조건
			- 개념적 설계 : DBMS 독립적 개념 스키마 설계, 트랜잭션 모델링
			- 논리적 설계 : DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스 설계
			- 물리적 설계 : DBMS에 맞는 물리적 구조 설계, 트랜잭션 세부 설계
			- 구현 : DBMS DDL로 스키마 작성, 트랜잭션(응용 프로그램) 작성
		- 데이터베이스 설계는 데이터베이스의 내용과 구조 설계와 데이터의 처리와 응용 소프트웨어 설계에 관한 활동으로 병행 수행
			- 데이터베이스 내용과 구조에 치중한 설계 -> 데이터 중심 데이터베이스 설계
			- 데이터의 처리와 응용에 치중한 설계 -> 처리 중심 데이터베시으 설계
	- 구현 단계 : 데이터베이스 스키마 정의, 파일 생성, 응용 소프트퉤어를 목표 DBMS 환경에 맞도록 구현
	- 운영 단계 : 데이터베이스 시스템과 응용 시스템을 실제로 운영하고 관리해 사용자 요구에 따라 서비스 제공
	- 감시 및 개선 단계 : 시스템 운영 과정에서 발생하는 새로운 요구조건이나 응용에 대처하고 부문별 시스템 활용도의 변동에 따라 저하될 지 모르는 성능 향상
	- 데이터 베이스 설계 고려사항
		- 데이터베이스 무결성
			- 일관성 : 저장된 두 데이타 값 사이나 특정 질의 응답들에 모순성이 없이 일치해야 함
			- 회복 : 장애 발생 직전의 일관된 데이터베이스 상태로 복구하는 것
			- 보안 : 의도적이거나 우연을 불문하고 불법적 데이터 변경이나 손실 OR 노출에 대한 보호 (접근제어와 밀접!!)
			- 효율성 : 응답 시간 단축, 저장 공간 최적화, 시스템 생산성 등
			- 데이터베이스 확장 : 시스템 운영에 영향 주지 않으며 새로운 데이타를 계속적으로 추가해 나갈 수 있는 기법이 있어야 함
			
- 요구조건 분석
	- 사용자의 요구조건을 수집하고 분석해 공식적인 요구조건 명세를 생성하는 것
		- 정적 정보 구조에 대한 요구 조건 : 개체, 애트리뷰트, 관계, 제약 조건 등
	 	- 동적 데이터베이스 처리 요구조건 : 트랜잭션 유형, 트랜잭션 실행 빈도 등
	 	- 범 기관적 제약 조건
	- 정보의 내용과 처리 요구 조건 수집	
		- 기능, 데이터 종류, 데이터 용도, 처리 형태, 데이터 흐름, 제약조건 및 요구조건 정보 수집
		- 트랜잭션에 대한 입출력 데이터 식별
		- 설문지, 인터뷰, 회의를 통해 문서화 ( 주요 관리자와 이용자의 의견을 빠뜨리면 안됨 )
- 개념적 설계
	- 개념적 스키마 모델링(데이터 중심 설계)과 트랜잭션 모델링(처리 중심 설계)을 병행적으로 수행
	- 개념적 스키마 모델링
		- 요구조건 분석 결과를 E-R 다이어그램 같은 개념적 데이타 모델, 즉 DBMS에 독립적이고 고차원적 표현 기법으로 기술하는 것
		- 표현 결과를 개념적 구조 OR 개념적 스키마 라고 함
		- 스키마의 구성 요소가 되는 개체 타입, 애트리뷰트, 관계성을 식별해 결ㄹ정해야 함
		- 요구 조건 분석 결과로부터 개념적 스키마를 유도하는 기본 원리는 추상화
			- 집단화 : 여러 애트리뷰트들을 그룹지어 하나의 개체로 만드는 것
			- 일반화 : 공통 성질을 가진 여러 부류의 개체들을 일반적이고 포괄적 개체로 만드는 것
	- 개념적 스키마 설계 방법
		- 뷰 통합 방법(하향식 방법)
			- 요구조건 분석 단계에서 식별된 응용, 사용자 그룹을 기초로 각 부문별 뷰를 식별하고 모델링
				- 개체를 식별하고 각 개체에 대해 키 애트리뷰트를 결정
				- 관계성 식별하고 명세하고 개체의 특성을 표현하는 설명 애트리뷰트 첨가
			- 완성된 부문별 뷰들을 하나로 통합해 전체 개념 스키마 작성
				- 집단화, 일반화 개념 이용 
		- 애트리뷰트 합성 방법 ( 상향식 방법 )
			- 작업과 데이터 관계에 기초하고 있음
			- 애트리뷰트들을 먼저 식별하고 분류
				- 애트리뷰트는 유일성 가진 애트리뷰트와 아닌 것으로 분류
			- 분류 완료 후 개체를 정의하고 키 애트리뷰트, 설명 애트리뷰트로 구성
			- 관계성 식별후 정의 
				- 개체 간 관계성, 개체와 애트리뷰트 관계성, 애트리뷰트들 간 관계성을 식별해 정의
			- E-R 다이어그램을 ㅗ전체 개념 스키마를 다이어그램 형태로 표현해 정보 구조 생성
			- 정보 구조를 분석 확인
				- 각 개체가 의존하는 것, 관계의 카디널리티, 각 개체의 종속 정보 등을 검사 확인, 누락 정보나 잘못 표현된 관계성 검사 등
	- 트랜잭션 모델링
		- 요구조건 분석 결과로 식별된 응용을 검토해 구현해야 될 트랜잭션을 고차원 명세로 정의
		- 트랜잭션을 식별하고 이들에 대한 기능적 특성을 데이터베이스 설계 단계 초기에 명세해 놓는 것
		- 트랜잭션의 입출력과 기능적 행태만 주로 정의
			- 입,출력 데이타와 내부적 제어 흐름을 명세함으로 트랜잭션을 개념적이고 시스템 독립적으로 정의
		- 검색, 갱신, 검색과 갱신 혼합 트랜잭션으로 구분
		- 모두 병행적으로 수행해 스키마와 트랜잭션 관계가 완전히 식별되고 명세될 때까지 피드백을 통해 정재해야 한다
- 논리적 설계
	- 논리적 데이터 모델로 변환
		- 개념적 스키마를 목표 DBMS에 맞는 스키마, 논리적 데이터 모델로 변환하는 과정을 데이터 모델링이라 함
		- 생성된 결과는 DBMS의 DLL로 기술된스키마
	- 트랜잭션 인터페이스 설계
		- 입출력과 기능적 행태로만 정의된 응용프로그램 즉, 트랜잭션 인터페이스를 설계
		- 트랜잭션의 전체적 골격을 개발하고 인터페이스를 정의
	- 스키마 평가 및 정제
		- 설계된 스키마를 정량적 정보, 성능 평가 기준에 따라 평가
		- 정략적 정보 : 데이터 양, 처리 빈도스, 처리 작업량 등
		- 성능 평가 기준 : 논리적 레코드 접근, 데이터 전송량, 데이터베이스 크기 등
- 물리적 설계
	- 논리적 스키마로부터 효율적인 내부 스키마를 설계하는 것
	- 논리적 데이터 모델롭루터 효율적이고 구현 가능한 물리적 데이터베이스 구조를 생성하는 것
	- 트랜잭션의 상세 설계를 병행
	- 데이터베이스가 실제 저장 장치에 구현되고 접근 되는 것은 물리족 구조 여하에 달려 있다 -> 하드웨어와 운영 체제의 특성을 고려 해야함
	- 물리적 데이터베이스 기본적 단위는 저장 레코드
	- 저장 레코드 양식 설계
		- 저장 레코드 양식은 데이타 타입, 데이터 값의 분포, 사용될 응용, 접근 빈도 등을 고려해 결정
		- 데이터 표현과 압축에 대한 양식 포함
	- 레코드 집중의 분석 및 설계 
		- 물리적으로 집중 저장되도록 할당함으로써 물리적 순차성을 이용할 수 있도록 해야함
		- 연속된 저장 공간에 할당하는 것, 효율적 검색을 위한 블록 크기 선정이 중요 -> 레코드의 크기와 물리적 저장 장치 특성에 의존
		- 데이터 레코드의 순차 처리가 주이면 큰 블록이 유리, 임의 접근 처리가 주이면 작은 블록 사용이 유리
	- 접근 경로 설계
		- 물리적 저장 장치 위에 저장된 데이타의 접근과 처리를 가능하게 하는 절차
		- 저장 구조와 탐색 기법이 기본 요소
			- 저장 구조는 인덱스를 통합 접근 방법과 저장 레코드를 정의하는 것
			- 탐색 기법은 주어진 응용을 위해 취해야 될 적절한 접근 경로를 정의하는 것
		- 접근 경로 설계(기본 접근 경로 / 보조 접근 경로)
			- 기본 접근 경로 : 기본 키를 기초로 기본 인덱스를 이용
				- 초기 레코드 적재, 레코드 물리적 위치, 기본키를 통한 검색 등과 밀접
			- 보조 접근 경로 : 보조키를 기초로 한 보조 인덱스를 통해 접근
				- 보조 인덱스를 통하면 접근 시간을 줄일 수 있으나 인덱스를 위한 저장공간, 인덱스 관리 오버헤드가 뒤따름
	- 물리적 설계 고려 사항
		- 응답 시간 : 트랜잭션이 참조하는 데이타에 대한 데이터베이스 접근 시간과 운영체제 스케줄링과 통신 지연에 영향을 받음
		- 저장 공간의 효율화 : 저장 하기위해 최소환의 저장 공간을 사용하느 것
		- 트랜잭션 처리도 : 단위 시간에 데이터베이스 시스템이 처리할 수 있는 평균 트랜잭션 수를 처리도 -> 시스템 부학가 절정을 이루는 시간대를 고려
		- 레코드 확장이나 레코드 수 증가에 따른 화일 확장 평가도 고려 대상
- 데이터베이스 구현
	- 목표 DBMS의 DLL로 기술된 명령문 컴파일하고 실행하여 데이터베이스 스키마와 공백 데이터베이스 파일 생성
	- 데이터베이스에 데이타를 적재
	- 트랜잭션은 응용 프로그래머에 의해 실행 트랜잭션으로 구현
		- 트랜잭션의 개념적 명세 검토하고 삽입 DML 명령문을 가진 프로그램 코드가 작성되어 검사됨
	- 트랜잭션 작성 후 시리제 데이타가 적재되면 설계 및 구현이 끝나고 운영 데이터베이스가 ㅗ안성

- 데이터베이스 설계 과정

	![ex_screenshot](/res/db16.png)
	![ex_screenshot](/res/db16_2.png)
		
		
		
		
		
		
		
		
	
	
