# 데이터베이스(DB)
1. 데이터베이스 환경
- 데이터 : 현실 세계로부터 단순한 관찰이나 측정을 통해 수집된 사실이나 값
- 정보 : 어떤 상황에 대한 적절한 결정을 할 수 있게 하는 지식으로 데이터의 유효한 해석이나 데이터 상호간의 관계
- 정보가 유용성을 갖기 위해서 정확성과 현재성을 가지고 있어야함
  -> 정확성과 현재성을 갖기 위해서는 데이터가 정확하고 현재의 것이어야함
- 정보시스템 : 한 조직체의 활동에 필요한 데이터를 수집, 조직, 저장해 두었다 필요시 처리해 의사 결정에 유효한 정보를 생성해 분배하는 수단
  - 목적 : 현재의 정확한 정보를 적시에 제공하여 조직체로 하여 유용한 의사 결정을 하도록 하는 것
- 데이터 웨어하우스 : 다양한 소스의 데이터를 별도로 추출해 관리하는 것
- 데이터 마이닝 : 데이터 웨어하우스 규모가 대형화되고 복잡하게 될 때 관련된 데이터를 찾아내고 필요한 정보, 지식을 생성하는 과정

- 일괄 처리 시스템
  - 유사한 트랜잭션을 한데 모아 일정 시간에 한꺼번에 처리하여 사용자의 요구를 만족시키고 시스템 효율성을 높이는데 목적이 있음
  - 트랜잭션 : 논리적 작업 단위로 하나의 단위로 처리되어야 하는 분리될 수 없는 연산 그룹
  - 장점 : 각 트랜잭션 당 처리 비용이 적게 들게 되고 시스템 성능을 높일 수 있다
  - 단점 : 대기 시간이 길어지고 사전작업을 거쳐야함
- 온라인 처리 시스템
  - 곧바로 데이터를 처리하는 방식
  - 대기시간이 없어 사용자는 편리 -> 사용자 중심 처리 방식
  - 응답시간을 최소화 해야함 -> 시스템을 계속 가동 상태 유지하고 이는 작업 당 처리 비용을 높게 만듦
  - 테스트, 유지보수가 어렵게되고 회복도 매우 복잡
  - 시스템 오보헤드로 연결되어 시스템 성능 저하의 직접적 원인
- 분산 처리 시스템
  - 지리적으로 분산되어 있는 처리기와 데이터베이스를 네트워크로 연결시켜 사용자는 마치 하나의 시스템을 사용하는 것처럼 데이터 처리해주는 시스템
  - 분산 데이터베이스 : 지리적으로 분산 저장되어 있는 형태의 데이터베이스
  - 신속한 조치, 지역 업무에 대한 책임 구분, 모듈식 구축의 용이, 다원적 재편성을 통한 신뢰성 증대 등 이점이 있음
  
- 데이터 베이스 : 어느 한 조직의 여러 응용 시스템이 공용할 수 있도록 통합, 저장된 운영 데이터 집합
  - 통합 데이터 : 원칙적으로 중복되어 있지 않음
  - 저장 데이터 : 컴퓨터가 접근 할 수 있는 저장 매체에 저장된 데이터
  - 운영 데이터 : 기능을 수행하기 위해 반드시 유지해야 할 데이터
  - 공용 데이터 : 여러 응용 시스템들이 공동으로 소유, 이용하는 공용 데이터, 서로 다른 목적으로 데이터베이스의 데이터를 공동으로 이용한다는 것
  - 데이터베이스 특성
    - 실시간 접근성 : 응답 시간은 단 몇 초를 넘지 않아야 함
    - 계속적인 변환 : 변화 속에서 현재의 정확한 데이터를 유지해야함
    - 동시 공용 : 여러 사용자가 동시에 원하는 데이터에 접근하여 이용할 수 있어야함
    - 내용에 의한 참조 : 사용자가 요구하는 데이터의 내용, 데이터가 가지는 값에 따라 참조
  - 개체 : 데이터베이스에서 표현하려고 하는 유형, 무형의 객체로 서로 구별되는 것
    - 하나 이상이 속성(애트리뷰트)으로 구성되고 각 속성은 개체의 특성이나 상태를 기술
    - 속성은 이름을 가진 데이터의 가장 논리적 단위
    - 개체 인스턴스 : 개체를 구성하고 있는 속성들이 어떤 구체적인 값을 가진 상태 -> 인스턴스 집합을 개체 집합이라함
  - 관계
    - 속성 관계 : 어느 한 개체를 기술하는 속성들 간의 관계(개체 내 관계)
    - 개체 관계 : 개체 집합과 개체 집합 사이의 관계(개체 간 관계)
  - 데이터베이스 구조 
    - 논리적 구조 : 사용자가 생각하는 데이터의 논리적 표현 (일반 사용자나 응용 프로그래머의 입장에서 보는 구조, 가상적인 구조)
    - 논리적 구조에서 취급하는 데이터 레코드 -> 논리적 레코드
    - 물리적 구조 : 저장 장치 위에 물리적으로 저장 되어 있는 데이터의 실제 구조
    - 물리적 구조에서 취급하는 데이터 레코드 -> 저장 레코드

2. 데이터베이스 관리 시스템
- 데이터 종속성 : 응용 프로그램과 데이터 간의 상호 의존 관계, 데이터 구성 방법이나 접근 방법을 변 경시 자연히 이것을 기초로 한 응요 프로그램도 같이 변경해야 하는 데 이것을 데이터 종속성이라 함
- 데이터 중복성 : 한 시스템 내에 내용이 같은 데이터가 중복되게 저장 관리 되는 것
  - 데이터 중복성으로 인해 야기되는 문제점
    - 데이터 일관성 : 동일성을 유지하기 어렵고 데이터 간 불일치 발생
    - 보안성 : 같은 내용의 데이터에 대해 같은 수준의 데이터 보안이 유지 되어야함
    - 경제성 : 중복 시 추가적으로 필요한 저장 공간에 대한 비용이 더 들게 됨
    - 무결성 : 중복 시 제어가 분산되게 되어 데이터의 정확성 유지가 어려움
- 데이터베이스 관리 시스템(DBMS) : 응용 프로그램과 데이터의 중재자로 모든 응용 프로그램들이 데이터베이스를 공용할 수 있게 관리해주는 SW 시스템
  - DBMS 필수 기능
    - 정의 기능 : 다양한 응용 프로그램과 데이터베이스가 서로 인터페이스 할 수 있는 방법 제공
      - DB의 논리적 구조와 특성이 DBMS가 지원하는 데이터 모델에 맞게 기술되어야함
      - DB를 물리적 저장 장치에 저장하기 위한 데이터의 물리적 구조의 명세도 포함되어야함
      - 데이터의 논리적 구조와 물리적 구조 사이에 상호 변환이 가능하도록 구조 사이의 사상을 명세해야함
    - 조작 기능 : 사용자와 인터페이스 사이의 인터페이스를 위한 수단 제공
      - 모든 사용자에게 사용하기 쉽고 자연스러워야 함
      - 명확하게 명세할 수 있어야하고,  합법적인 범위내에서 완전히 명세할 수 있어야함
      - 효율적이어야 함
    - 제어 기능 : DB의 내용에 대해 항상 정확성과 안정성을 유지할 수 있는 데이터 제어 기능을 가져야함
      - 데이터의 무결성이 파괴되지 않도록 제어할 수 있어야함
      - 권한 검사하고 보안을 유지할 수 있어야 함
      - 여러 사용자가 동시에 접근해 처리하더라도 DB와 처리결과는 항상 정확성이 유지되도록 병행 제어 기능을 가져야함
  - DBMS의 장점 
    - 데이터 중복 최소화 / 데이터 공용 / 데이터 일관성 유지 / 데이터 무결성 유지 / 데이터 보안 보장 / 표준화 / 전체 데이터 요구의 조정
  - DBMS 단점
    - 운영비 증대 / 특정 응용 프로그램의 복잡화 / 복잡한 백업과 회복 / 시스템 취약성 
  - 데이터 독립성 : 논리적 구조나 물리적 구조가 변경 되더라도 응요 프로그램이 영향 받지 않도록 제공해야함
    - 논리적 데이터 독립성 : DBMS가 DB의 논리적 구조를 변경하더라도 기존 응용 프로그램들에 아무런 영향을 주지 않는 것
    - 물리적 데이터 독립성 : 기존 응용 프로그램, 논리적 구조에 아무런 영향을 주지 않고 DBMS이 DB의 물리적 구조를 변경할 수 있는 것

3. 데이터베이스 시스템의 구성
- 1) 3단계 데이터 베이스

    ![ex_screenshot](/res/db1.png)
    
  - 스키마 : DB 구조와 제약조건에 대한 명세를 기술 한 것(개체, 관계, 제약 조건, 속성에 대한 정의 포함)
  - 외부 스키마(외부 단계)
    - 데이터베이스의 개인 사용자나 응용 프로그래머가 접근하는 데이터베이스를 정의한 것
    - 데이터베이스 전체의 한 논리적 부분이 되는 것이기에 서브 스키마라고도 함
    - 하나의 데이터베이스 시스템은 여러 외부 스키마가 존재
  - 개념 스키마
    - 범 기관적 입자에서 데이터베이스를 정의한 것
    - 응용 시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 데이터베이스를 기술한 것
  - 내부 스키마
    - 저장 장치의 입장에서 데이터베이스 전체가 저장되는 방법을 명세한 것
    - 개념 스키마에 대한 저장 구조를 정의한 것
  - 외부/개념 사상
    - 특정 외부 스키마와 개념 스키마간의 대응 관계 정의 (응용 인터페이스) -> 논리적 데이터 독립성 제공
  - 개념/내부 사상
    - 개념 스키마와 내부 스키마간의 대응 관계 정의(저장 인터페이스) -> 개체의 각 속성이 내부 필드와 어떻게 대응 되는가를 정의 -> 물리적 데이터 독립성 제공
  - 시스템 카탈로그 : 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정의나 명세에 관한 정보를 유지하는 시스템
  - 데이터 디렉토리 : 데이터베이스에 수록된 데이터로 접근하는 데 필요한 위치 정보를 관리하는 시스템
  -> 두 개다 시스템 데이터베이스이지만, 시스템 카탈로그는 사용자가 접근해 검색 가능하지만 데이터 디렉토리는 시스템만 접근 가능
  
- 2) DBMS
  - 사용자의 데이터베이스 사이에 위치해 데이터베이스를 관리하고 사용자가 요구하는 연산을 수행해 정보를 생성해주는 소프트웨어
  
    ![ex_screenshot](/res/dbms.png)
    
    - DDL 컴파일러 : DDL로 명세된 스키마 정의를 내부 형태로 변환해 시스템 카탈로그에 저장
    - 질의어 처리기 : 사용자가 제출한 고급 질의문 처리(질의문 팡싱하고 분석해 컴파일)
    - DML 예비 컴파일러 : 응용 프로그램 속에 삽입된 DML 명령문들을 추출하고 그 자리에 함수 호출문 삽입
    - DML 컴파일러 : DML 명령문을 파싱하고 컴파일하여 효율적인 목적 코드 생성
    - 런타임 데이터베이스 처리기 : 실행 시간에 데이터베이스 접근을 관리함
    - 트랜잭션 관리자 : 무결성 제약조건이 만족하는지 검사, 권한 검사, 병행제어, 회복 작업 수행
    - 저장 데이터 관리자 : 디스크에 저장된 사용자가 데이터베이스나 시스템 카탈로그 접근을 책임 
    
- 3) 데이터 언어
  - 데이터 정의어 : 데이터베이스를 정의하거나 정의를 수정할 목적으로 사용하는 언어
    - 기술된 데이터 스키마는 DDL 컴파일러가 컴파일하여 시스템 카탈로그에 저장해 놓고 필요한 경우 시스템이 활용
  - 데이터 조작어 : 사용자가 DBMS로 하여금 원하는 데이터를 처리하게끔 명세하는 도구로 사용자와 DBMS 간 인터페이스 제공
    - 절차적 데이터 조작어 : 사용자가 모슨 데이터를 원하고 어떻게 접근해야 하는지 명세해야되는 저급 데이터 언어
      - 한번에 하나의 레코드를 검색해 호스트 언어와 함께 처리 -> 응용 프로그램 속에 삽입되어 사용됨
    - 비 절차적 데이터 조작어 : 사용자가 무슨 데이터를 원하는지만 명세하고 어떻게 접근해 처리할지는 명세할 필요 없이 DBMS에 위임하는 고급 데이터 언어 
      - 선언적 언어라고하며 한번에 여러 개의 레코드를 검색해 처리함
  - 데이터 제어어 : 데이터 제어에 관해 정의하고 기술하는 언어
    - 데이터 보안, 무결성, 회복, 병행 수행 제어를 명세할 수 있는 명령어 포함
  - 데이터 언어의 완정성 : 사용자가 원하는 데이터베이스의 어떤 객체도 추출하고 처리할 수 있어며 어떤 연산도 표현할 수 있는 데이터 언어의 능력

4. 관계 데이터베이스
- 1) 관계 데이터 모델

  ![ex_screenshot](/res/db2.png)
  
  - 테이블의 열은 속성(Attribute), 행은 튜플(tuple)
  - 데이터의 가장 작은 논리적 단위는 Attribute 값 -> 원자값만 허용
  - 하나의 Attribute가 취할 수 있는 같은 타입의 모든 원자 값들의 집합을 Attribute의 Domain이라 함
  - 각 Attribute는 어는 한 Domain으로부터만 값을 취할 수 있음
- 2) Relation(릴레이션)
  - Relation Schema는 이름과 Attribute 집합으로 구성되어 있음
  - Relation Schema는 한 릴레이션의 논리적 구조를 정의한 것
  - 관계 데이터 베이스 스키마는 한 관계 데이터베이스의 논리적 구조를 정의한 것, 하나 이상의 릴레이션 스키마가 포함 된다
  - 릴레이션, 데이터베이스 인스턴스는 동적 성질을 가지고 릴레이션, 데이터베이스 스키마는 정적 성질을 가짐
  - 카티션 프로덕트를 기술하는 도메인 순서는 결과에 영향을 주기에 중요함
  - 릴레이션 정의에 사용된 도메인 개수를 차수, 투플의 수를 카디널리티라 함
- 3) 릴레이션의 특성 
  - 투플의 유일성
  - 투플의 무순서성 
  - 애트리뷰트의 무순서성
  - 애트리뷰트의 원자성 
  - 널 값도 관계 데이터 모델에서는 원자 값으로 취급
- 4) 관계 데이터베이스 개념
  - 관계 데이터베이스 스키마는 릴레이션 스키마 집합과 무결성 제약 조건으로 구성
  - 관계 데이터베이스 인스턴스는 관계 데이터베이스 스키마에 정의된 릴레이션 인스턴스들의 집합
- 5) 데이터베이스 키 
  - 투플을 유일하게 식별할 수 있는 애트리뷰트 집합을 릴레이션의 키라고 함
  - 유일성 : 릴레이션에 있는 모든 투플에 대해 값이 상이하고 유일하다
  - 최소성 : 유일성을 가진 k가 둘 이상의 애트리뷰트로 구성되어 있을 때 어느 한 애튜리뷰트라도 제외하는 경우 유일성이 깨진다
    - k는 모든 투플을 유일하게 식별하는 뎅 필요한 애트리뷰트들로만 구성
    
  - 슈퍼키 : 유일성만 만족하고 최소성을 만족하지 못한 경우
  - 기본키 : 투플을 식별하기 위한 도구로 db 설계자가 지정한 하나의 후보키 -> 널 값을 가질 수 없다
  - 대체키 : 기본키로 지정되지 않은 나머지 후보키들
  - 외래키 : 릴레이션 R에 속한 어떤 애트리뷰트 집합 FK가 있을 때 FK 값은 반드시 어떤 릴레이션 S의 기본키 값이어야 할 때 FK를 릴레이션 R의 외래키라 함 ( R을 참조 릴레이션, S를 피참조 릴레이션)
    - 외래키와 기본키의 도메인은 같아야함
- 6) 무결성 제약
  - 무결성 종류 
    - 널 무결성 : 릴레이션 특정속성 값이 NULL이 될 수 없도록 하는 규정
    - 고유 무결성 : 릴레이션의 특정 속성에 대해 각 튜플이 갖는 값들이 서로 달라야하는 규정
    - 참조 무결성 : 외래키 값은 NULL이거나 참조 릴레이션의 기본 키 값과 동일해야 한다는 규정
    - 도메인 무결성 : 특정 속성 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
    - 키 무결성 : 하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정
  - 널 값
    - 알려지지 않은(모르는 값)
    - 값이 있지만 아직 모름
    - 해당 없음 등
    - 이러한 이유로 정보 부재를 명시적으로 표시하기 위해 사용하는 특수 데이터 값
  - 개체 무결성 제약 : 기본 키에 속해 있는 애트리뷰트는 널 값을 가질 수 없음
  - 참조 무결성 제약 : 참조할 수 없는 외래 키 값을 가져서는 안된다는 것을 의미
    - 널이 아니면서 참조된 릴레이션의 어떤 기본 키값과도 일치하지 않는 값을 의미

5. 관계 대수와 관계 해석
- 1) 관계 대수 : 원하는 목표 데이터를 얻기 위해 어떻게 해야 되는지 일련의 연산을 순서대로 명세해야 하는 절차 언어
  
  ![ex_screenshot](/res/db3.png)
  - 일반 집합 연산자     
    - 합집합 : 차수는 r or s의 차수, 카디널리티는 r+s 보다 크지 않아야함
    - 교집합 : 차수는 r or s의 차수, 카디널리티는 r과 s의 카디널리티보다 크지 않음
    - 차집합 : 차수는 r or s의 차수, 카디널리티는 r의 카디널리티보다 크지 않음
    - 카티션 프로덕트 : 차수는 r+s, 카디널린티는 r*s
    - 합,교,차 집합은 합병 가능해야함 ( 합병 가능은 두 릴레이션의 차수가 같고 대응 애트리뷰트별로 도메인이 같음)
    - 합/교집합, 카티션 프로덕트는 결합적이고 교환적
  - 순수 관계 연산자 
    - 실렉트 : 수평적 부분 집합
    - 프로젝트 : 수직적 부분 집합
    - 조인 
      - ⍬로 표현될 수 있는 조인을 세타조인
      - ⍬가 =인 동일 조인
      - 동일 조인 결과에서 중복 애트리뷰트 제거하는 연산을 자연 조인
    - 디비전 : s의 모든 투플에 연관된 r의 투플을 선택
    - 개명 연산 
  - 기본 연산과 복합 연산 
    - 기본 연산 : 합, 차집합, 카티션 프로덕트, 실렉트, 프로젝트
    - 복합 연산 : 조인, 교집합, 디비전
  - 관계 대수 확장
    - 세미 조인 : s와 자연조인에 참여할 수 있는 r의 투플만 선택하는 것을 의미
    - 외부 조인 : 조인 상대 릴레이션에 대응되는 투플이 없을 경우 이를 제외않고 상대를 널 투플로 만들어 결과 릴레이션에 포함하는 연산
    - 외부 합집합 : 완전하게 합병 가능하지 않은 두 릴레이션을 합집합으로 만드는 것
      - 확장 애트리뷰트에 해당되는 값이 없는 경우 널 값으로 채움
    - 집계 연산 : SUM, AVG, MAX, MIN, COUNT 등이 있고 특별히 지정한 애트리뷰트 값에 따라 투플들을 그룹 짓게하는 GROUP이 있음
    
- 2) 관계 해석 : 원하는 정보가 무엇이라는 것만 선언하는 비절차적 언어
  - 투플 관계 해석
  - 도메인 관계 해석

6. SQL
- 1) SQL 데이터 정의문 
  - 스키마와 카탈로그 
    - SQL 스키마 : 스키마 이름을 식별되고 허가권자와 스키마의 각 요소에 대한 기술자 포함
      - 테이블, 뷰, 도메인, 기타 허가권이나 무결성 등에 관한 요소 포함
      - CREATE SCHEMA UNIVERSITY AUTHORIZATION SHLEE; -> 이름이 UNIVERSITY이고 허가권자가 SHLEE인 스키마 생성
    - 카탈로그 : 한 SQL 시스템 내의 스키마들의 집합 
      - 각 카탈로그는 반드시 INFORMATION_SCHEMA라는 스키마를 포함하며 카탈로그에 포함된 모든 스키마들의 정보와 스키마들의 모든 요소들에 대한 정보를 제공하기 위한 것
  - 도메인 정의문   
    - SQL이 지원하는 데이터 타입으로만 정의
		
    - CREATE DOMAIN 도메인_이름 데이타 타입
		
                    [기정_값_정의]                
											=> DEFAULT 값 OR NULL
											
                    [도메인_제약조건_정의리스트]   
											=> 무결성 제약 조건, CONSTRAINT, CHECK로 명세
											
    - EX) CREATE DOMAIN DEPT CHAR(4)
                 DEFAULT '???'
                 CONSTRAINT VALID_DEPT
                 CHECK( VALUE INT
                   ('COMP', 'ME', 'EE','ARCH','???'));
									 
    - ALTER DOMAIN 으로 변경 가능 -> 도메인 수정
    - DROP DOMAIN 도메인_이름 옵션; -> 도메인 삭제
      - 옵션 RESTRICT : 이 도메인을 참조하고 있는 것이 없을 때만 삭제
      - CASCADE : 도메인을 참조하고 있는 뷰나 제약조건도 함께 삭제되지만 참조 열은 삭제되지 않고 다른 형태의 타입으로 변경
  - 기본 테이블 생성
    - 기본 테이블 : CREATE TABLE로 만들어지는 테이블로 독자적으로 존재하는 테이블
    - 가상 테이블 : CREATE VIEW로 만들어지는 테이블로 독자적 존재 불가, 기본 테이블로 유도되어 만들어 지는 테이블
    - 임시 테이블 : 질의문 처리 과정의 중간 결과로 만들어 지는 테이블
    - CREATE TABLE SQL문
    
    	     CREATE TABLE 기본 테이블
             ({열_이름 데이타 타입 [NOT NULL] [DEFAULT 값],}+   
			=> [] 생략 가능, {} 중복 가능 '+'는 1번 이상, * 는 0번 이상								
             [PRIMARY KEY(열_이름_리스트),]                   
			=> 기본키 명세, 개체 무결성 정의								
             {[UNIQUE (열_이름_리스트).]}                    
			=> 대체키(후보키 명세)							
             {[FOREIGN KEY(열_이름_리스트)
                  REFERENCES 기본테이블[(열_이름_리스트)]
                  [ON DELETE 옵션]
                  [ON UPDATE 옵션],]}*
                  [CONSTRAINT 이름] [CHECK(조건식)]);          
			=> 외래키로 참조 무결성 유지
			   옵션 NO ACTION, CASCADE, SET NULL, SET DEFAULT
			   CHECK절은 행 갱신, 삽입 시 유지되어야 할 무결성 제약 조건
											
    - 예제
    	CREATE TABLE ENROL(Sno INT NOT NULL,
         		Cno CHAR(6) NOT NULL,
         		Grade INT,
         PRIMARY KEY(Sno, Cno),
         FOREIGN KEY(Sno) REFERENCES STUDENT(Sno)
                ON DELETE CASCADE
                ON UPDATE CASCADE,
         FOGEIGN KEY(Cno) RREFERENCES COURSE 
                ON DELETE CASCADE
                ON UPDATE CASCADE,
         CHECK(Grade>=0 AND Grade<=100));
         
  - 기본 테이블 제거와 변경 
    - DROP TABLE COURSE CASCADE;
      - CASCADE : 참조하는 다른 뷰 정의, 제약조거너이 있으면 함께 자동 삭제
      - RESTRICT : 다른 뷰 정의에서나 조약조건에서 참조되고 있는 경우 실행되지 않음
			
    - DROP SCHEMA UNIVERSITY CASCADE;
      - CASCADE : 스키마뿐 아니라 연관 객체들 모두 삭제
      - RESTRICT : 스키마가 공백인 경우에만 삭제
			
    - ALTER TABLE ENROL ADD Final CHAR DEFAULT 'F';
    - ALTER TABLE ENROL ALTER Grade SET DEFAULT '0'; -> 기정 값 변경
    - DROP CONSTRAINT 이름 -> 제약 조건 삭제
		
- 2) SQL 데이타 조작문
  - 데이타 갬색
    - SELECT [ALL|DISTINCT] 열_리스트
      FROM 테이블_리스트
      [WHERE 조건]
      [GROUP BY 열_리스트]
      [HAVING 조건]
      [ORDER BY 열_리스트] ASC|DESC]];
    
    - SELECT Sno AS 학번, '중간시험 =' AS 시험, Midtern+3 AS 점수
      FROM ENROL
      WHERE Cno='c312';
      
      SELECT S.Sname, S.Dept, E.Grade
      FROM STUDENT S, ENROL E
      WHERE S.Sno = E.Sno and E.Cno = 'C413';
      
    - 조인 조건의 3가지 형식
      - 테이블1 JOIN 테이블2 ON 조건식
      - 테이블1 JOIN 테이블2 USING(열_리스트)
      - 테이블1 NATURAL JOIN 테이블2
    
      - SELECT Sname, Dept, Grde
        1)FROM STUDNET JOIN ENROL ON(STUDENT.Sno = ENROL.Sno)
        2)FROM STUDNET JOIN ENROL USING(Sno)
        3)FROM STUDNET NATURAL JOIN ENROL
        WHERE ENROL.Cno ='C413;
				
    - GROUP BY 이용 검색 
      - SELECT Cno, AVG(Final) AS 기말평균
        FROM ENROL
        GROUP BY Cno                       
					=> GROUP BY 절에 명세된 열의 값에 따라 그룹으로 분할 
					
        HAVING COUNT(*)>=3         
					=> 각 그룹의 구성 요건 명세 
				
    - Subquery 사용 검색
      - SELECT Sname 
        FROM STUDENT 
        WHERE Sno IN (SELECT Sno FROM ENROL WHERE Cno =’C413’);
      - SELECT Sname 
        FROM STUDENT 
        WHERE Sno NOT IN (SELECT Sno FROM ENROL WHERE Cno =’C413’);
      - SELECT Sname, Dept 
        FROM STUDENT 
        WHERE Dept = (SELECT Dept FROM STUDENT WHERE Sname =’정기태‘); 
				
    - Like 사용 검색
      - SELECT Cno, Cname 
        FROM COURSE
        WHERE Cno LIKE ‘C%’;
      - LIKE 프레디킷은 서브 스트링 패턴을 비교하는 비교 연산자 
        - %는 서브 스트링 패턴을 명세 
        - C% -> C로 시작, S__ -> S로 시작 세문자 스트링, LIKE '$S$' -> S포함 스트링
				
    - NULL 사용 검색
      - SELECT Sno, Sname
        FROM STUDENT
        WHERE Dept IS NULL;
				
    - EXISTS 사용 검색
      - SELECT Sname
        FROM STUDENT
        WHERE EXISTS(NOT EXIST도 가능) 
          (SELECT * 
           FROM ENROL
           WHERE Sno = STUDENT.Sno AND Cno = ‘C413’);
					 
  - 데이타 갱신 
    - UPDATE 테이블 
      SET {열_이름 = 산술식}`+
      [WHERE 조건];
			
    - UPDATE ENORL
      SET Final = Final + 5
      WHERE Sno IN (SELECT Sno 
                    FROM STUDENT
                    WHERE Dept = ‘컴퓨터’);
										
  - 데이터 삽입
    - INSERT
      INTO 테이블[(열_이름_리스트)]
      VALUES (열_값_리스트);
			
    - INSERT
      INTO 테이블[(열_이름_리스트)]
      SELECT문;
			
    - INSERT
      INTO STUDENT(Sno, Sname, Year, Dept)
      VALUE(600, ‘박상철’, 1, ‘컴퓨터’);
			
    - INSERT
      INTO COMPUTER(Sno, Sname, Year)
        SELECT Sno, Sname, Year
        FROM STUDENT
        WHERE Dept= ‘컴퓨터’;
				
  - 데이터 삭제
    - DELETE
      FROM 테이블
      [WHERE 조건];
			=> WHERE 절 없으면 투플이 모두 삭제 된 빈 테이블이 됨.
			
    - DELETE
      FROM STUDENT
      WHERE Sno = 100; 
			
    - DELETE
      FROM ENROL; 
			=> 빈 테이블이 됨.
			
    - DELETE
      FROM ENROL
      WHERE Cno = ‘C413’ AND Final <60 AND ENROL.Sno IN 
                                                     (SELECT Sno 
                                                      FROM STUDENT 
                                                      WHERE Dept = ‘컴퓨터’);
  
- 3) SQL 뷰
  - 뷰는 다른 테이블로부터 유도된 이름을 가진 가상 테이블
  - 뷰 정의만 시스템 내에 저장해 두었다가 필요시 실행 시간에 테이블을 구축
  - ALTER문 을 이용한 변경 불가
  - 뷰 생성 
    - CREATE VIEW 뷰_이름[(열_이름_리스트)] 
          AS SELECT문                       
        [WITH CHECK OPTION];                
					=> 뷰에 대한 갱신, 삽입 연산 시 뷰 정의 조건 위반 시 실행 거부 되는 제약 조건
					
			=> AS SELECT문에 UNION, ORDER BY 사용 불가
			
    - CREATE VIEW CSTUDENT 
          AS SELECT Sno, Sname, Year 
             FROM STUDENT 
             WHERE Dept = ‘컴퓨터’ WITH CHECK OPTION;
    - CREATE VIEW HONOR(Sname, Dept, Grade)
          AS SELECT STUDENT.Sname, STUDENT.Dept, ENROL.Final      
             FROM STUDENT, ENROL 
             WHERE STUDENT.Sno = ENROL.Sno AND ERNOL.Final >90;  
  - 뷰 제거 
    - DROP VIEW 뷰_이름 {RESTRICT | CASCADE};
      - RESTRICT -> 다른곳에 참조되고 있지 않는 한 데이터베이스에서 제거되어 없어진다.
      - CASCADE -> 해당 뷰 뿐만 아니라 뷰가 사용된 다른 모든 뷰나 제약 조건이 함께 제거
   
  - 뷰의 조작 연산
    - 뷰는 검색문을 사용할 수 있으나 삽입, 삭제, 갱신문에는 제한이 있다
    - 기본키를 포함하지 않는 뷰일 경우 삽입 불가
    - 둘 이상의 테이블로 동일 조인으로 정의되었다면 갱신 시 많은 문제점 발생 가능
    - 통계요약을 위해 정의된 경우에 변경 연산은 많은 문제점을 야기 할 수 있다
    
    - 변경이 허용되지 않는 경우
      - 뷰의 열이 상수, 산술연산자, 함수가 사용된 산술 식으로 만들어지면 변경 불가
      - 집계함수가 관련되어 정의된 뷰는 변경 불가
      - DISTINCT, GROUP BY, HAVING이 사용되어 정의된 뷰는 변경 불가
      - 두 개 이상의 테이블이 관련되어 정의된 뷰는 변경 불가
      - 변경할 수 없는 뷰를 기초로 정의된 뷰는 변경 불가 
  - 뷰의 장단점
    - 데이터의 논리적 독립성을 어느 정도 제공할 수 있다.
    - 데이터의 접근을 제어함으로써 보안을 제공할 수 있다.
    - 사용자의 데이터 관리를 간단하고 쉽게 해준다.
    - 여러 사용자의 상이한 응용이나 요구를 지원해 줄 수 있다.
    - 뷰의 정의를 변경할 수 없다.
    - 삽입, 삭제, 갱신 연산에 많은 제한을 가지고 있다. 
    
- 4) 삽입 SQL
  - 응용 프로그램 특징 
    - 삽입 SQL문은 명령문 앞에 ‘EXEC SQL’을 붙여 다른 호스트 언어의 명령문과 쉽게 구별, 끝에는 세미콜론과 같은 특별한 종료 심벌을 붙여 표시
    - 삽입 SQL 실행문은 호스트 언어의 실행문이 사용되는 곳이면 어디나 나타날 수 있고 실행문, 비 실행문이 있는데 DECLARE CURSOR, BEGIN, END, DECLARE SECTION은 비실행문이다.
    - 삽입 SQL문은 호스트 변수를 포함 할 수 있고 다른 SQL 필드 이름과 구별하기위해 콜론을 앞에 붙인다. 호스트 변수는 검색 결과를 저장하는 장소를 나타내기 위해 INTO 절에 나타날 수 있다.
    - SQL문에서 사용할 호스트 변수는 사용전 반드시 삽입 SQL 선언부인 BEGIN/END DECLARE SECTION속에서 선언되어야 한다. 여러개 있어도 무방하다
    - SQLSTATE라는 스트링 타입의 호스트 변수를 포함한다. 실행 상태 표시가 SQLSTATE 변수를 통해 프로그램에 전달된다.
      - 변수 값이 “00000” -> 성공적으로 실행, “02000” -> 실행 했지만 아무런 데이터도 검색하지 못함을 의미
    - 삽입 SQL문의 호스트 변수의 데이터 타입은 이에 대응하는 데이터베이스 필드의 SQL 데이터 타입과 일치해야한다. 
    - 호스트 변수와 데이터베이스 필드 이름은 같아도 된다.
    - SQL문 실행 후 SQLSTATE 변수에 반환된 값을 검사해야한다.
      - EXEC SQL WHENEVER <조건> <행동>;
      - 조건은 SQLERROR이거나 NOT FOUND, 행동은 CONTINUE, GOTO문
  - 커서 
    - SQL 레코드 집합 단위 처리와 호스트 언어의 개별 레코드 단위 처리 사이에 어떤 교량 시설
    - 응용 프로그램의 삽입 SQL에만 사용되는 새로운 객체, 레코드 집합을 처리하는 데 사용되는 일종의 포인터
  - 커서가 필요 없는 데이터 조작
    - 단일 레코드 검색
      - EXEC SQL SELECT Sname, Dept 
             INTO :sname, :dept 
             FROM STUDENT
             WHERE Sno = :sno;
    - 갱신 
      - EXEC SQL UPDATE ENROL
                 SET Final = Final + :new 
                 WHERE Cno = ‘C413’; 
    - 삭제
      - EXEC SQL DELETE
                 FROM ENROL
                 WHERE SNO = :sno
    - 삽입
      - EXEC SQL INSERT
                 INTO STUDENT(Sno, Sname, Dept)
                 VALUES(:sno, :sname, :dept); 
                 
  - 커서를 이용하는 데이터 조작
  
    - EXEC SQL DECLARE C1 CURSOR FOR 
    	=> 커서 C1 정의, 커서를 FOR 뒤의 SELECT 문과 연결				
               SELECT Sno, Sname, Year 
 	             FROM STUDENT
               WHERE DEPT= :dept;
	       		=> 커서가 OPEN 될 때 실행							
      EXEC SQL OPEN C1;                     
      	=> C1으로 접근되는 모든 레코드에 대해 질의문 실행									
              DO                
	      	EXEC SQL FETCH C1 INTO :sno, :sname, :year; .....
               		=>  활동 세트 내의 다음레코드를 지시하게 하고 레코드의 필드 값을 호스트 변수들에 각각 저장 								
              END
      EXEC SQL CLOSE C1;
      	=> 커서 C1 활동 종료 
      
    - EXEC SQL UPDATE SUTDENT
               SET Year = :year
               WHERE CURRENT OF C1;  
				=> 현재 가리키고 있는 레코드의 Year 값을 호스트변수가 가진 값으로 변경
    - EXEC SQL DELETE
  	       FROM STUDENT
	       WHERE CURRENT OF C1;
				=> 현재 가리키고 있는 레코드를 삭제 
		
  - 다이내믹 SQL
    - 온라인 응용을 실행 시간에 구성할 수 있는 삽입 SQL
			
    	```sql			
			varchar dynamicSQL[256]; ( 문자 스트링 변수로 SQL문을 저장함 )
			dynamicSQL = “DELETE FROM ENROL 
    	              WHERE Cno = ‘C413’ AND Final <= 60”;
			EXEC SQL PREPARE objSQL FROM :dynamicSQL;
			(dynamicSQL에 저장된 SQL문 예비컴파일 후 바인드 해 목적 코드 생성해 objSQL에 저장 )
			EXEC SQL EXECUTE objSQL;                         		
			(objSQL에 자장된 목적 코드의 SQL문을 실행)			
			```
			
      - PREPARE문과 EXECUTE문을 하나의 IMMEDIATE문으로 표현 가능
        - EXEC SQL EXECUTE IMMEDIATE :dynamicSQL;
        
      - 스트링으로 표현되는 SQL문에는 호스트 변수를 포함 시킬 수 없음							
			```sql
      		dynamicSQL = “DELETE FROM ENROL WHERE Cno = ? AND Final <= ?”;
        	EXEC SQL PREPARE objSQL FROM :dynamicSQL;
	          	  	cno = “C413”; 
		            	grade= 60;
					( ?인 값들인 터미널로부터 입력 받을 수 있음)
	    	EXEC SQL EXECUTE objSQL USING :cno, :grade;
				( ?를 가진 매개변수가 포함된 명령문 실행 시 USING절을 가진 EXECUTE 문에 이자 값을 명세 )
			```
			
7. 데이터 종속성과 정규화
