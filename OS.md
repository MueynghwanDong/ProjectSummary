# 운영체제(Operating System)

### 서론
1.1 운영체제가 할일 
1) 사용자 관점 
- PC : 한 사용자가 자원을 독점하도록 설계되었으며 사용자가 수행하는 작업을 최대화하는 것이 목적, 사용의 용이성을 위해 설계
- 대형, 미니 컴퓨터 : 자원을 공유하며 정보 교환 가능, 자원 이용을 극대화하도록 설계하며 각 개인은 자신의 정당 몫만 사용 가능
- 워크스테이션, 서버 : 자신이 맘대로 할 수 있는 전용자원을 갖지만 네트워킹 서버-파일, 프린트 서버를 공유, 개인의 사용 용이성과 자원 이용간 적절한 조화를 이루도록 설계
- 휴대용 컴퓨터 : 개인 사용자들을 위한 독립형 장치
2) 시스템 관점 
- 자원 할당자 : 자원의 관리자로 동작하며 작업을 위해 특정 프로그램과 사용자에게 필요 자원 할당, 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할지 결정해야함
- 제어프로그램 : 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어

1.4 운영체제 구조
- 운영체제의 가장 중요한 면 => 다중 프로그램을 할 수 있는 능력
- 다중 프로그래밍
  - CPU가 수행할 작업을 항상 하나 가지도록 구성함으로 CPU 이용률을 증가한다
  - 작업들은 디시크의 작업 풀 내에 유지된다
  - 작업 풀은 디스크 내의 모든 프로세스로 구성되며 주 메모리의 할당을 기다린다
  - 메모리 내 작업 집합은 작업 풀 내의 작업들의 부분 집합이다
  - 여러 시스템 자원을 효율적으로 이용할 수 있는 환경을 제공하나 사용자를 위해 컴퓨터 시스템과 상호작용을 제공하지 않음
  - 시분할은 다중 프로그래밍의 논리적 확장
- 시분할 시스템
  - 사용자, 시스템 간 직접 통신을 제공하는 대화식 컴퓨터 시스템을 필요로 함
    - 응답시간이 짧아야 하며, 1초 이내 정도
  - 동시에 많은 사용자가 컴퓨터를 공유하도록 한다
  - CPU 스케줄링과 다중 프로그래밍을 사용한다 
    - 각 사용자에게 시분할 되는 작은 부분을 제공하기 위해 
  - 시분할과 다중 프로그래밍 운영체제는 여러 작업이 메모리에 동시에 유지되어야 한다
    - CPU 스케줄링, 작업 스케줄링
  - 시분할 시스템에서 운영체제는 적잘한 응답시간을 보장해야 한다
  - 파일 시스템을 제공해야 한다
  - 디스크 관리 기법, 작업 동기화와 통신 기법을 제공해야 하며 교착 상태에 빠지지 않도록 해야한다
  - 자원을 보호하기 위한 기법을 제공해야 한다
  
1.5 운영체제 연산 
- 트랩 : 오류 혹은 사용자 프로그램의 운영체제 서비스 수행 요청에 의해 유발되는 소프트웨어에 의해 생성된 인터럽트
1) 이중 연산 모드 
- 운영체제를 위해 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다
- 사용자 응용을 위해 실행 시 사용자 모드, 운용체제로부터 서비스 요청을 하면 사용자에서 커널 모드로 전환
- 이중 모드는 잘못된 사용자로부터 운영체제를, 잘못된 사용자 서로를 보호하는 방법을 제공함

  ![ex_screenshot](/res/os1.jpg)
  
  - 시스템 부트 시 커널 모드에서 시작
  - 운영체제가 적재되고 사용자 모드에서 프로세스 시작
  - 트랩, 인터럽트 발생마다 사용자에서 커널모드로 전환 
  - 운영체제가 컴퓨터 제어를 얻을 때마다 커널모드에 있게됨
  - 특권 명령은 커널 모드에서만 수행되도록 하며 사용자 모드에서 수행 시 불법적 명령으로 간주해 운영체제로 트랩을 건다
  
2) 타이머 
- 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장
- 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패해 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지해야한다
- 가변 타이머는 고정률의 클락과 계수기로 구현
  - 계수기가 0이 될 때 인터럽트 발생
- 타이머가 인터럽트 발생하면 제어는 운영체제로 넘어가며 타이머 값을 변경 명령은 특권 명령
  - 사용자 프로그램이 오래 실행되는 것을 방지하기 위해 사용할 수 있음
  
1.6 프로세스 관리
- 프로세스는 자신의 일을 수행하기 위해 CPU 시간, 메모리, 파일, 입출력 장치를 포한한 여러 자원을 필요로 함
- 한 프로세스는 한 시스템 내의 작업의 단위
- 운영체제는 다음과 같은 활동에 대한 책임을 진다
  - CPU에 프로세스와 스레드 스케줄
  - 사용자 프로세스와 시스템 프로세스의 생성과 제거
  - 프로세스의 일시 중지와 재수행
  - 프로세스 동기화를 위한 기법 제공
  - 프로세스 통신을 위한 기법 제공
1.7 메모리 관리 
- 주 메모리는 CPU와 입출력 장치에 의해 공유되는 빠른 접근이 가능한 데이터 저장소
- 주 메모리는 CPU가 직접 주소 지정할 수 있고, 직접 접근이 가능한 유일한 대량 메모리
- 프로그램 수행을 위해 반드시 절대 주소로 매핑되고 메모리에 적재되어야 한다
- CPU 이용률과 사용자에 대한 응답속도를 개선하기 위해 메모리에 여러 개의 프로그램을 유지해야 하며 이를 위한 메모리 관리 기법이 필요
- 운영체제는 다음과 같은 일을 담당
  - 메모리의 어느 부분이 사용되고 누구에 의해 사용되는지 추적해야 한다
  - 어떤 프로세스들을 메모리에 적재하고 제거할 것인지 결정
  - 필요에 따라 메모리 공간을 할당하고 회수해야한다
1.8 저장장치 관리 
- 파일 시스템 관리 
  - 파일의 생성 및 제거
  - 디렉토리 생성 및 제거
  - 파일과 디렉토리 조작을 위한 프리미티브 제공
  - 파일을 보조 저장 장치로 매핑
  - 안정적 저장 매체에 파일 백업
- 대용량 저장 장치 관리 
  - 자유 공간의 관리 
  - 저장 장소 할당 
  - 디스크 스케줄링
  
### 시스템 구조
1) 운영체제 서비스 
- 사용자에게 도움을 주는 목적

  ![ex_screenshot](/res/os2.png)  
  
  - 사용자 인터페이스 : 명령어 라인 인터페이스 / 그래피컬 사용자 인터페이스
  - 프로그램 수행 : 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야함
  - 입출력 연산
  - 파일 시스템 조작 
  - 통신 : 공유 모메리, 메시지 전달 기법 등
  - 오류 탐지 : 각 유형 오류에 대해 적당한 조치를 취해야 함
- 시스템 자체의 효율적 동작을 보장하기 위한 운영체제 기능
  - 자원 할당 
    - 다수의 사용자, 작업들이 동시 수행 시, 각각에 자원을 할당해 주어야함
  - 회계
    - 사용자가 어떤 종류의 컴퓨터 자원을 많이 사용하는지 추적할 수 있어야함
  - 보호와  보안
2) 사용자 운영체제 인터페이스
2.1 명령 해석기
- 사용자가 지정한 명령을 가져와 수행하는 것이 주 기능
- 구현 방식 중 하나는 명령 해석기 자체가 명령을 실행할 코드를 갖고 있는 경우
  - 명령 해석기가 자신의 코드의 한 부분을 분기하고 코드 부분이 매개 변수를 설정하고 적절 시스템을 호출 -> 명령의 수가 명령 해석기 크기를 결정
- 다른 방법은 시그템 프로그램에 의해 대부분의 명령을 구현하는 방법
3) 시스템 호출
- 시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공
- API : 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함해 응용 프로그래머가 사용 가능한 함수의 집합을 명시
  - 프로그램의 호환성에 따라 실제 시스템 호출 보다 API를 선호하는 편
- 프로그래밍 언어들을 위한 실행시간 지원 시스템은 운영체제가 제공하는 시스템 호출에 대한 연결로서 동작하는 시스템 호출 인터페이스를 제공
  - API 함수의 호출을 가로채 필요 운영체제 시스템 호출을 부른다
- 통상 시스템 호출은 번호가 할당되고 번호에 따라 색인되는 테이블을 유지한다, 호출 인터페이스는 의도 시스템 호출을 부르고 시스템 호출의 상태와 반환 값을 돌려준다
- 호출자는 단지 API를 준수하고 시스템 호출의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다
- 운영체제에 매개변수를 전달하기 위한 방법
- 매개변수를 레지스터 내에 전달하는 방법
- 레지스터보다 매개변수가 많은 경우 매개변수는 메모리 내 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달

  ![ex_screenshot](/res/os3.png)  
  
  ![ex_screenshot](/res/os4.png)  
  
4) 시스템 호출 유형
- 프로세스 제어
  - 끝내기(end), 중지(abort)
  - 적재(load), 수행(execute)
  - 프로세스 생성 및 종료
  - 프로세스 속성 획득, 프로세스 속성 설정
  - 시간을 기다림
  - 사건 기다림(wait event), 사건 알림(signal event)
  - 메모리 할당 및 자유화
- 파일 조작
  - 파일 생성(create file), 파일 삭제(delete file)
  - 열기, 닫기
  - 읽기, 쓰기, 위치 변경
  - 파일 속성 획득 및 설정
- 장치 관리
  - 장치를 요구, 장치를 방출
  - 읽기, 쓰기, 위치 변경
  - 장치 속성 획득, 장치 속성 설정
  - 장치의 논리적 부착 및 분리
- 정보 유지
  - 시간과 날짜의 설정과 획득
  - 시스템 데이터의 설정과 획득
  - 프로세스, 파일, 장치 속성의 획득
  - 프로세스, 파일, 장치 속성의 설정
- 통신
  - 통신 연결의 생성, 제거
  - 메시지 송신, 수신
  - 상태 정보 전달
  - 원격 장치의 부착 및 분리
  
6) 운영체제 설계 및 구현
6.1 설계 목표
- 시스템 설계 시 문제점은 시스템 목표와 명세를 정의하는 일 
- 사용자 목적과 시스템 목적으로 나눔
- 사용자들이 시스템에 기대하는 특징 
  - 사용하기 쉽고 편리하며, 배우기 쉽고 믿을수 있고 안전, 신속 해야한다.
  - 즉, 운영체는 설계, 구현, 유지보수가 쉬어야하며 적응성, 신뢰성, 무오류, 효율성을 가져야 한다
6.2 기법과 정책
- 기법으로부터 정책을 분리하는 것이 중요 원칙
- 기법 : 어떤 일을 어떻게 할 것인가 결정하는 것
- 정책 : 무엇을 할 것인가를 결정하는 것
- 정책과 기법의 분리는 융통성을 위해 중요함
  - 정책은 장소가 바뀌거나 시간 흐름에 따라 변경될 수 있다
- 기법이 정책으로부터 적절히 분리되면 입출력 중심 프로그램이 CPU 중심 프로그램보다 높은 우선순위를 가지도록 하는 정책을 지원하거나 반대 정책을 지원할 수 있다
- 정책 결정은 모든 자원 할당 문제이 있어 중요하다
  - 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야한다
  - 무엇이 아니라 어떻게 일때마다, 반드시 결정되어야 하는 것은 기법
  
7) 운영체제 구조
7.1 간단한 구조 
- MS-DOS는 인터페이스와 기능 계층이 잘 분리되어 있지 않다. 사용자 프로그램이 고장 나면 시스템 전체가 고장나게 된다
- UNIX는 커널과 시스템 프로그램으로 구성되어 있고 커널은 시스템 호출을 통해 파일 시스템, CPU 스케줄링, 메모리 관리, 다른 운영체제 기능을 제공

 ![ex_screenshot](/res/os5.png) 
 
 ![ex_screenshot](/res/os6.png) 
 
7.2 계층적 접근
- 운영체제 스템은 여러 계층으로 구분
  - 최하위 계층 : 하드웨어
  - 최상위 계층 : 사용자 인터페이스
- 운영체제의 층은 데이터와 연산으로 구성된 추상된 객체의 구현이다
- 모듈화를 통해 각 계층은 바로 아래 계층에서 제공하는 기능과 서비스만을 사용
  - 계층은 하위 계층에 대한 연산을 호출 할 수 있다
- 장점 
  - 구축과 디버깅의 단순함
  - 설계와 구현이 단순하다
  - 각 계층은 하위 계층에서 제공하는 연산만을 통해 구현
  - 각 계층은 연산들이 어떻게 구현되는지 알 필요 없음
- 단점
  - 다양한 계층들이 대략적으로 정의
  - 각 계층은 오직 하위 계층들이 제공하는 기능만 사용하기에 주의 깊은 계획이 이요구 된다
  - 다른 유형의 구현 방법보다 효율성이 낮다
7.3 마이크로 커널
- 중요하지 않는 구성 요소를 커널로 부터 제거하고 시스템 및 사용자 수준 프로그램으로 구현해 운영체제를 구성
- 주 기능은 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스 간 통신 제공
  - 커널과 통신은 사용자 모듈 사이에서 메시지 전달을 통해 이루어짐
- 장점
  - 마이크로 커널을 확장하기 쉽다
  - 운영체제를 새로운 구조로 이식하기 쉽다
  - 커널에서 수행되는 코드가 적으므로 안정적이고 안전하다
- 단점 
  - 커널 공간과 통신하기 위한 사용자 공간의 성능 오버헤드 발생

7.4 모듈
- 적재 가능 모듈 : 커널은 핵심 구성요소 집합을 가지고 있고 부팅 때 또는 실행 중 부가 서비스들을 모듈을 통해 링크 한다
- 설계 주안점 : 커널은 핵심 서비스를 제공, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현
- 대부분의 현대 운영체제는 커널 모듈을 구현
  - 객체 지향 접근 사용
  - 각 핵심 컴포넌트는 나뉘어 짐
  - 각 컴포넌트는 정해진 인터페이스를 통해 다른 컴포넌트와 대화
  - 각 컴포넌트는 커널 내에서 필요에 따라 적재 가능
- 모듈화 커널 접근법은 계층 구조 접근법과 유사
  - 모듈화 커널 접근법은 서브시스템들이 서로 정해진 인터페이스를 통해 상호 작용 하도록 요구
  - 각 부분이 정의되고 보호된 인터페이스를 가진다
  - 단, 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층구조보다 유연함
- 중심 모듈은 단지 핵심 기능만 가지고 다른 모듈 적재방법과 어떻게 통신하는지 안다는 점에서 마이크로 커널과 유사
  
  ![ex_screenshot](/res/os7.png) 
  
  ![ex_screenshot](/res/os8.png) 
  
8. 운영체제 디버깅
- 디버깅은 하드웨어와 소프트웨어에서의 시스템 오류를 발견하고 수정하는 행위
- 시스템에서 처리 중 발생하는 병목 현상을 제거해 성능을 향상시키려는 성능 조정도 포함
8.1 장애 분석
- 오류 정보를 로그 파일에 기록하고 프로세스가 사용하던 메모리를 캡처한 코어 덤프를 취하고 차후 분석을 위해 파일로 저장
- 커널 장애는 충돌로 불리며 프로세스 장애와 마찬가지로 오류 정보가 로그파일에 저장되고 메모리 상태가 충돌 덤프에 저장
8.2 성능 조정
- 처리 병목 지점을 제거함으로 성능을 향상하려함
  - 병목지점 발견을위해 시스템 성능을 감시할 수 있다
- 운영체제는 시스템 동작 추적 목록 생산
  - 관심 사건은 시간과 중요 매개변수와 함께 파일에 기록
  - 후에 분석 프로그램이 로그 파일을 처리하고 시스템 성능을 결정하고 병목지점, 비효율성을 발견한다
- 추적은 운영체제 동작의 오류를 발견하는 데 도움을 줄 수 있다

### 프로세스
1. 프로세스 개념 
- 프로세스 : 실행 중인 프로그램, 시분할 시스템에서 작업의 단위
- 스택, 데이터 섹션, 힙을 포함한다
1.2 프로세스 상태
  
  ![ex_screenshot](/res/os9.png)
  - 새로운(new) : 프로세스 생성 중
  - 실행(running) :  명령어들이 실행
  - 대기(wating) : 프로세스가 어떤 사건이 일어나길 기다림
  - 준비 완료(ready) : 프로세스가 처리기에 할당되기를 기다림
    - 프로세스 식별자 배정, 메모리 할당, 프로그램 적재, PCB 초기화, 스케줄링 추가
  - 종료(terminated) : 프로세스 실행이 종료
  
  - new -> ready : Job Scheduling
  - ready -> running : CPU Scheduling
1.3 프로세스 제어 블록(PCB)

  ![ex_screenshot](/res/os10.png) 
  
  - 프로세스 상태 : 상태는 new, ready, running, wating, halted 상태 등이 있다.
  - 프로그램 카운터 : 다음 실행할 명령어 주소를 가리킴
  - CPU 레지스터들 : 컴퓨터 구조에 따라 다양한 수와 타입을 가짐
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보 포함
  - CPU-스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터, 다른 스케줄 매개변수들을 포함
  - 메모리 관리 정보 : OS에 의해 사용되는 메모리 시스템에 따라 기준 레지스터, 한계 레지스터 값, OS가 사용하는 메모리 시스템에 따라 페이지 테이블 or 세그먼트 테이블과 같은 정보 포함
  - 회계 정보 : CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 or 프로세스 번호 등을 포함
  - 입출력 상태 정보 : 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함

  ![ex_screenshot](/res/os11.png) 

2. 프로세스 스케줄링
- 다중 프로그래밍의 목적 : CPU 이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다
- 시분할 목적 : 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU를 빈번히 교체하는 것
- 프로세스 스케줄러는 CPU에서 실행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택
2.1 스케줄링 큐

  ![ex_screenshot](/res/os12.png) 
- 프로세스가 시스템에 들어오면 잡 큐(시스템 안의 모든 프로세스로 구성)에 놓여진다
- 준비 완료 상태에서 실행 대기하는 프로세스들은 준비 완료 큐라는 리스트 상에 유지된다
  - 큐의 헤더는 리스트의 첫번째와 마지막 PCB를 가리키는 포인터 포함
  - 각 PCB는 준비 완료 큐에 있는 다음 프로세스를 가리키는 포인터 필드를 가짐
- 특정 입출력 장치를 대기하는 프로세스들의 리스트를 장치 큐라고 하며 각 장치는 자신의 장치의 장치 큐를 가짐
- 새로운 프로세스는 처음 준비 완료 큐에 놓이며 실행을 위해 선택 될 때 CPU를 할당 받을 때까지 준비 완료 큐에서 대기한다
- 프로세스에 CPU가 할당되어 실행되면 여러 사건 중 하나가 발생
  - 프로세스가 입출력 요청을 하여 입출력 큐에 넣어질 수 있다
  - 프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다릴 수 있다
    - 대기 상태에서 중비 완료 상태로 전환되고 다시 준비 완료 큐에 넣어지게 된다
  - 프로세스가 인터럽트의 결과에 의해 강제로 CPU로부터 제거되고, 준비 완료 큐에 다시 놓일 수 있다
- 프로세스는 종료될 때까지 주기를 계속하며 종료되면 모든 큐에서 삭제되고 자신의 PCB의 자원을 반납한다

  ![ex_screenshot](/res/os13.png) 
2.2 스케줄러
- 장기 스케줄러(잡 스케줄러, new-> ready) : 프로세스들을 선택하여 실행하기 위해 메모리로 적재
- 단기 스케줄러(CPU 스케줄러, ready -> new) : 실행 준비가 완료되어 있는 프로세스들 중 선택해 CPU를 할당 
- 두 스케줄러의 차이점은 실행 빈도에 있음
  - 단기 스케줄러는 CPU를 위해 반드시 자주 새로운 프로세스를 선택해야한다.
  - 장기 스케줄러는 실행 빈도수가 훨씬 적고 다중 프로그램의 정도를 제어한다 
    - 다중 프로그래밍의 정도가 안정적이면 평균 프로세스 생성률이 시스템을 떠나는 평균 프로세스 이탈률과 반드시 동일해야함
- 입출력 중심 프로세스 : 연산보다 입출력 실행에 더 많은 시간을 소요하는 프로세스
- CPU 중심 프로세스 : 입출력 중심 프로세스보다 연산에 시간을 더 소요하여, 입출력 요청을 드물게 발생시키는 프로세스
- 장기 스케줄러는 입출력 중심과 CPU 중심 프로세스들의 적절한 프로세스 혼합을 선택하는 것이 중요

- 중기 스케줄러 : 메모리에서 프로세스들을 제거함으로써 다중 프로그래밍 정도를 완화하는 것이 핵심 아이디어 

  ![ex_screenshot](/res/os14.png) 
  - 차후 다시 프로세스를 메모리로 불러와 중단 시점에서부터 실행 재개 -> swapping
  - 스와핑은 프로세스 혼합 상태를 개선하기 위해 필요하기도 하며, 메모리 요구에 대한 변화가 가용 메모리에 비해 너무 많은 요규를 수용하여, 메모리를 자유화시키기 위해 필요하기도 함

2.3 문맥 교환
- 인터럽트 발생 시 시스템은 인터럽트 처리 후 문맥을 복구할 수 있도록 현재 실행 프로세스의 현재 문맥을 저장할 필요가 있다
- 문맥은 프로세스의 PCB에 표현
- 문맥 교환 : CPU를 다른 프로세스로 교환하려면 이전 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업


