# 운영체제(Operating System)

### 서론
1.1 운영체제가 할일 
1) 사용자 관점 
- PC : 한 사용자가 자원을 독점하도록 설계되었으며 사용자가 수행하는 작업을 최대화하는 것이 목적, 사용의 용이성을 위해 설계
- 대형, 미니 컴퓨터 : 자원을 공유하며 정보 교환 가능, 자원 이용을 극대화하도록 설계하며 각 개인은 자신의 정당 몫만 사용 가능
- 워크스테이션, 서버 : 자신이 맘대로 할 수 있는 전용자원을 갖지만 네트워킹 서버-파일, 프린트 서버를 공유, 개인의 사용 용이성과 자원 이용간 적절한 조화를 이루도록 설계
- 휴대용 컴퓨터 : 개인 사용자들을 위한 독립형 장치
2) 시스템 관점 
- 자원 할당자 : 자원의 관리자로 동작하며 작업을 위해 특정 프로그램과 사용자에게 필요 자원 할당, 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할지 결정해야함
- 제어프로그램 : 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어

1.4 운영체제 구조
- 운영체제의 가장 중요한 면 => 다중 프로그램을 할 수 있는 능력
- 다중 프로그래밍
  - CPU가 수행할 작업을 항상 하나 가지도록 구성함으로 CPU 이용률을 증가한다
  - 작업들은 디시크의 작업 풀 내에 유지된다
  - 작업 풀은 디스크 내의 모든 프로세스로 구성되며 주 메모리의 할당을 기다린다
  - 메모리 내 작업 집합은 작업 풀 내의 작업들의 부분 집합이다
  - 여러 시스템 자원을 효율적으로 이용할 수 있는 환경을 제공하나 사용자를 위해 컴퓨터 시스템과 상호작용을 제공하지 않음
  - 시분할은 다중 프로그래밍의 논리적 확장
- 시분할 시스템
  - 사용자, 시스템 간 직접 통신을 제공하는 대화식 컴퓨터 시스템을 필요로 함
    - 응답시간이 짧아야 하며, 1초 이내 정도
  - 동시에 많은 사용자가 컴퓨터를 공유하도록 한다
  - CPU 스케줄링과 다중 프로그래밍을 사용한다 
    - 각 사용자에게 시분할 되는 작은 부분을 제공하기 위해 
  - 시분할과 다중 프로그래밍 운영체제는 여러 작업이 메모리에 동시에 유지되어야 한다
    - CPU 스케줄링, 작업 스케줄링
  - 시분할 시스템에서 운영체제는 적잘한 응답시간을 보장해야 한다
  - 파일 시스템을 제공해야 한다
  - 디스크 관리 기법, 작업 동기화와 통신 기법을 제공해야 하며 교착 상태에 빠지지 않도록 해야한다
  - 자원을 보호하기 위한 기법을 제공해야 한다
  
1.5 운영체제 연산 
- 트랩 : 오류 혹은 사용자 프로그램의 운영체제 서비스 수행 요청에 의해 유발되는 소프트웨어에 의해 생성된 인터럽트
1) 이중 연산 모드 
- 운영체제를 위해 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다
- 사용자 응용을 위해 실행 시 사용자 모드, 운용체제로부터 서비스 요청을 하면 사용자에서 커널 모드로 전환
- 이중 모드는 잘못된 사용자로부터 운영체제를, 잘못된 사용자 서로를 보호하는 방법을 제공함

  ![ex_screenshot](/res/os1.jpg)
  
  - 시스템 부트 시 커널 모드에서 시작
  - 운영체제가 적재되고 사용자 모드에서 프로세스 시작
  - 트랩, 인터럽트 발생마다 사용자에서 커널모드로 전환 
  - 운영체제가 컴퓨터 제어를 얻을 때마다 커널모드에 있게됨
  - 특권 명령은 커널 모드에서만 수행되도록 하며 사용자 모드에서 수행 시 불법적 명령으로 간주해 운영체제로 트랩을 건다
  
2) 타이머 
- 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장
- 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패해 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지해야한다
- 가변 타이머는 고정률의 클락과 계수기로 구현
  - 계수기가 0이 될 때 인터럽트 발생
- 타이머가 인터럽트 발생하면 제어는 운영체제로 넘어가며 타이머 값을 변경 명령은 특권 명령
  - 사용자 프로그램이 오래 실행되는 것을 방지하기 위해 사용할 수 있음
  
1.6 프로세스 관리
- 프로세스는 자신의 일을 수행하기 위해 CPU 시간, 메모리, 파일, 입출력 장치를 포한한 여러 자원을 필요로 함
- 한 프로세스는 한 시스템 내의 작업의 단위
- 운영체제는 다음과 같은 활동에 대한 책임을 진다
  - CPU에 프로세스와 스레드 스케줄
  - 사용자 프로세스와 시스템 프로세스의 생성과 제거
  - 프로세스의 일시 중지와 재수행
  - 프로세스 동기화를 위한 기법 제공
  - 프로세스 통신을 위한 기법 제공
1.7 메모리 관리 
- 주 메모리는 CPU와 입출력 장치에 의해 공유되는 빠른 접근이 가능한 데이터 저장소
- 주 메모리는 CPU가 직접 주소 지정할 수 있고, 직접 접근이 가능한 유일한 대량 메모리
- 프로그램 수행을 위해 반드시 절대 주소로 매핑되고 메모리에 적재되어야 한다
- CPU 이용률과 사용자에 대한 응답속도를 개선하기 위해 메모리에 여러 개의 프로그램을 유지해야 하며 이를 위한 메모리 관리 기법이 필요
- 운영체제는 다음과 같은 일을 담당
  - 메모리의 어느 부분이 사용되고 누구에 의해 사용되는지 추적해야 한다
  - 어떤 프로세스들을 메모리에 적재하고 제거할 것인지 결정
  - 필요에 따라 메모리 공간을 할당하고 회수해야한다
1.8 저장장치 관리 
- 파일 시스템 관리 
  - 파일의 생성 및 제거
  - 디렉토리 생성 및 제거
  - 파일과 디렉토리 조작을 위한 프리미티브 제공
  - 파일을 보조 저장 장치로 매핑
  - 안정적 저장 매체에 파일 백업
- 대용량 저장 장치 관리 
  - 자유 공간의 관리 
  - 저장 장소 할당 
  - 디스크 스케줄링
  
### 시스템 구조
1) 운영체제 서비스 
- 사용자에게 도움을 주는 목적

  ![ex_screenshot](/res/os2.png)  
  
  - 사용자 인터페이스 : 명령어 라인 인터페이스 / 그래피컬 사용자 인터페이스
  - 프로그램 수행 : 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야함
  - 입출력 연산
  - 파일 시스템 조작 
  - 통신 : 공유 모메리, 메시지 전달 기법 등
  - 오류 탐지 : 각 유형 오류에 대해 적당한 조치를 취해야 함
- 시스템 자체의 효율적 동작을 보장하기 위한 운영체제 기능
  - 자원 할당 
    - 다수의 사용자, 작업들이 동시 수행 시, 각각에 자원을 할당해 주어야함
  - 회계
    - 사용자가 어떤 종류의 컴퓨터 자원을 많이 사용하는지 추적할 수 있어야함
  - 보호와  보안
2) 사용자 운영체제 인터페이스
2.1 명령 해석기
- 사용자가 지정한 명령을 가져와 수행하는 것이 주 기능
- 구현 방식 중 하나는 명령 해석기 자체가 명령을 실행할 코드를 갖고 있는 경우
  - 명령 해석기가 자신의 코드의 한 부분을 분기하고 코드 부분이 매개 변수를 설정하고 적절 시스템을 호출 -> 명령의 수가 명령 해석기 크기를 결정
- 다른 방법은 시그템 프로그램에 의해 대부분의 명령을 구현하는 방법
3) 시스템 호출
- 시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공
- API : 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함해 응용 프로그래머가 사용 가능한 함수의 집합을 명시
  - 프로그램의 호환성에 따라 실제 시스템 호출 보다 API를 선호하는 편
- 프로그래밍 언어들을 위한 실행시간 지원 시스템은 운영체제가 제공하는 시스템 호출에 대한 연결로서 동작하는 시스템 호출 인터페이스를 제공
  - API 함수의 호출을 가로채 필요 운영체제 시스템 호출을 부른다
- 통상 시스템 호출은 번호가 할당되고 번호에 따라 색인되는 테이블을 유지한다, 호출 인터페이스는 의도 시스템 호출을 부르고 시스템 호출의 상태와 반환 값을 돌려준다
- 호출자는 단지 API를 준수하고 시스템 호출의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다
- 운영체제에 매개변수를 전달하기 위한 방법
- 매개변수를 레지스터 내에 전달하는 방법
- 레지스터보다 매개변수가 많은 경우 매개변수는 메모리 내 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달

  ![ex_screenshot](/res/os3.png)  
  
  ![ex_screenshot](/res/os4.png)  
  
4) 시스템 호출 유형
- 프로세스 제어
  - 끝내기(end), 중지(abort)
  - 적재(load), 수행(execute)
  - 프로세스 생성 및 종료
  - 프로세스 속성 획득, 프로세스 속성 설정
  - 시간을 기다림
  - 사건 기다림(wait event), 사건 알림(signal event)
  - 메모리 할당 및 자유화
- 파일 조작
  - 파일 생성(create file), 파일 삭제(delete file)
  - 열기, 닫기
  - 읽기, 쓰기, 위치 변경
  - 파일 속성 획득 및 설정
- 장치 관리
  - 장치를 요구, 장치를 방출
  - 읽기, 쓰기, 위치 변경
  - 장치 속성 획득, 장치 속성 설정
  - 장치의 논리적 부착 및 분리
- 정보 유지
  - 시간과 날짜의 설정과 획득
  - 시스템 데이터의 설정과 획득
  - 프로세스, 파일, 장치 속성의 획득
  - 프로세스, 파일, 장치 속성의 설정
- 통신
  - 통신 연결의 생성, 제거
  - 메시지 송신, 수신
  - 상태 정보 전달
  - 원격 장치의 부착 및 분리
  
6) 운영체제 설계 및 구현
6.1 설계 목표
- 시스템 설계 시 문제점은 시스템 목표와 명세를 정의하는 일 
- 사용자 목적과 시스템 목적으로 나눔
- 사용자들이 시스템에 기대하는 특징 
  - 사용하기 쉽고 편리하며, 배우기 쉽고 믿을수 있고 안전, 신속 해야한다.
  - 즉, 운영체는 설계, 구현, 유지보수가 쉬어야하며 적응성, 신뢰성, 무오류, 효율성을 가져야 한다
6.2 기법과 정책
- 기법으로부터 정책을 분리하는 것이 중요 원칙
- 기법 : 어떤 일을 어떻게 할 것인가 결정하는 것
- 정책 : 무엇을 할 것인가를 결정하는 것
- 정책과 기법의 분리는 융통성을 위해 중요함
  - 정책은 장소가 바뀌거나 시간 흐름에 따라 변경될 수 있다
- 기법이 정책으로부터 적절히 분리되면 입출력 중심 프로그램이 CPU 중심 프로그램보다 높은 우선순위를 가지도록 하는 정책을 지원하거나 반대 정책을 지원할 수 있다
- 정책 결정은 모든 자원 할당 문제이 있어 중요하다
  - 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야한다
  - 무엇이 아니라 어떻게 일때마다, 반드시 결정되어야 하는 것은 기법
  
7) 운영체제 구조
7.1 간단한 구조 
- MS-DOS는 인터페이스와 기능 계층이 잘 분리되어 있지 않다. 사용자 프로그램이 고장 나면 시스템 전체가 고장나게 된다
- UNIX는 커널과 시스템 프로그램으로 구성되어 있고 커널은 시스템 호출을 통해 파일 시스템, CPU 스케줄링, 메모리 관리, 다른 운영체제 기능을 제공

 ![ex_screenshot](/res/os5.png) 
 
 ![ex_screenshot](/res/os6.png) 
 
7.2 계층적 접근
- 운영체제 스템은 여러 계층으로 구분
  - 최하위 계층 : 하드웨어
  - 최상위 계층 : 사용자 인터페이스
- 운영체제의 층은 데이터와 연산으로 구성된 추상된 객체의 구현이다
- 모듈화를 통해 각 계층은 바로 아래 계층에서 제공하는 기능과 서비스만을 사용
  - 계층은 하위 계층에 대한 연산을 호출 할 수 있다
- 장점 
  - 구축과 디버깅의 단순함
  - 설계와 구현이 단순하다
  - 각 계층은 하위 계층에서 제공하는 연산만을 통해 구현
  - 각 계층은 연산들이 어떻게 구현되는지 알 필요 없음
- 단점
  - 다양한 계층들이 대략적으로 정의
  - 각 계층은 오직 하위 계층들이 제공하는 기능만 사용하기에 주의 깊은 계획이 이요구 된다
  - 다른 유형의 구현 방법보다 효율성이 낮다
7.3 마이크로 커널
- 중요하지 않는 구성 요소를 커널로 부터 제거하고 시스템 및 사용자 수준 프로그램으로 구현해 운영체제를 구성
- 주 기능은 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스 간 통신 제공
  - 커널과 통신은 사용자 모듈 사이에서 메시지 전달을 통해 이루어짐
- 장점
  - 마이크로 커널을 확장하기 쉽다
  - 운영체제를 새로운 구조로 이식하기 쉽다
  - 커널에서 수행되는 코드가 적으므로 안정적이고 안전하다
- 단점 
  - 커널 공간과 통신하기 위한 사용자 공간의 성능 오버헤드 발생

7.4 모듈
- 적재 가능 모듈 : 커널은 핵심 구성요소 집합을 가지고 있고 부팅 때 또는 실행 중 부가 서비스들을 모듈을 통해 링크 한다
- 설계 주안점 : 커널은 핵심 서비스를 제공, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현
- 대부분의 현대 운영체제는 커널 모듈을 구현
  - 객체 지향 접근 사용
  - 각 핵심 컴포넌트는 나뉘어 짐
  - 각 컴포넌트는 정해진 인터페이스를 통해 다른 컴포넌트와 대화
  - 각 컴포넌트는 커널 내에서 필요에 따라 적재 가능
- 모듈화 커널 접근법은 계층 구조 접근법과 유사
  - 모듈화 커널 접근법은 서브시스템들이 서로 정해진 인터페이스를 통해 상호 작용 하도록 요구
  - 각 부분이 정의되고 보호된 인터페이스를 가진다
  - 단, 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층구조보다 유연함
- 중심 모듈은 단지 핵심 기능만 가지고 다른 모듈 적재방법과 어떻게 통신하는지 안다는 점에서 마이크로 커널과 유사
  
  ![ex_screenshot](/res/os7.png) 
  
  ![ex_screenshot](/res/os8.png) 
  
8. 운영체제 디버깅
- 디버깅은 하드웨어와 소프트웨어에서의 시스템 오류를 발견하고 수정하는 행위
- 시스템에서 처리 중 발생하는 병목 현상을 제거해 성능을 향상시키려는 성능 조정도 포함
8.1 장애 분석
- 오류 정보를 로그 파일에 기록하고 프로세스가 사용하던 메모리를 캡처한 코어 덤프를 취하고 차후 분석을 위해 파일로 저장
- 커널 장애는 충돌로 불리며 프로세스 장애와 마찬가지로 오류 정보가 로그파일에 저장되고 메모리 상태가 충돌 덤프에 저장
8.2 성능 조정
- 처리 병목 지점을 제거함으로 성능을 향상하려함
  - 병목지점 발견을위해 시스템 성능을 감시할 수 있다
- 운영체제는 시스템 동작 추적 목록 생산
  - 관심 사건은 시간과 중요 매개변수와 함께 파일에 기록
  - 후에 분석 프로그램이 로그 파일을 처리하고 시스템 성능을 결정하고 병목지점, 비효율성을 발견한다
- 추적은 운영체제 동작의 오류를 발견하는 데 도움을 줄 수 있다

### 프로세스
1. 프로세스 개념 
- 프로세스 : 실행 중인 프로그램, 시분할 시스템에서 작업의 단위
- 스택, 데이터 섹션, 힙을 포함한다
1.2 프로세스 상태
  
  ![ex_screenshot](/res/os9.png)
  - 새로운(new) : 프로세스 생성 중
  - 실행(running) :  명령어들이 실행
  - 대기(wating) : 프로세스가 어떤 사건이 일어나길 기다림
  - 준비 완료(ready) : 프로세스가 처리기에 할당되기를 기다림
    - 프로세스 식별자 배정, 메모리 할당, 프로그램 적재, PCB 초기화, 스케줄링 추가
  - 종료(terminated) : 프로세스 실행이 종료
  
  - new -> ready : Job Scheduling
  - ready -> running : CPU Scheduling
1.3 프로세스 제어 블록(PCB)

  ![ex_screenshot](/res/os10.png) 
  
  - 프로세스 상태 : 상태는 new, ready, running, wating, halted 상태 등이 있다.
  - 프로그램 카운터 : 다음 실행할 명령어 주소를 가리킴
  - CPU 레지스터들 : 컴퓨터 구조에 따라 다양한 수와 타입을 가짐
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보 포함
  - CPU-스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터, 다른 스케줄 매개변수들을 포함
  - 메모리 관리 정보 : OS에 의해 사용되는 메모리 시스템에 따라 기준 레지스터, 한계 레지스터 값, OS가 사용하는 메모리 시스템에 따라 페이지 테이블 or 세그먼트 테이블과 같은 정보 포함
  - 회계 정보 : CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 or 프로세스 번호 등을 포함
  - 입출력 상태 정보 : 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함

  ![ex_screenshot](/res/os11.png) 

2. 프로세스 스케줄링
- 다중 프로그래밍의 목적 : CPU 이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다
- 시분할 목적 : 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU를 빈번히 교체하는 것
- 프로세스 스케줄러는 CPU에서 실행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택
2.1 스케줄링 큐

  ![ex_screenshot](/res/os12.png) 
- 프로세스가 시스템에 들어오면 잡 큐(시스템 안의 모든 프로세스로 구성)에 놓여진다
- 준비 완료 상태에서 실행 대기하는 프로세스들은 준비 완료 큐라는 리스트 상에 유지된다
  - 큐의 헤더는 리스트의 첫번째와 마지막 PCB를 가리키는 포인터 포함
  - 각 PCB는 준비 완료 큐에 있는 다음 프로세스를 가리키는 포인터 필드를 가짐
- 특정 입출력 장치를 대기하는 프로세스들의 리스트를 장치 큐라고 하며 각 장치는 자신의 장치의 장치 큐를 가짐
- 새로운 프로세스는 처음 준비 완료 큐에 놓이며 실행을 위해 선택 될 때 CPU를 할당 받을 때까지 준비 완료 큐에서 대기한다
- 프로세스에 CPU가 할당되어 실행되면 여러 사건 중 하나가 발생
  - 프로세스가 입출력 요청을 하여 입출력 큐에 넣어질 수 있다
  - 프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다릴 수 있다
    - 대기 상태에서 중비 완료 상태로 전환되고 다시 준비 완료 큐에 넣어지게 된다
  - 프로세스가 인터럽트의 결과에 의해 강제로 CPU로부터 제거되고, 준비 완료 큐에 다시 놓일 수 있다
- 프로세스는 종료될 때까지 주기를 계속하며 종료되면 모든 큐에서 삭제되고 자신의 PCB의 자원을 반납한다

  ![ex_screenshot](/res/os13.png) 
2.2 스케줄러
- 장기 스케줄러(잡 스케줄러, new-> ready) : 프로세스들을 선택하여 실행하기 위해 메모리로 적재
- 단기 스케줄러(CPU 스케줄러, ready -> new) : 실행 준비가 완료되어 있는 프로세스들 중 선택해 CPU를 할당 
- 두 스케줄러의 차이점은 실행 빈도에 있음
  - 단기 스케줄러는 CPU를 위해 반드시 자주 새로운 프로세스를 선택해야한다.
  - 장기 스케줄러는 실행 빈도수가 훨씬 적고 다중 프로그램의 정도를 제어한다 
    - 다중 프로그래밍의 정도가 안정적이면 평균 프로세스 생성률이 시스템을 떠나는 평균 프로세스 이탈률과 반드시 동일해야함
- 입출력 중심 프로세스 : 연산보다 입출력 실행에 더 많은 시간을 소요하는 프로세스
- CPU 중심 프로세스 : 입출력 중심 프로세스보다 연산에 시간을 더 소요하여, 입출력 요청을 드물게 발생시키는 프로세스
- 장기 스케줄러는 입출력 중심과 CPU 중심 프로세스들의 적절한 프로세스 혼합을 선택하는 것이 중요

- 중기 스케줄러 : 메모리에서 프로세스들을 제거함으로써 다중 프로그래밍 정도를 완화하는 것이 핵심 아이디어 

  ![ex_screenshot](/res/os14.png) 
  - 차후 다시 프로세스를 메모리로 불러와 중단 시점에서부터 실행 재개 -> swapping
  - 스와핑은 프로세스 혼합 상태를 개선하기 위해 필요하기도 하며, 메모리 요구에 대한 변화가 가용 메모리에 비해 너무 많은 요규를 수용하여, 메모리를 자유화시키기 위해 필요하기도 함

2.3 문맥 교환
- 인터럽트 발생 시 시스템은 인터럽트 처리 후 문맥을 복구할 수 있도록 현재 실행 프로세스의 현재 문맥을 저장할 필요가 있다
- 문맥은 프로세스의 PCB에 표현
- 문맥 교환 : CPU를 다른 프로세스로 교환하려면 이전 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업
- 문맥 교환 발생 시, 커널은 과거 프로세스의 문맥을 PCB에 저장, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구
- 문맥 교환 시간은 순수한 오버헤드
- 운영체제가 복잡할 수록 문맥교환 시 해야할 작업 양이 많다. 

3. 프로세스에 대한 연산
3.1 프로세스 생성
- 생성하는 프로세스를 부모 프로세스, 새로운 프로세스는 자식 프로세스
- 유일한 프로세스 식별자(pid)를 사용해 구분, 각 프로세스에 고유한 값을 가지도록 할당
- pid가 1인 init 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행
- 프로세스가 자식 프로세스를 생성할 때, 자식 프로세스는 자신의 임무를 달성하기 위해 어떤 자원(CPU 시간, 메모리, 파일, 입출력 장치)이 필요
- 자식 프로세스는 자원을 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한
- 부모 프로세스는 자원을 분할해 자식 프로세스에 나누어 주거나 메모리나 파일 같은 몇몇 자원은 자식 프로세스들이 같이 사용할 수 있다
- 부모 프로세스 자원의 일부분만 사용하도록 자식 프로세스가 쓸 수 있게 제한하며 자식 프로세스들을 많이 생성해 시스템을 과부하 상태로 만드는 프로세스를 방지 할 수 있다

- 프로세스가 새로운 프로세스 생성 시
  - 부모는 자식과 병행하게 실행을 계속한다
  - 부모는 일부 OR 모든 자식이 실행을 종료할 때까지 기다린다
- 새로운 프로세스들의 주소 공간 측면
  - 자식 프로세스는 부모 프로세스의 복사본(부모와 같은 프로그램과 데이터를 가짐)
  - 자식 프로세스가 자신에게 적재될 새로운 프로그램을 갖음
- UNIX 
  - 새로운 프로세스는 fork()로 호출, 원래 프로세스의 주소 공간의 복사본으로 구성
  - 부모 프로세스가 쉽게 자식 프로세스와 통신할 수 있게 한다
  - fork()의 복귀 코드가 서로 다르다
    - 자식 프로세스의 식별자가 부모로 복귀되지만, 새로운 프로세스는 '0'이 복귀된다
  - exec()는 자식의 메모리 공간을 새로운 프로그램으로 교체한다 (동시 실행)
  - 부모는 더 많은 자식을 생성할 수 있고, 자식이 실행하는 동안 할일 없으면, 자식이 종료될 때까지 준비 완료 큐에서 자신을 제거하기 위해 wait() 를 호출한다
  - 자식 프로세스에게 보이는 pid값은 0이고 부모 프로세스에게 보이는 pid값은 0보다 큰 정수값
  - 자식 프로세스는 열린 파일과 같은 자원, 특권, 스케줄링 속성을 부모 프로세스로부터 상속받고 부모는 wait()로 자식 프로세스가 끝나기 기다림
  - 부모와 자식은 같은 코드를 실행하는 병행 실행 프로세스
  - 자식은 부모의 복사본이기에 각 프로세스는 모든 데이터에 대해 자신만의 복사본을 가짐
3.2 프로세스 종료
- exit 시스템 호출을 사용해 운영체제에게 자신의 삭제를 요청하면 종료한다
- 프로세스는 자신의 부모 프로세스에게 상태값을 반환할 수 있고, 물리 메모리, 파일, 입출력 버퍼 등 프로세스의 모든 자원이 운영체제로 반환
- 한 프로세스는 적당 시스템 호출을 통해 다른 프로세스의 종료를 유발할 수 있다(부모만 호출 가능)
  - 부모가 자식의 pid를 알아야 종료시킬 수 있다
  - 새로운 프로세스 생성 시, 새로운 프로세스의 신원이 부모에게 전달된다
- 부모가 자식의 실행을 종료하는 경우
  - 자식이 자신에게 할당된 자원을 초과하여 사용할 때, 부모가 자식들의 상태를 검사할 수 있는 방편이 주어져야함
  - 자식에게 할당된 태스크가 더 이상 필요 없을 때
  - 부모가 exit 하는데, 운영체제는 부모가 exit한 후 자식이 실행을 계속하는 것을 허용하지 않는 경우
- 부모는 wait를 통해 자식 프로세스가 종료할 때를 기다리며 wait는 부모가 자식으이 종료 상태를 얻어낼 수 있도록 하나의 인자를 전달 받음
- wait는 부모가 어느 자식이 종료되었는지 구별할 수 있도록 종료된 자식 프로세스 식별자를 반환
- 좀비 프로세스 : 종료되었지만 부모 프로세스가 아직 wait를 호출하지 않은 프로세스
- 고아 프로세스 : 부모 프로세스가 wait를 호출하는 대신 종료할 때 자식 프로세스 

4. 프로세스간 통신
- 프로세스 협력을 허용하는 환경을 제공하는 이유
  - 정보 공유
  - 계산 가속화 : 병렬 실행
  - 모듈성
  - 편의성
- 협력적 프로세스들은 데이터와 정보를 교환할 수 있는 프로세스간 통신 기법을 필요로 함

 ![ex_screenshot](/res/os17.png) 
 
- 공유 메모리 모델
  - 협력 프로세스들에 의해 공유되는 메모리 영역이 구축
  - 프로세스들은 영역에서 데이터를 읽고 쓰고 함으로 정보를 교환
  - 공유 메모리 영역을 구축할 경우에만 시스템 호출이 필요
  - 메시지 전달 모델 보다 빠르다
  - 캐시 일관성 문제로 인해 성능 저하가 발생할 수 있다
- 메시지 전달 모델 
  - 협력 프로세스들 사이 교환되는 메시지를 통해 통신한다
  - 충돌을 회피할 필요가 없기에 적은 양의 데이터 교환을 하는데 유용
  - 통상 시스템 호출을 사용해 구현되므로 부가적 시간 소비 작업들이 필요로 하기에 공유 메모리 모델 보다 느리다
  - 많은 처리 코어를 가진시스템 사엥서는 메시지 전달이 더 나은 성능을 보인다
- 시스템 처리 코어의 수가 증가할수록 IPC로 메시지 전달이 선호될 수 있다

4.1 공유 메모리 시스템
- 공유 메모리 영역을 구축해야한다
- 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치 
- 통신 시 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야함
4.2 메시지 전달 시스템
- 동일 주소 공간을 공유하지 않고도 프로세스들이 통신하고, 동작을 동기화할 수 있도록 허용하는 기법을 제공
- 프로세스들이 네트워크에 의해 연결된 분산 환경에서 유용하다
- 프로세스 P와 Q가 통신을 원하면 반드시 서로 메시지를 보내고 받아야하며 통신 연결이 설정되어야 한다
- 통신 연결 
  - 직접 통신하에서 통신을 원하는 프로세스는 통신의 수신, 송신자의 이름을 명시해야한다
    - send(P, message) : 프로세스 P에게 메시지를 전송
    - reveive(Q, message) : 프로세스 Q로부터 메시지를 수신
    - 통신을 원하는 각 프로세스의 쌍들 사이 연결이 자동적으로 구축되며 서로 상대방의 신원만 알면 된다
    - 연결은 정확히 두 프로세스들 사이에만 연관
    - 각 쌍 사이에는 정확히 하나의 연결이 존재해야 한다
  - 주소 지정 시 비대칭을 사용하는 경우, 송신자만 수신자 이름을 지명한다
    - send(P, message) : 메시지를 프로세스 P에 전송
    - reveive(id, message) : 임의 프로세스로부터 메시지 수신, 변수 id는 통신을 발생시킨 프로세스의 이름
  -> 두 방법은 결과로 얻어지는 프로세스 정의의 제한된 모듈성이 있는 단점이 있다 
  
  - 간접 통신에서 메시지들은 메일박스 or 포트로 송신되고 수신된다
  - 메일박스는 프로세스들에 이해 메시지들이 넣어지고 제거될 수 있는 객체
  - 각 메일박스는 고유 id를 갖는다 
    - send(A, message) : 메시지를 메일박스 A로 송신
    - receive(A, message) : 메시지를 메일박스 A로부터 수신
    - 한쌍의 프로세스들 사이 연결은 프로세스가 공유 메일박스를 가질 때만 구축된다
    - 연결은 두 개 이상의 프로세스들과 연관될 수 있다
    - 통신하는 각 프로세스들 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다 
  - 메일박스는 한 프로세스 OR 운영체제에 의해 소유될 수 있다
    - 프로세스에 의해 소유될 경우, 소유자와 메일박스 사용자를 구분 할 수 있고 메일 박스를 소유한 프로세스 종료시 메일박스는 사라지며 메일박스로 송신하는 프로세스들은 메일박스가 존재하지 않다는 사실을 통보 받아야 한다
    - 운영체제에 의해 소유한 경우 메일박스는 자체적으로 존재한다 (메일박스 생성, 송수신, 삭제 등을 제공해야함)
  - 메일박스 생성 프로세스는 디폴트로 메일박스의 소유자가 된다 

- 동기화
  - 봉쇄형 보내기 : 송신하는 프로세스는 메시지가 수신 프로세스 OR 메일박스에 의해 수신될 때까지 봉쇄
  - 비봉쇄형 보내기 : 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다
  - 봉쇄형 받기 : 메시지가 이용 가능할 때까지 프로세스 봉쇄
  - 비봉쇄형 받기 : 송신하는 프로세스가 유효한 메시지 또는 NULL을 받음
  - send(), receive()가 모두 봉쇄형일 때, 우리는 송,수신자 간에 랑데부를 갖게된다 
- 버퍼링 
  - 무용량 : 큐의 최대 길이가 0이고, 링크는 자체 안에 대기하는 메시지들을 가질 수 없다 -> 송신자는 수신자가 메시지 수신할 때까지 기다림
  - 유한 용량 : 유한 길이 큐를 가지낟
  - 무한 용량 : 무한한 길이의 큐를 가지고 메시지들은 얼마든지 큐 안에서 대기할 수 있다
6. 클라이언트 서버 환경에서 통신 
6.1 소켓 
- 두 프로세스가 네트워크상에서 통신하려면 양 프로세스 마다 하나씩 소켓이 필요
- 소켓은 IP 주소, 포트 번호 두가지를 접합해 구별
- 클라이언트 프로세스가 연결을 요청하면 호스트 컴퓨터가 포트 번호를 부여
- 두 호스트 사이에 패킷들이 오갈 때 패킷들은 목적지 포트 번호가 지정하는 데 따라 적절한 프로세스로 배달딘다
- 모든 연결은 유일해야하며 모든 연결이 유일한 소켓 쌍으로 구성되는 것을 보장한다 

6.2 원격 프로시저 호출(RPC)
- 메시지 반 통신을 해야한다
- 각 메시지에는 원격지 포트에서 listen 중인 RPC 디먼의 주소가 지정되어 있고 실행되어야 할 함수 식별자, 그 함수에게 전달되어야 할 매개변수가 포함된다
- 네트워크 주소는 하나씩 갖지만 시스템에서 지원되는 여러 서비스를 구별하기 위해 포트를 여러개 가질 수 있다
- 원격 프로세스가 어떤 서비스를 받고자하면 서비스에 대응되는 적절한 포트 주소로 메시지를 보내야함
- RPC는 클라이언트가 원격 호스트 프로시저 호출하는 것을 자기 프로시저 호출 처럼 해준다
- RPC시스템은 클라이언트 쪽에 stub을 제공해 통신하는 데 필요한 자세한 사항들을 숨겨 준다
- 원격 프로시저 마다 다른 stub가 존재한다
- 클라이언트가 원격 프로시저 호출하면 RPC는 대응 stub를 호출하고 원격 프로시저가 필요로한 매개변수를 건네주고 stub가 원격 서버의 포트를 찾고 매개변수를 정돈 한다.
  - 매개 변수 전동 : 프로시저에게 갈 매개변수를 네트워크로 전송하기 위해 적절한  형태로 재구성하는 작업
- stub는 메시지 전달 기법을 사용해 서버에게 메시지를 전송한다.
- 대응 stub가 서버에 존재하여 서버측 stub가 수신후 적절 서버의 프로시저를 호출하고 필요한 경우 반환 값들도 동일 방식으로 되돌려 준다.

- 클라이언트와 서버의 데이터 표현 방식이 다른 경우 RPC 시스템은 기종 중립적인 데이터 표현 방식을 정의한다
  - 클라이언트 측에서 서버에 보내기전 매개변수 정돈 작업의 일환으로 전송 데이터를 XDR 형태로 바꾸어 보냄
  - 수신측에서 XDR을 받으면 매개변수를 풀어 자기 기종의 형태로 데이터 바꾼 후 서버에게로 전잘 
- 호출의 의미
  - 운영체제로 하여금 메시지가 최대 한 번 실행되는 것이 아니라 정확히 한번 처리되도록 보장하게 한다 
    - 응답 메시지 활용
- 클라이언트와 서버간 통신 문제
  - 고정된 포트 주소 형태로 미리 정해 놓는 방법
    - 컴파일 시 RPC에게는 고정된 포트 번호가 주어짐
  - 랑데부 방식에 의해 동적으로 바인딩하는 방법
    - 운영체제는 미리 정해진 고정 RPC 포트를 통해 랑데부용 디먼을 제공
    - 클라이언트가 실행을 원하는 RPC 이름을 담은 메시지를 랑데부 디먼에 보내 RPC 이름에 대응하는 포트 번호가 무엇인지 알려달라 요청
    - 포트 번호가 클라이언트에 반환되고 클라이언트는 포트 번호로 RPC 요청을 계속 보냄

  ![ex_screenshot](/res/os15.png) 
  
  ![ex_screenshot](/res/os16.png) 

6.3 파이프
- 파이프 : 두 프로세스가 통신할 수 있게 하는 전달자로서 동작
- 일반 파이프 : 생산자-소비자 형태로 두 프로세스 간 통신을 허용
  - 생산자는 파이프의 한 종단에 쓰고, 소비자는 다른 종단에서 읽음
  - 한쪽으로만 데이터 전송하며 오직 단반형 통신만 가능
  - 파이프를 생성한 프로세스 이외는 접근 할 수 없다
  - 통상 부모 프로세스가 파이프를 생성하고 fork()로 생성한 자식 프로세스와 통신하기 위해 사용
  - Windows 시스템의 일반 파이프는 익명 파이프라 불린다
  - 동일한 기계 상의 두 프로세스만 통신이 가능!
- 지명 파이프
  - 양방향으로 가능하며 부모-자식 관계도 필요로 하지 않음
  - 지명 파이프가 구축되면 여러 프로세스 들이 통신할 수 있다 
  - UNIX에서 FIFO라 부르며 반이중 전송만이 가능하며, 바이트-단위 통신만 허용
  - Windows는 전이중 통신을 하용하고 두 프로세스는 같은 기계 or 다른 기계 상에 존재할 수 있고, 바이트-단위 or 메시지-단위 데이터 전송 허용

### 스레드 
- 스레드는 CPU 이용의 기본 단위이며 스레드 ID, PC(프로그램 카운터), 레지스터 집합, 스택으로 구성
- 같은 프로세스에 속한 다른 스레드, 코드, 데이터 섹션, 운영체제 자원들을 공유한다
- 단일 스레드와 다중 스레드
  
  ![ex_screenshot](/res/os18.jpg)

  ![ex_screenshot](/res/os16.png)

1.2 장점 
- 응답성 : 사용자에 대한 응답성을 증가시킨다
- 자원 공유 : 프로세스는 공유 메모리와 메시지 전달 기법을 통해 자원을 공유
  - 스레드는 자동적으로 그들이 속한 프로세스의 자원들과 메모리를 공유
  - 코드와 데이터 공유의 이점은 한 응용 프로그램이 같은 주소 공간 내 여러 개의 다른 작업을 하는 스레드를 가질 수 있다는 점
- 경제성 : 자원을 공유하기에 스레드를 생성하고 문맥 교환하는 것이 프로세스를 생성을 위해 자원 할당 하는 것 보다 경제적이다
- 규모 적응성 : 다중 처리기 구조에서 더욱 증가 할 수 있다
  - 다중 처리기 구조에서는 각 스레드가 다른 처리기에서 병렬로 수행될 수 있기 때문

2. 다중코어 프로그래밍
- 코어가 여러 CPU칩 형태를 띠거나 칩 안에 여러 개가 존재한 시스템 (다중코어 OR 다중 처리기 시스템)
- 다중 스레드 프로그래밍은 다중 계산 코어를 더 효율적으로 사용할 수 있고 병행 실행을 더 향상 시킬 수 있는 기법을 제공
- 병행성은 스레드들이 병렬적으로 실행될 수 있다는 것을 의미
- 병렬 : 하나 이상의 태스크를 동시에 수행할 수 있는 시스템
- 병행 : 모든 태스크가 진행하게끔 함으로써 하나 이상의 태스크를 지원 

2.2 병렬 실행의 유형 
- 데이터 병렬 실행 : 동일 데이터의 부분집합을 다수 계산 코어에 분배한 뒤 각 코어에 동일한 연산을 실행하는데 초점을 맞춤
  - 데이터가 코어에 분배되어야함
- 태스크 병렬 실행 : 태스크를 다수의 코어에 분배하고 각 스레드는 고유 연산을 실행
  - 태스크가 분배되어야 함
-> 두 전략을 혼용하여 사용

3. 다중 스레드 모델
3.1 다대일 모델 : 많은 사용자  수준 스레드를 하나의 커널 스레드로 사상
- 사용자 공간 스레드 라이브러리에 의해 스레드 관리가 행해짐 -> 효율적
- 한 스레드가 봉쇄형 시스템 콜을 할 경우 전체가 봉쇄
- 한번에 하나의 스레드만 커널에 접근할 수 있기에 병렬로 실행할 수 없다

3.2 일대일 모델 : 사용자 스레드를 각 하나으 ㅣ커널 스레드로 사상
- 다대일 델보다 더 많은 병렬성을 제공하고 다중 스레드가 병렬로 수행되는 것을 허용
- 사용자 수준 스레드를 생성할 때 커널 스레드를 생성해야하는 단점이 있음
- 커널 스레드를 생성하는 오버헤드가 성능을 저하할 수 있음 -> 시스템에 의해 지원되는 스레드 수 제한

3.3 다대다 모델 : 여러 개의 사용자 수준 스레드를 적은수 혹은 같은 수의 커널 스레드로 멀티플렉스 한다
- 필요한 만큼 사용자 수준 스레드를 생성할 수 있고 상응하는 커널 스레드가 다중 처리기에 의해 병렬로 수행될 수 있다
- 다대다 모델의 변형으로 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것을 허용하는 두 수준 모델이 있다

  ![ex_screenshot](/res/os20.png)
  
  ![ex_screenshot](/res/os21.jpg)
  
4. 스레드 라이브러리
- 프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공
- 구현 방법
  - 커널의 지원 없이 완전히 사용자 공간에서만 라이브러리를 제공하는 것
    - 라이브러리를 모든 코드와 자료구조는 사용자 공간에 존재
    - 함수 호출하는 것은 사용자 공간의 지역 함수를 호출하게 된다는 것을 의미
  - 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하는 것
    - 라이브러리를 위한 코드와 자료구조는 커널 공간에 존재
    - 라이브러리 API 호출은 커널 시스템 호출을 부르는 결과 
  
  - 비동기 스레딩 : 부모가 자식 스레드 생성 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 병행하게 실행
    - 각 스레드는 독립적으로 실행하고 부모 스레드는 자식의 종료를 알 필요 없음
  - 동기 스레딩 : 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다 자신의 실행을 재개하는 방식
    - 포크-조인 전략
    - 부모가 생성한 스레드는 병행하게 실행되지만 부모는 자식들의 작업이 끝날 때 까지 실행을 계속할 수 없음
    - 모든 자식 스레드가 조인한 후에 실행을 재개할 수 있다
    - 상당한 야야의 데이터 공유를 수반한다

4.3 자바 스레드
- 스레드 생성 기법
  - Thread 클래스로부터 파생된 새로운 클래스를 생성하고 Thread 클래스의 run() 메서드를 무효화 하는 것
  - Runnable 인터페이스를 구현하는 클래스를 정의하는 것
    - 스레드 생성은 Thread 클래스의 객체 인스턴스를 생성하고 Runnable 객체의 컨스트럭트를 전달함으로 이루어짐
    - start 메서드가 새로운 스레드를 생성
      - 메모리가 할당되고 JVM 내에 새로운 스레드가 초기화
      - run() 메서드를 호출하면 스레드가 JVM에 의해 수행될 자격을 갖게 한다.
    <pre><code>
      class Sum{
        private int sum;
        public int getSum(){
          return sum;
        }
        public void setSum(int sum){
          this.sum = sum;
        }
      }
      
      class Summation implements Runnable
      {
        private int upper;
        private Sum sumValue;
        public Summation(int upper, Sum sumValue){
          this.upper = upper;
          this.sumValue = sumValue;
        }
        public void run(){
          int sum = 0;
          for(int i =0; i<=upper; i++)
            sum+=i;
          sumValue.setSum(sum);
         }
       }
       
       public class Driver
       {
        public static void main(String[] args){{
          if(args.length>0){
            if(Integer.parseInt(args[0] <0)
              System.out.println(args[0] + " must be >=0.");
            else{
              Sum sumObject = Sum(); // 공유 객체
              int upper = Integer.parseInt(args[0]);
              // 스레드 생성 및 실행
              Thread thrd = new Thread(new Summation(upper, sumObject));
              thrd.start();
              try{
                thrd.join();
                System.out.println("The sum of " + upper+" is " + sumObject.getSum());
              }catch(InterruuptedException e){}
             }
           else
            System.out.println("m of " + upper+" is " + sumObject.getSum());
         }
        }
    </code></pre>

5. 암묵적 스레딩
- 스레딩 생성과 관리 책임을 응용 개발자로부터 컴파일과 실행시간 라이브러리에게 넘겨주는 것
5.1 스레드 풀 : 프로세스를 시작할 때 일정한 수의 스레드를 미리 풀로 만들어 두는 것
- 요청이 들어오면 풀에서 한 스레드에게 할당하고 요청을 다하면 스레드는 다시 풀로 돌아가 작업을 기다림
- 장점
  - 새 스레드를 만들어 주는 것 보다 기존 스레드로 서비스하는 것이 빠름
  - 스레드 개수에 제한을 두며 많은 스레드를 병렬 처리할 수 없는 시스템에 도움이 됨
  - 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크 실행을 다르게 할 수 있음
- 스레드 개수는 CPU 수, 물리 메모리 용량, 동시 요청 클라이언트 개수를 고려해 정해질 수 있고 동적으로 풀의 크기를 바꿔 줄 수도 있다

5.2 OpenMP : C++, C, FORTRAN으로 작성된 API와 컴파일러 디렉티브의 집합
- 공유 메모리 환경에서 병렬 프로그래밍을 할 수 있도록 도움을 주고 병렬로 실행될 수 있는 블록을 찾아 병렬 영역이라 부른다
- 병렬 영역에 컴파일러 디렉티브를 삽입하고 OpenMP 실행시간 라이브러리에 해당 영역을 병렬로 수행하라고 지시
- 병렬화를 위한 디렉티브를 제공할 뿐아니라 개발자가 병렬화 수준을 선택할 수 있게 해줌

5.3 Grand Central Dispatch : Apple의 Max OS X와 iOS 운영체제를 위한 기술로 C, API 및 실행시간 라이브러리 각각 확장해 조합한 기술
- 개발자가 병렬로 실행될 수 있는 영역을 식별할 수 있게 도움을 준다
- C, C++ 언어를 확장한 블록을 식별하고 블록은 독립적으로 실행될 수 있는 작업 단위이다
- ^{ printf("I am a block"); }
- 블록을 디스패치 큐에 넣어 실행될 수 있도록 스케줄 한다
- 직렬과 병행의 두가지 유형의 디스패치 큐를 유힌다
  - 직렬 큐는 넣어진 블록은 FIFO 순서대로 제거되고 각 프로세스는 각자 직렬 큐를 가짐
  - 병행 큐는 FIFO 순으로 제거되지만 여러 블록이 동시에 제거 될 수 있으며 여러 블록이 동시에 병렬로 실행되는 것이 가능

6. 스레드와 관련된 문제들
6.1 Fork() 및 Exec() 시스템 호출
- fork() 모든 스레드를 복사하는 것, fork()를 호출한 스레드만 복사 둘 중 어떠한 것을 사용하는지에 따라 다름
6.2 신호처리
- 신호는 프로세스에게 어떤 사건이 일어났음을 알려주기 위해 사용
- 동기식 or 비동기식으로 전달 될 수 있음
- 신호는 특정 사건이 일어나야 생성된다
- 생성된 신호가 프로세스에게 전달된다
- 신호가 전달되면 반드시 처리되어야 한다
- 동기적 신호는 신호를 발생시킨 연산을 수행한 동일 프로세스에게 전달되고 비동기식 신호는 신호가 실행중인 프로세스 외부로부터 발생되는 것을 말함
- 디폴트 신호 처리기 모든 신호마다 커널이 실행시키는 것이고 신호를 처리하기 위해 호출되는 사용자 정의 처리기에 의해 대체도리 수 있다

6.3 취소
- 스레드 취소는 스레드가 끝나기 전 그것을 강제 종료시키는 작업
- 취소되어야 할 스레드를 목적 스레드라 부른다
- 목적 스레드 취소 방식
  - 비동기식 취소 : 한 스레드가 즉시 목적 스레드를 강제 종료
  - 지연 취소 : 목적 스레드가 주기적으로 자신이 강제 종료되어야 할지 점검, 목적 스레드가 질서정연하게 강제 종료될 수 있는 기회가 만들어짐
- 스레드 취소를 어렵게 만드는 것
  - 할당된 자원
  - 다른 스레드와 공유하는 자료구조를 갱신하는 도중 취소 요청 -> 모든 자원 시스템을 회사하지 못하는 경우도 있음
- 지연 취소는 목적 스레드가 취소 여부를 경정하기 위한 플래그를 검사 한 후 일어나고 자신이 취소되어도 안전하다 판단되는 시점에 취소 여부를 검사할 수 있다.
- 디폴트 취소는 지연 취소이며 취소점에 도달했을 때만 취소 작업이 일어남

6.4 스레드 국지 저장소
- 한 프로세스에 속한 스레드들은 프로세스의 데이터를 모두 공유하지만 상황에 따라 각 스레드가 자기만 액세스할 수 있는 데이터를 가져야할 필요가 있는데 이러한 데이터를 스레드 국지 저장소라함
- TLS은 전체 함수 호출에 걸쳐 보이고 TLS 데이터는 각 스레드의 고유한 정보를 저장한다

6.5 스케줄러 액티베이션
- 다대다 OR 두 수준 모델을 구현하는 많은 시스템들은 사용자, 커널 스레드 사이 중간 자료 구조를 두고 경량 프로세스(LWP)라고 함
- LWP 방식은 응용이 사용자 스레드를 수행하기 위해 스케줄 할 가상 처리기처럼 보인다
- 각 LWP는 하나의 커널 스레드에 부속되었으며 물리 처리기에 스케줄 하는 대상은 커널 스레드이다
- 통상 동시 발생하는 봉쇄형 시스템 호출마다 하나의 LWP가 필요하다

  ![ex_screenshot](/res/os22.png)
  
- 사용자 스레드 라이브러리와 커널 스레드 간 통신 방법 중하나는 스케줄 액티베이션이다
  - 커널은 응용에게 가상 처리기의 집합을 제공하고 으용은 사용자 스레드를 가용한 가상 처리기로 스케줄
  - 커널은 응용에게 특정 사건에 대해 알려줘야하며 이 프로세저를 upcall이라 부름
  - Upcall은 스레드 라이브러리의 upcall 처리기에 의해 처리되고 upcall 처리기는 가상 처리기 상에서 실행되어야 한다
  - upcall 처리기를 일으키는 한 사건은 응용 스레드가 봉쇄하려고 할 때 발생
  - 커널은 스레드가 봉쇄하려는 사실과 스레드의 식별자를 알려주는 upcall을 수행하고 커널은 새로운 가상 처리기를 응용에게 할당
  - 응용은 새로운 가상 처리기 상에서 upcall 처리기를 수행하고 upcall 처리기는 봉쇄 스레드 상태를 저장하고 스레드가 실행 중이던 가상 처리기를 반환
  - upcall 처리기는 새로운 가상 처리기에서 실행 가능한 다른 스레드를 스케줄하고 봉쇄 스레드가 기다리던 사건 발생 시 커널은 이전 봉쇄된 스레드가 실행 가능하다는 사실을 알려주는 다른 upcall을 스레드 라이브러리에게 한다
  - upcall처리기도 가상 처리기가 필요하고 커널은 새로운 가상 처리기를 할당하거나 사용자 스레드 하나를 선점해 처리기에서 upcall 처리기를 실행한다
  - 봉쇄가 풀린 스레드를 실행 가능 상태로 표시후 응용은 가용한 가상 처리가 상에서 다른 실행 가능 스레드 실행
  
### CPU 스케줄링
- 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 함에 있다
- CPU 스케줄링은 운영체제 설계의 핵심
1.2 CPU 스케줄러
- CPU가 유휴 상태가 될 때마다, 운영체제는 준비 완료 큐에 있는 프로세스들 중 하나를 선택해 실행
- 선택 절차는 단기 스케줄러에 의해 수행
- 스케줄러는 실행 준비가 되어 있는 메모리 내 프로세스들 중 선택해 CPU를 할당
1.3 선점 스케줄링
- 4가지 상황에서 CPU 스케줄링 결정이 발생
  - 한 프로세스가 실행 상태에서 대기 상태로 전환될 때
  - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
  - 프로세스가 대기 상태에서 준비 완료 상태로 전환 될 때
  - 프로세스가 종료될 때
- 선점 스케줄링은 데이터가 다수의 프로세스에 의해 공유될 때 경쟁 조건 초래
1.4 디스패처
- 디스패처는 CPU 제어를 단기 스케줄러가 선택한 프로세스에 주는 모듈이며 다음 작업을 포함
  - 문맥 교환 
  - 사용자 모드로 전환
  - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절 위치로 이동하는 일
  - 디스패처는 모든 프로세스의 문맥 교환 시 호출되며, 가능한 최고로 빨리 수행되어야 함
  - 디스패처 하나가 프로세스를 중지하고 다른 프로세스의 수행을 시작하는 데 소요되는 시간 -> 디스패치 지연
  
2. 스케줄링 기준
- CPU 이용률 : 가능한 CPU를 최대한 바쁘게 유지하기를 원함
- 처리량 : CPU가 프로세스 수행시 바쁘면 작업이 진행되고 있는것, 작업량 측정 방법은 단위 시간당 완료된 프로세스 갯수
- 총처리 시간 : 프로세스 실행 동안 소요된 시간 중요!
- 대기 시간 : 스케줄링 알고리즘은 단지 프로세스가 준비 완료 큐에 대기하는 시간의 양에만 영향을 줌
- 응답 시간
- CPU 이용률과 처리량을 최대화하고 총 처리 시간, 대기 시간, 응답 시간을 최소화 하는 것이 바람직

3. 스케줄링 알고리즘
3.1 선입선출 알고리즘(FCFS)
- 선입 선처리 스케줄링에서는 먼저 요청하는 포로세스가 CPU를 먼저 할당 받음
- 프로세스가 준비 완료 큐에 진입하면 프로세스의 프로세스 제어 블록을 큐의 끝에 연결
- CPU가 자유 상태가 되면 준비 완료 큐의 앞부분에 있는 프로세스에 할당
- 평균 대기 시간을 일반적으로 최소가 아니며, 프로세스 CPU 버스트 시간이 크게 변할 경우 평균 대기 시간도 변할 수 ㅣㅇㅆ다
- 모든 다른 프로세스 들이 하나의 긴 프로세스가 CPU를 양도하기 기다리는 것 -> 호위 효과
  - 짧은 프로세스들이 먼저 처리 되도록 허용할 때보다 CPU와 장치 이용률이 저하되는 결과를 낳음
- 한 프로세스가 지나치게 오랜 동안 CPU 점유시 손해가 클 것

3.2 최단 작업 우선 스케줄링
- CPU가 이용가능하면 가장 작은 다음 CPU 버스트를 가진 프로세스에게 할당
- 프로세스 전체 길이가 아니라 다음 CPU의 버스트 길이에 의해 스케줄링 -> 최단 다음 CPU 번스트
- 주어진 프로세스 집합에 대해 최소 평균 대기 시간을 가진다
- 다음 CPU 요청 길이 파악이 어려운 문제점!!
- SJF 스케줄링은 장기 스케줄링에서 자주 사용
  - 단기 스케줄링에서는 다음 CPU 버스트 길이를 알 수 있는 방법이 없음
  - 한가지 접근 방식은 다음 CPU 버스트 길이를 예측하는 것
- SJF 알고리즘은 선점 OR 비선점형일 수 있음
  - 선점형 SJF 알고리즘은 현재 실행 프로세스를 선점
  - 비선점 SJF 알고리즘은 현재 실행 프로세스가 자신의 CPU 버스트를 끝내도록 허용
- 선점형 SJF 알고리즘은 때로 최소 잔여 시간 우선 스케줄링이라고도 함

3.3 우선순위 스케줄링
- 우선순위가 프로세스들에게 연관되어 있으며, CPU는 가장 높은 우선순위를 가진 프로세스에게 할당
- 우선순위가 같을 경우 FCFS 순서로 스케줄
- 내부적 우선순위는 프로세스의 우선순위를 계산하기 위해 어떤 측정 가능한 양들을 사용(시간제한, 메모리 요구, 열린 파일 수, 평균 CPU 버스트 비율 등)
- 외부적 우선순위는 프로세스 중요성, 비용, 타입 등과 같은 운영체제 외부적 기준에 의해 결정
- 선점형이거나 비선점형이 될 수 있다
- 프로세스가 준비 완료 큐에 도착하면, 새로 도착한 프로세스의 우선순위를 현재 실행 프로세스의 우선순위와 비교
  - 선점형일경우 새로 도착한프로세스 우선순위가 현재 실행 프로세스보다 높다면 CPU 선점
  - 비선점일 경우 준비완료 큐의 머리 부분에 새로운 프로세스 넣음
- 무한 봉쇄 OR 기아 상태가 우선순위 스케줄링의 주요 문제점!!
  - 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우 발생 가능
  - 부하가 과중한 컴퓨터 시스템 시 높은 우선순위 프로세스들이 꾸준히 들어와 낮은 우선순위 프로세스들이 CPU를 얻지 못할 수 있음
  - 결국 낮은 우선순위 프로세스를 잃는 경우가 발생할 수 있음
- 무한 봉쇄 문제 해결하는 방법은 노화
  - 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가 시킨다

3.4 라운드 로빈 스케줄링
- 시분할 스템을 위해 설계되었음
- 선입선출 스케줄링과 유사하나 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가
- 시간 할당량이라는 작은 단위의시간을 정의
- 준비 완료 큐는 원형 큐로 동작
- CPU 스케줄러는 준비 완료 큐를 돌면서 한 번에 한 프로세스에게 한 번의 시간 할당량 동안 CPU를 할당

- 첫 번째 프로세스 선택해 한 번의 시간 할당량 이후 인터럽트를 걸도록 타이머 설정 후, 프로세스를 디스패치한다
  - CPU 버스트가 한 번의 시간 할당량보다 작을 경우
    - 자신이 CPU를 자발적으로 방출 -> 준비 완료 큐에 있는 다음 프로세스로 진행
  - CPU 버스트가 한 번의 시간 할당량보다 클 경우
    - 타이머 끝나고 운영체제에게 인터럽트를 발생 -> 문맥 교환이 일어나고 실행 프로세스는 준비 완료 큐의 꼬리에 넣어짐 -> CPU 스케줄러는 준비 완료큐의 다음 프로세스 선택

- RR 알고리즘의 성능은 시간 할당량 크기에 매우 많은 영향을 받음
  - 시간 할당량이 크면, 선입 선처리 정책과 같음
  - 시간 할당략이 작으면, 매우 많은 문맥교환을 야기
  -> 시간 할당량이 문맥 교화나 시간에 비해 클 것을 원함
- 총처리 시간 역시 시간 할당량의 크기에 좌우
  - 대부분 프로세스들이 단일 시간 할당량 안에 다음 cpu 버스트 끝내면 평균 총 처리시간은 개선된다
- 시간 할당량이 문맥 교환 시간에 비해 커야하나 너무 커서는 안된다 -> CPU 버스트의 80%는 시간 할당량보다 짧아야 한다

3.5 다단계 큐 스케줄링
- 준비 완료 큐를 다수의 별도 큐로 분류한다
- 프로세스들인 메모리 크기, 프로세스 우선순위 같은 특성에 따라 한 개의 큐에 영구적으로 할당
- 각 큐는 자신의 스케줄링 알고리즘을 갖고 있다
- 큐와 큐 사이에 스케줄링도 반드시 있어야 하며, 고정 우선순위의 선점형 스케줄링으로 구현된다

  ![ex_screenshot](/res/os23.png)

3.6 다단계 피드백 큐 스케줄링
- 다단계 큐 스케줄링은 프로세스들이 시스템 진입 시 영구적으로 하나의 큐에 할당 -> 스케줄링 오버헤드가 장점이나 융통성이 적다
- 다단계 피드백 큐에서는 프로세스가 큐들 사이를 이동하는 것을 허용
- 프로세스들을 CPU 버스트 성격에 따라 구분
  - CPU 시간을 너무 많이 사용하면 낮은 우선순위 큐로 이동
  - 입출력 중심 프로세스와 대화형 프로세스들을 높은 우선순위 큐에 넣음
  - 낮은 우선순위 큐에서 너무 오래 기다린 프로세스는 높은 우선순위 큐로 이동 -> 기아 상태를 예방
- 다단계 피드백 큐 스케줄러는 다음 매개변수에 의해 정의된다
  - 큐의 개수
  - 각 큐를 위한 스케줄링 알고리즘
  - 한 프로세스를 높은 우선순위 큐로 올려주는 시기 결정 방법
  - 한 프로세스를 낮은 우선순위 큐로 강등하는 시기 결정 방법
  - 프로세스가 서비스 필요 시 프로세스가 들어갈 큐 결정 방법
  
4. 스레드 스케줄링
- 다대일, 다대다 모델 구현 시스템에서는 스레드 라이브러리는 사용자 수준 스레드를 가용한 LWP 상에서 스케줄 한다
  - 동일 프로세스에 속한 스레드들 사이에 CPU를 경쟁하기에 프로세스-경쟁-범위라고 한다
  - 우선순위에 따라 행해진다 
- CPU 상에 어느 커널 스레드를 스케줄 할 것인지 결정하기 위해 커널은 시스템-경쟁 범위를 사용
  - CPU에 대한 경쟁은 시스템 상 모든 스레드 사이에서 일어남

5. 다중 처리기 스케줄링
5.1 다중 처리기 스케줄링에 대한 접근 방법
- 비대칭 다중 처리 사용
  - 주 서버라는 하나의 처리기가 모든 스케줄링 결정과 입출력 처리, 다른 시스템의 활동을 취급하게 하는 것
  - 다른 처리기들은 다만 사용자 코드만을 수행
  - 단지 한 처리기만 시스템 자료구조를 접근해 자료 공유의 필요성을 배제하기에 간단하다
- 대칭 다중 처리를 사용
  - 각 처리기가 독자적으로 스케줄링
- 서로 다른 2개의 처리기가 같은 프로세스를 선택하지 않아야 하며 프로세스들이 큐에서 사라지지 않는다는 것을 보장해야 한다

5.2 처리기 친화성
- 처리기에 의해 가장 최근에 접근된 데이터가 처리기의 캐시를 채우게 됨
- 캐시를 무효화 하고 다시 채우는 작업은 비용이 많이 들기 때문에 대부분 SMP 시스템은 한 처리기에서 다른 처리기의 이주를 피하고 같은 처리기에서 프로세스를 실행하려고 하는데 이를 처리기 친화성이라 한다
- 프로세스가 현재 실행 중인 처리기에 친화성을 가진다는 것을 의미
- 연성 친화성 : 운영체제가 동일 처리기에서 프로세스를 실행시키려 노력하는 정책을 갖지만, 보장하지 않는 경우
- 강성 친화성 : 시스템 호출을 통해 프로세스는 자신이 실행될 처리기 집합을 명실할 수 있는 경우
- 대부분 연성, 강성 친화성을 모두 지원한다.

5.3 부하 균등화
- 처리가가 하나 이상이라는 것을 최대한 활용하려면 부하를 모든 처리기에 균등하게 배분하는 것이 중요!
- 부하 균등화는 SMP 시스템의 모든 처리기 사이에 부하가 고르게 배분되도록 시도한다
- 각 처리기가 실행할 프로세스를 위한 자기 자신만의 큐를 가지고 있는 시스템에서만 필요한 기능임을 주의!
- PUSH 이주 : 특정 태스크가 주기적으로 각 처리기의 부하를 검사하고 불균형 상태이면 과부하인 처리기에서 쉬고 있거나 덜 바쁜 처리기로 프로세스를 이동시킴으로 부하를 분배
- PULL 이주 : 쉬고 있는 처리기가 바쁜 처리기를 기다리고 있는 프로세스를 PULL 할때 발생
-> 둘은 병렬적으로 구현딘다.

5.4 다중코어 프로세서
- 각 프로세스가 자신의 물리 칩을 가지는 시스템에 비해 속도가 쁘르고 적은 전력을 소모
- 스케불링 문제를 복잡하게 한다
  - 메모리 멈춤 : 프로세스가 메모리 접근 시 데이터가 가용해지기를 기다리며 많은 시간을 허비
    - 캐시 미스 등 여러원인이 이유
- 처리기를 다중 스레드화 하는 방법
  - 거친 다중 스레딩 : 스레드가 메모리 멈춤과 같은 긴 지연시간을 가지 사건 발생 시까지 한 처리기에서 수행
    - 처리기는 다른 스레드 실행
    - 스레드간 교환 비용이 많이 든다
  - 세밀한 다중 스레딩 : 보통 명령어 주기의 경계에서 같이 좀 더 세밀한 정밀도를 가진시점에 스레드 교환이 일어남
    - 세밀한 시스템의 구조적 설계는 스레드 교환을 위한 회로를 포함 -> 스레드간 교환 비용이 적어짐
- 다중 스레드 다중코어 프로세스는 두가지 스케줄링이 필요
  - 소프트웨어 스레드가 각 하드웨어 스레드에서 실행되어야 하는지 운영체제가 결정 하는 것
  - 각 코어가 어떤 하드웨어 스레드를 실행시킬지 지정해야 하는 것
  
6. 실시간 CPU 스케줄링
- 연성 실시간 시스템 : 오직 중요한 프로세스가 그렇지 않은 프로세스들에 비해 우선권을 가진다는 것만 보장
- 경성 실시간 시스템 : 엄격한 요구조건을 만족
  - 태스크는 반드시 마감시간까지 서비스 받아야 하며 마감시간이 지난 후 서비스 받은 것은 서비스를 전혀 받지 않는 것과 동일 결과

6.1 지연 시간 최소화
- 사건 지연 시간 : 사건이 발생해서 그에 맞는 서비스가 수행될 때까지의 시간
- 두가지 유형의 지연시간이 실시간 시스템 성능을 좌우
  - 인터럽트 지연 시간 : CPU에 인터럽트가 발생한 시점부터 해당 인터럽트 처리 루틴이 시작하기까지 시간
    - 인터럽트 지연시간을 최소화하는것이 실시간 운영체제에게 매우 중요한 일
    - 실시간 운영체제는 인터럽트 불능 시간을 매우 짧게 해야한다
  - 디스패치 지연 시간 : 스케줄링 디스패처가 하나의 프로세스를 블록시키고 다른 프로세스를 시작하게 하는데 걸리는 시간
    - 실시간 운영체제는 이 지연 시간을 최소화해야한다
    - 가장 효과적인 방법은 선점형 커널이다
    
8. 알고리즘 평가
- 알고리즘을 선택하는 데 사용할 기준을 정의하는 것
  - CPU 이용률, 응답시간, 처리량에 의해 기준이 정의됨
- 최대 응답 시간이 1초라는 제약 조건 하에 CPU 이용률을 극대화 한다
- 총 처리 시간이 전체 실행 시간에 평균적으로 선형 비례가 되도록 처리량을 극대화 한다

8.1 결정론적 모델링
- 분석적 평가 : 주어진 작업 부하에 대한 알고리즘 성능을 평가하는 공식이나 값을 생성하기 위해 주어진 알고리즘과 시스템 작업 부하를 이용
- 결정론적 모델링은 분석적 평가의 한가지 유형
  - 사전에 정의된 특정한 작업 부하를 받아들여 그 작업 부하에 대한 각 알고리즘 성능을 정의
  - 단순하고 빠르며, 알고리즘들을 비교할 수 있도록 정확한 값을 제공한다
  - 정확한 숫자를입력으로 요구하며, 응답도 단지 이들의 경우에만 적용하는 단점이 있다
  - 주로 스케줄링 알고리즘을 설명하고 예를 제공하는데 사용

### 프로세스 동기화
- 협력적 프로세스 : 시스템 내에서 실행중인 다른 프로세스의 실행에 영향을 주거나 영향을 받는 프로세스
  - 논리 주소 공간을 직접 공유하거나 파일 or 메시지에 의해 데이터의 공유가 허용
- 경쟁 상황 : 동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황
2 임계구역 문제
- 한 프로세스가 자신의 임계구역에서 수행하는 동안 다른 프로세스들은 임계구역에 들어갈 수 없다
- 프로세스들이 협력할 때 사용할 수 있는 프로토콜을 설계하는 것
- 해결하기 위한 요구조건
  - 상호 배제(mutual exclusion) : 프로세스 p가 자기 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없음
  - 진행(progress) : 자기 임계구역에서 실행되는 프로세스 없고 임계구역으로 진입하려는 프로세스가 있다면 나머지 구역에서 실행중이지 않은 프로세스들만 다음 임계구역으로 진입할 지 결정에 참여 가능, 이 선택은 무한정 연기될 수 없음
  - 한정된 대기(bounded wating) : 임계구역 진입 요청 후부터 허용때까지 다른 프로세스들이 임계구역에 진입하도록 허용되는 횟수에 한계가 있다
- 운영체제 내에서 임계구역을 다루기 위해 선점형 커널, 비선점형 커널 두 가지 접근법 사용
  - 선점형 커널 : 프로세스가 커널 모드에서 수행되는 동안 선점하는 것 허용
  - 비선점형 커널 : 커널 모드에서 수행되는 프로세스의 선점을 허용않고 커널 모드 프로세스는 커널을 빠져나갈 때까지 or 봉쇄될 때까지 or 자볼적으로 CPU 제어를 양보할 때까지 계속 수행

3 피터슨의 해결안
- 임계 구역과 나머지 구역을 번갈아 실행하는 두 개의 프로세스로 한정
- 두 프로세스가 두 개의 데이터 항목을 공유하도록 하여 해결
- int turn; (임계구역으로 진입할 순번)
  - turn == i 이면 프로세스 Pi가 임계구역에서 실행될 수 있다
- boolean flag[2]; (프로세스가 임계구역으로 진입할 준비가 되었다는 것을 나타낸다)
  - flag[i] == true 이면 Pi가 임계구역으로 진입할 준비가 되었음을 나타냄
<pre><code>
do{
  flag[i] = TRUE;
  turn = j;
  while(flag[j] && turn == j);
  
  critical section
  
  flag[i] = FALSE;
  
  remainder section
  } while(TRUE);
</code></pre>

4 동기화 하드웨어
- test_and_set() 명령어
<pre><code>
Boolean test_and_set(boolean *target){
  boolean rv = *target;
  *target = true;
  return rv;
}

do{
  while(test_and_set(&lock))
    ; // do noting
    // critical section
   lock = FALSE;
    // remainder section
  } while(TRUE);
  
</code></pre>

- compare_and_swap() 명령어
<pre><code>
void compare_and_swap(int *value, int expected, int new_value){
  int temp = *value;
  
  if(*value == expectd)
    *value = new_value;
  return temp;
}

do{
  while(test_and_set(&lock))
    ; // do noting
    // critical section
   lock = 0;
    // remainder section
  } while(TRUE);
  
</code></pre>

5 Mutex Locks
- 임계구역을 보호하고 경쟁 조건을 방지하기 위해 mutex 락을 사용
- 프로세슷는 임계구역에 들어가기 전 반드시 락을 획득하고 빠져 나올 때는 반환해야한다
- boolean available; 락의 가용여부 
<pre><code>
// 락 획득
acquire(){
  while(!available)
    ; // busy wait
   available = false;
 }
// 락 반환
release(){
  available = true;
}
</code></pre>
- 두 함수 호출은 원자적으로 수해오디어야 한다
- 바쁜 대기를 하는 단점이 있다
  - 프로세스가 임계구역에 있는 동안 다른 프로세스들은 acquire() 함수를 호출하는 반복문을 계속 실행해야 한다
  - 락이 사용해지기를 계속 기다리면 프로세스가 회전하고 있기에 spinlock이라고 부른다
  - CPU 사이클을 낭비하게 된다
- spinlock은 문맥 교환을 전혀 필요로 하지 않는 장점이 있다
  - 짧은 시간동안 락을 소유할 경우 spinlock이 유용

6 세마포(Semaphores)
- 세마포 S는 정수 변수로, 원자적 연산 wait(), signal()로만 접근이 가능
<pre><code>
wait(S){
  while(S<=0)
    ;// 바쁜 대기
  S--;
}
signal(S){
  S++;
}
</code></pre>

6.1 세마포 사용법
- 카운팅 세마포는 제한이 없는 영역을 갖는다
- 이진 세마포는 0과 1 사이의 값만 가능, mutex 락과 유사하게 동작
- 상호 배제를 보장하기위해 이진 세마포가 사용되기도 한다
- 카운팅 세마포는 유한 개수를 가진 자원에 대한 접근을 제어하는데 사용

6.2 구현
- 봉쇄연산은 프로세스를 세마포에 연관된 대기큐에 넣고, 프로세스의 상태를 대기 상태로 전환
- 제어가 CPU 스케줄러로 넘어가고, 스케줄러는 다른 프로세스 실행을 위해 선택
<pre><code>
typedef struct{
  int value;
  struct process *list;
} semaphore;

void wait(semaphore *S){
  S->vlaue--;
  if(S->value <0){
    프로세스를 s->list에 넣음;
    block();
  }
}

void signal(semaphore *S){
S->value++;
  if(S->value <=0){
    S->list로부터 하나의 프로세스 P를 꺼낸다;
    wakeup(P);
  }
}
</code></pre>

- signal 연산은 프로세스 리스트에서 한 프로세스를 꺼내 프로세스를 깨워 줌.
- block 연산은 자기를 호출한 프로세스를 중지
- wakeup(P) 연산은 봉쇄된 프로세스 P의 실행을 재개시킨다
- 각 세마포는 정수 값과 프로세스 제어 블록의 리스트에 대한 포인터를 가지고 있다 
- 세마포가 원자적으로 실행되어야 한다는 것은 매우 중요!
- 두 프로세스가 동시에 wait와 signal 연산들을 실행할 수 없도록 반드시 보장해야 한다

6.3 교착 상태와 기아
- 대기 큐를 가진 세마포 구현은 두개 이상 프로세스들이 오로지 대기 중인 프로세스들 중 하나에 의해서만 야기 될 수 있는 사건을 무한정 기다리는 상황이 발생할 수 있다.
- signal() 연산의 실행을 의미하고 이런상태에서 프로세스들은 교착 상태라고 한다
- 무한 봉쇄 or 기아 => 프로세스들인 세마포에서 무한정 대기하는 것

7. 고전적인 동기화 문제들
7.1 유한 버퍼 문제
<pre><code>
int n;
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;
do{
  wait(full);
  wait(mutex);
  // remove an item from buffer to nextc
  signal(mutex);
  signal(empty);
  // consum the item in nextc
} while(TRUE);
</code></pre>
- n개의 버퍼들로 구성된 풀이 있으며 각 버퍼들은 한 항목(item) 저장할 수 있다고 가정
- mutex 세마포는 상호 배젲 기능을 제공하며 1로 초기화
- empty는 비어 있는 버퍼 수, full은 꽉 찬 버퍼의 수
- 생산자가 소비자를 위해 꽉 찬 버퍼를 생산해내고 소비자는 생산자를 위해 비어 있는 버퍼를 생산

7.2 Readeers-Writers 문제
- writer와 다른 스레드가 동시 접근 시 혼란 야기
- wirter가 작업 동안 공유 데이터베이스에 배타적 접근 권한을 가질 필요가 있다

- writer가 공유 객체 사용의 허가를 엊지 못했다면 reader를 기다리게 해서 안된다.
- writer가 준비되면 가능한 빨리 쓰기를 수행할 것을 요구한다 -> 다른 새로운 reader들은 읽기 시작을 못한다
-> 해결안이 기아를 낳을 수 있다
- 첫번째 경우는 writer가 기아, 두번째는 reader가 기아 될 수 있다.
<pre><code>
semaphore rw_mutex = 1;
semaphore mutex = 1;
int read_count = 0;
//Writer 구조
do{
  wait(rw_mutex);
  // writeing is performed
  signal(rw_mutex);
} while(true);

// Reader 구조
do{
  wait(mutex);
  read_count++:
  if(read_count ==1)
    wait(rw_mutex);
  signal(mutex);
  // reading is performed
  wait(mutex);
  read_count--;
  if(read_count == 0)
  signal(rw_mutex);
  signal(mutex);
}while(true);
</code></pre>

- Reader-Wirter락이 유용한 경우
  - 공유 데이터를 읽기만 하는 프로세스와 쓰기만 하는 스레드를 식별하기 쉬운 응용
  - Writer보다 reader의 개수가 많은 용용
  
7.3 식사하는 철학자들 문제
<pre><code>
semaphore chopstick[5];
do{
  wait(chopstick[i]);
  wait(chopstick[(i+1) %5]);  
  // eat for awhile
  signal(chopstick[i]);
  signal(chopstick[(i+1) %5]);
  // think for awhile
} while(true);
</code></pre>
- 두 철학자가 동시에 식사하지 않음을 보장하나 교착 상태를 야기할 가능성이 있음

8. 모니터
- 세마포는 signal, wait를 바꿔쓰거나 잘못 사용할 경우, 빠트린 경우 교착 상태가 발생하게된다.
8.1 모니터 사용법
- 모니터 형은 모니터 내부에서 상호 배제가 보장되는 프로그래머가 정의한 일련의 연산자 집합을 포함하는 ADT
  - 변수들의 선언을 포함 -> 변수들의 값은 형에 해당하는 한 인스턴스 상태를 정의
  - 프로시저 or 함수들의 본체 포함
  - 다른 프로세스들이 직접 사용 불가
  - 모니터 내 정의된 함수만 오직 모니터 내 지역적으로 선언된 변수들과 형식 매개변수들에만 접근 가능
  - 모니터 내 지역변수는 오직 지역 변수만 가능
- 모니터는 모니터 안에 항상 하나의 프로세스만 활성되도록 보장해 준다
  - condition형의 변수로 동기화 제공
  - condition에 의해 호출될 수 있는 연산은 오직 wait와 signal 뿐이다
  - wait는 signal 호출때까지 일시중단되어야 함
  - signal은 정확히 하나의 일시중단 프로세스를 재개
  - Signal and wait : P는 Q가 모니터를 떠날 때까지 기다리거나 다른 조건을 기다린다
  - Signal and continue : Q는 P가 모니터를 떠날 때까지 기다리거나 다른 조건을 기다린다
8.2 모니터를 사용한 식사하는 철학자 해결안
<pre><code>
monitor DiningPhilosphers{
  enum{thinking, hungry, eating} state[5];
  condition self[5];  
  
  void pickup(int i){
    state[i] = HUNGRY;
    test(i);
    if(state[i] != EATING)
      self[i].wait();
  }
  void putdown(int i){
    state[i] = THINKING;
    test((i+4)%5);
    test((i+1)%5);
  }
  void test(int i ){
    if((state[(i+4)%5] != EATING && (state[i]== HUNGRY) && (state[i+1)%5]!= EATING)){
      state[i] = EATING;
      self[i].signal();
    }
  }
  initialization code(){
    for(int i = 0; i<5; i++)
      state[i] = THINKING;
    }
}
</code></pre>
- 식사하기전 pickup 연산을 반드시 호출해야 한다
- 식사 후에는 putdown 연산 호출

9. 대체 방안들

9.1 트랜잭션 메모리
- 메모리 트랜잭션 : 메모리 읽기와 쓰기 연산의 원자적인 연속적 순서
  - 한 트랜잭션의 모든 연산이 완수되면 메모리 트랜잭션은 확정
  - 그렇지 않으면 그 시점까지 완수된 모든 연산들은 취소되고 시작 이전의 상태로 roll-back
- atomic{S}가 추가
  - S 내 연산이 트랜잭션으로 실행된다는 것을 보장
- STM은 트랜잭션 블록 안에 검사 코드르르 삽입해 동작
  - 컴파일러에 의해 삽입되어 명령문들이 동시 시행 지점과 저수준 락킹이 필요한 지점을 검사하여 각 트랜잭션을 관리
- HTM은 개별 처릴기 캐시에 존재하는 공유 데이터 충돌을 해결하고 관리하기위해 HW 캐시 계층 구조와 캐시 일관성 프로토콜을 사용
  - 코드 계측이 필요 없고 STM보다 적은 오보헤드를 가진다.
  - 기존 캐시 계층 구조와 캐시 일관성 프로토콜을 트랜잭션 메모리를 지원하기위해 변경해야 한다
 
### 교착상태
- 한 프로세스 집합 내의 모든 프로세스가 집합 내의 다른 프로세스에 의해서만 발생 될 수 있는 사건을 기다리면 프로세스 집합은 교착 상태에 있다
7.2 교착 상태의 특징
- 필요 조건
  - 상호 배제 : 최소한 하나의 자원이 비공유 모드로 점유되어야 한다
    - 비공유 모드에서는 한 번에 한 프로세스만이 그 자원을 사용할 수 있다
    - 다른 프로세스가 자원을 요청하면, 요청 프로세스는 자원이 방출될 때까지 반드시 지연되어야 함
  - 점유하며 대기 : 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 함
  - 비선점 : 자원들을 선점할 수 없어야 한다
  - 순환 대기
- 교착 상태가 발생되려면 4가지 조건이 성립되어야 함!
- 자원 할당 그래프
  - Pi -> Rj (요청 간선), Rj -> Pi (할당 간선)
  
  ![ex_screenshot](/res/os24.png)
  - 그래프가 사이클을 포함하면 교착상태가 존재할 수 있다
  - 각 자원 타입이 정확히 하나의 인스턴스만 가지면 하나의 사이클은 교착 상태가 발생함을 암시
  - 사이클이 있으며 교착상태가 아닌 자원 할당 그래프
  
    ![ex_screenshot](/res/os25.png)
    
7.3 교착 상태 처리 방법
- 교착 상태를 예방하거나 회피
  - 필요 조건들 중 적어도 하나가 성립하지 않도록 보장하는 일련의 방법
  - 자원이 어떻게 요청될 수 있는지를 제한하며 교착상태를 예방
- 교착 상태 허용 후 회복
  - 사용할 자원에 대한 부가적 정보를 미리 제공할 것을 요구함
- 문제를 무시하고 발생하지 않은 척 
  - 다름 방법에 비해 비용이 적게 들지만 반드시 수작업 복구 방법이 있어야 함.

7.4 교착상태 예방
- 상호 배제
  - 적어도 하나의 자원은 공유 불가능 자원이어야 함
  - 공유 자원들은 배타적 접근을 요구하지 안흥며 교착상태에 관련될 수 없다
- 점유하며 대기
  - 각 프로세스가 실행되기 전 자신의 모든 자원을 요청하고 할당받을 것을 요구하는 방법
  - 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용 
  - 두 방법은 자원 이용도가 낮을 수 있고 기아 상태가 가능 하다
- 비선점 
  - 점유 프로세스가 즉시 할당할 수 없는 다른 자원을 요청하면 현재 점유하고 있는 모든 자원들이 선점
  - 한 프로세스가 자원 요청 시 사용 가능을 검사하고 가능 시 할당, 불가능 시 자원들이 추가 자원을 위해 대기하고 있는 다른 프로세스에 할당되어 있는지를 검사
  - mutex 락과 세마포 같은 자원에는 적용 불가
- 순환 대기
  - 모든 자원 타입들에게 전체적인 순서를 부여
  - 모든 동기화 객체의 순서를 정하고 이 기법을 응용 프로그램에 구현할 수 있다 (요청은 오름차순으로 요청되어야 함)

- 요청 방법에 제한을 두어 교착상태를 예방
- 필요조건 중 적어도 한가지는 성립되지 않도록 보장
-> 장치의 이용률이 저하되고 시스템 처리율이 감소된다!

7.5 교착상태 회피
- 자원이 어떻게 요청될 지에 대한 추가 정보를 제공하도록 요구하는 것
-
