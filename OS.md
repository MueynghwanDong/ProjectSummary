# 운영체제(Operating System)

### 서론
1.1 운영체제가 할일 
1) 사용자 관점 
- PC : 한 사용자가 자원을 독점하도록 설계되었으며 사용자가 수행하는 작업을 최대화하는 것이 목적, 사용의 용이성을 위해 설계
- 대형, 미니 컴퓨터 : 자원을 공유하며 정보 교환 가능, 자원 이용을 극대화하도록 설계하며 각 개인은 자신의 정당 몫만 사용 가능
- 워크스테이션, 서버 : 자신이 맘대로 할 수 있는 전용자원을 갖지만 네트워킹 서버-파일, 프린트 서버를 공유, 개인의 사용 용이성과 자원 이용간 적절한 조화를 이루도록 설계
- 휴대용 컴퓨터 : 개인 사용자들을 위한 독립형 장치
2) 시스템 관점 
- 자원 할당자 : 자원의 관리자로 동작하며 작업을 위해 특정 프로그램과 사용자에게 필요 자원 할당, 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할지 결정해야함
- 제어프로그램 : 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어

1.4 운영체제 구조
- 운영체제의 가장 중요한 면 => 다중 프로그램을 할 수 있는 능력
- 다중 프로그래밍
  - CPU가 수행할 작업을 항상 하나 가지도록 구성함으로 CPU 이용률을 증가한다
  - 작업들은 디시크의 작업 풀 내에 유지된다
  - 작업 풀은 디스크 내의 모든 프로세스로 구성되며 주 메모리의 할당을 기다린다
  - 메모리 내 작업 집합은 작업 풀 내의 작업들의 부분 집합이다
  - 여러 시스템 자원을 효율적으로 이용할 수 있는 환경을 제공하나 사용자를 위해 컴퓨터 시스템과 상호작용을 제공하지 않음
  - 시분할은 다중 프로그래밍의 논리적 확장
- 시분할 시스템
  - 사용자, 시스템 간 직접 통신을 제공하는 대화식 컴퓨터 시스템을 필요로 함
    - 응답시간이 짧아야 하며, 1초 이내 정도
  - 동시에 많은 사용자가 컴퓨터를 공유하도록 한다
  - CPU 스케줄링과 다중 프로그래밍을 사용한다 
    - 각 사용자에게 시분할 되는 작은 부분을 제공하기 위해 
  - 시분할과 다중 프로그래밍 운영체제는 여러 작업이 메모리에 동시에 유지되어야 한다
    - CPU 스케줄링, 작업 스케줄링
  - 시분할 시스템에서 운영체제는 적잘한 응답시간을 보장해야 한다
  - 파일 시스템을 제공해야 한다
  - 디스크 관리 기법, 작업 동기화와 통신 기법을 제공해야 하며 교착 상태에 빠지지 않도록 해야한다
  - 자원을 보호하기 위한 기법을 제공해야 한다
  
1.5 운영체제 연산 
- 트랩 : 오류 혹은 사용자 프로그램의 운영체제 서비스 수행 요청에 의해 유발되는 소프트웨어에 의해 생성된 인터럽트
1) 이중 연산 모드 
- 운영체제를 위해 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다
- 사용자 응용을 위해 실행 시 사용자 모드, 운용체제로부터 서비스 요청을 하면 사용자에서 커널 모드로 전환
- 이중 모드는 잘못된 사용자로부터 운영체제를, 잘못된 사용자 서로를 보호하는 방법을 제공함

  ![ex_screenshot](/res/os1.jpg)
  
  - 시스템 부트 시 커널 모드에서 시작
  - 운영체제가 적재되고 사용자 모드에서 프로세스 시작
  - 트랩, 인터럽트 발생마다 사용자에서 커널모드로 전환 
  - 운영체제가 컴퓨터 제어를 얻을 때마다 커널모드에 있게됨
  - 특권 명령은 커널 모드에서만 수행되도록 하며 사용자 모드에서 수행 시 불법적 명령으로 간주해 운영체제로 트랩을 건다
  
2) 타이머 
- 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장
- 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패해 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지해야한다
- 가변 타이머는 고정률의 클락과 계수기로 구현
  - 계수기가 0이 될 때 인터럽트 발생
- 타이머가 인터럽트 발생하면 제어는 운영체제로 넘어가며 타이머 값을 변경 명령은 특권 명령
  - 사용자 프로그램이 오래 실행되는 것을 방지하기 위해 사용할 수 있음
  
1.6 프로세스 관리
- 프로세스는 자신의 일을 수행하기 위해 CPU 시간, 메모리, 파일, 입출력 장치를 포한한 여러 자원을 필요로 함
- 한 프로세스는 한 시스템 내의 작업의 단위
- 운영체제는 다음과 같은 활동에 대한 책임을 진다
  - CPU에 프로세스와 스레드 스케줄
  - 사용자 프로세스와 시스템 프로세스의 생성과 제거
  - 프로세스의 일시 중지와 재수행
  - 프로세스 동기화를 위한 기법 제공
  - 프로세스 통신을 위한 기법 제공
1.7 메모리 관리 
- 주 메모리는 CPU와 입출력 장치에 의해 공유되는 빠른 접근이 가능한 데이터 저장소
- 주 메모리는 CPU가 직접 주소 지정할 수 있고, 직접 접근이 가능한 유일한 대량 메모리
- 프로그램 수행을 위해 반드시 절대 주소로 매핑되고 메모리에 적재되어야 한다
- CPU 이용률과 사용자에 대한 응답속도를 개선하기 위해 메모리에 여러 개의 프로그램을 유지해야 하며 이를 위한 메모리 관리 기법이 필요
- 운영체제는 다음과 같은 일을 담당
  - 메모리의 어느 부분이 사용되고 누구에 의해 사용되는지 추적해야 한다
  - 어떤 프로세스들을 메모리에 적재하고 제거할 것인지 결정
  - 필요에 따라 메모리 공간을 할당하고 회수해야한다
1.8 저장장치 관리 
- 파일 시스템 관리 
  - 파일의 생성 및 제거
  - 디렉토리 생성 및 제거
  - 파일과 디렉토리 조작을 위한 프리미티브 제공
  - 파일을 보조 저장 장치로 매핑
  - 안정적 저장 매체에 파일 백업
- 대용량 저장 장치 관리 
  - 자유 공간의 관리 
  - 저장 장소 할당 
  - 디스크 스케줄링
  
### 시스템 구조
1) 운영체제 서비스 
- 사용자에게 도움을 주는 목적

  ![ex_screenshot](/res/os2.png)  
  
  - 사용자 인터페이스 : 명령어 라인 인터페이스 / 그래피컬 사용자 인터페이스
  - 프로그램 수행 : 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야함
  - 입출력 연산
  - 파일 시스템 조작 
  - 통신 : 공유 모메리, 메시지 전달 기법 등
  - 오류 탐지 : 각 유형 오류에 대해 적당한 조치를 취해야 함
- 시스템 자체의 효율적 동작을 보장하기 위한 운영체제 기능
  - 자원 할당 
    - 다수의 사용자, 작업들이 동시 수행 시, 각각에 자원을 할당해 주어야함
  - 회계
    - 사용자가 어떤 종류의 컴퓨터 자원을 많이 사용하는지 추적할 수 있어야함
  - 보호와  보안
2) 사용자 운영체제 인터페이스
2.1 명령 해석기
- 사용자가 지정한 명령을 가져와 수행하는 것이 주 기능
- 구현 방식 중 하나는 명령 해석기 자체가 명령을 실행할 코드를 갖고 있는 경우
  - 명령 해석기가 자신의 코드의 한 부분을 분기하고 코드 부분이 매개 변수를 설정하고 적절 시스템을 호출 -> 명령의 수가 명령 해석기 크기를 결정
- 다른 방법은 시그템 프로그램에 의해 대부분의 명령을 구현하는 방법
3) 시스템 호출
- 시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공
- API : 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함해 응용 프로그래머가 사용 가능한 함수의 집합을 명시
  - 프로그램의 호환성에 따라 실제 시스템 호출 보다 API를 선호하는 편
- 프로그래밍 언어들을 위한 실행시간 지원 시스템은 운영체제가 제공하는 시스템 호출에 대한 연결로서 동작하는 시스템 호출 인터페이스를 제공
  - API 함수의 호출을 가로채 필요 운영체제 시스템 호출을 부른다
- 통상 시스템 호출은 번호가 할당되고 번호에 따라 색인되는 테이블을 유지한다, 호출 인터페이스는 의도 시스템 호출을 부르고 시스템 호출의 상태와 반환 값을 돌려준다
- 호출자는 단지 API를 준수하고 시스템 호출의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다
- 운영체제에 매개변수를 전달하기 위한 방법
- 매개변수를 레지스터 내에 전달하는 방법
- 레지스터보다 매개변수가 많은 경우 매개변수는 메모리 내 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달

  ![ex_screenshot](/res/os3.png)  
  
  ![ex_screenshot](/res/os4.png)  
  
4) 시스템 호출 유형
- 프로세스 제어
  - 끝내기(end), 중지(abort)
  - 적재(load), 수행(execute)
  - 프로세스 생성 및 종료
  - 프로세스 속성 획득, 프로세스 속성 설정
  - 시간을 기다림
  - 사건 기다림(wait event), 사건 알림(signal event)
  - 메모리 할당 및 자유화
- 파일 조작
  - 파일 생성(create file), 파일 삭제(delete file)
  - 열기, 닫기
  - 읽기, 쓰기, 위치 변경
  - 파일 속성 획득 및 설정
- 장치 관리
  - 장치를 요구, 장치를 방출
  - 읽기, 쓰기, 위치 변경
  - 장치 속성 획득, 장치 속성 설정
  - 장치의 논리적 부착 및 분리
- 정보 유지
  - 시간과 날짜의 설정과 획득
  - 시스템 데이터의 설정과 획득
  - 프로세스, 파일, 장치 속성의 획득
  - 프로세스, 파일, 장치 속성의 설정
- 통신
  - 통신 연결의 생성, 제거
  - 메시지 송신, 수신
  - 상태 정보 전달
  - 원격 장치의 부착 및 분리
  
6) 운영체제 설계 및 구현
6.1 설계 목표
- 시스템 설계 시 문제점은 시스템 목표와 명세를 정의하는 일 
- 사용자 목적과 시스템 목적으로 나눔
- 사용자들이 시스템에 기대하는 특징 
  - 사용하기 쉽고 편리하며, 배우기 쉽고 믿을수 있고 안전, 신속 해야한다.
  - 즉, 운영체는 설계, 구현, 유지보수가 쉬어야하며 적응성, 신뢰성, 무오류, 효율성을 가져야 한다
6.2 기법과 정책
- 기법으로부터 정책을 분리하는 것이 중요 원칙
- 기법 : 어떤 일을 어떻게 할 것인가 결정하는 것
- 정책 : 무엇을 할 것인가를 결정하는 것
- 정책과 기법의 분리는 융통성을 위해 중요함
  - 정책은 장소가 바뀌거나 시간 흐름에 따라 변경될 수 있다
- 기법이 정책으로부터 적절히 분리되면 입출력 중심 프로그램이 CPU 중심 프로그램보다 높은 우선순위를 가지도록 하는 정책을 지원하거나 반대 정책을 지원할 수 있다
- 정책 결정은 모든 자원 할당 문제이 있어 중요하다
  - 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야한다
  - 무엇이 아니라 어떻게 일때마다, 반드시 결정되어야 하는 것은 기법
  
7) 운영체제 구조
7.1 간단한 구조 
- MS-DOS는 인터페이스와 기능 계층이 잘 분리되어 있지 않다. 사용자 프로그램이 고장 나면 시스템 전체가 고장나게 된다
- UNIX는 커널과 시스템 프로그램으로 구성되어 있고 커널은 시스템 호출을 통해 파일 시스템, CPU 스케줄링, 메모리 관리, 다른 운영체제 기능을 제공

 ![ex_screenshot](/res/os5.png) 
 
 ![ex_screenshot](/res/os6.png) 
 
7.2 계층적 접근
- 운영체제 스템은 여러 계층으로 구분
  - 최하위 계층 : 하드웨어
  - 최상위 계층 : 사용자 인터페이스
- 운영체제의 층은 데이터와 연산으로 구성된 추상된 객체의 구현이다
- 모듈화를 통해 각 계층은 바로 아래 계층에서 제공하는 기능과 서비스만을 사용
  - 계층은 하위 계층에 대한 연산을 호출 할 수 있다
- 장점 
  - 구축과 디버깅의 단순함
  - 설계와 구현이 단순하다
  - 각 계층은 하위 계층에서 제공하는 연산만을 통해 구현
  - 각 계층은 연산들이 어떻게 구현되는지 알 필요 없음
- 단점
  - 다양한 계층들이 대략적으로 정의
  - 각 계층은 오직 하위 계층들이 제공하는 기능만 사용하기에 주의 깊은 계획이 이요구 된다
  - 다른 유형의 구현 방법보다 효율성이 낮다
7.3 마이크로 커널
- 중요하지 않는 구성 요소를 커널로 부터 제거하고 시스템 및 사용자 수준 프로그램으로 구현해 운영체제를 구성
- 주 기능은 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스 간 통신 제공
  - 커널과 통신은 사용자 모듈 사이에서 메시지 전달을 통해 이루어짐
- 장점
  - 마이크로 커널을 확장하기 쉽다
  - 운영체제를 새로운 구조로 이식하기 쉽다
  - 커널에서 수행되는 코드가 적으므로 안정적이고 안전하다
- 단점 
  - 커널 공간과 통신하기 위한 사용자 공간의 성능 오버헤드 발생

7.4 모듈
- 적재 가능 모듈 : 커널은 핵심 구성요소 집합을 가지고 있고 부팅 때 또는 실행 중 부가 서비스들을 모듈을 통해 링크 한다
- 설계 주안점 : 커널은 핵심 서비스를 제공, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현
- 대부분의 현대 운영체제는 커널 모듈을 구현
  - 객체 지향 접근 사용
  - 각 핵심 컴포넌트는 나뉘어 짐
  - 각 컴포넌트는 정해진 인터페이스를 통해 다른 컴포넌트와 대화
  - 각 컴포넌트는 커널 내에서 필요에 따라 적재 가능
- 모듈화 커널 접근법은 계층 구조 접근법과 유사
  - 모듈화 커널 접근법은 서브시스템들이 서로 정해진 인터페이스를 통해 상호 작용 하도록 요구
  - 각 부분이 정의되고 보호된 인터페이스를 가진다
  - 단, 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층구조보다 유연함
- 중심 모듈은 단지 핵심 기능만 가지고 다른 모듈 적재방법과 어떻게 통신하는지 안다는 점에서 마이크로 커널과 유사
  
  ![ex_screenshot](/res/os7.png) 
  
  ![ex_screenshot](/res/os8.png) 
  
8. 운영체제 디버깅
- 디버깅은 하드웨어와 소프트웨어에서의 시스템 오류를 발견하고 수정하는 행위
- 시스템에서 처리 중 발생하는 병목 현상을 제거해 성능을 향상시키려는 성능 조정도 포함
8.1 장애 분석
- 오류 정보를 로그 파일에 기록하고 프로세스가 사용하던 메모리를 캡처한 코어 덤프를 취하고 차후 분석을 위해 파일로 저장
- 커널 장애는 충돌로 불리며 프로세스 장애와 마찬가지로 오류 정보가 로그파일에 저장되고 메모리 상태가 충돌 덤프에 저장
8.2 성능 조정
- 처리 병목 지점을 제거함으로 성능을 향상하려함
  - 병목지점 발견을위해 시스템 성능을 감시할 수 있다
- 운영체제는 시스템 동작 추적 목록 생산
  - 관심 사건은 시간과 중요 매개변수와 함께 파일에 기록
  - 후에 분석 프로그램이 로그 파일을 처리하고 시스템 성능을 결정하고 병목지점, 비효율성을 발견한다
- 추적은 운영체제 동작의 오류를 발견하는 데 도움을 줄 수 있다

### 프로세스
1. 프로세스 개념 
- 프로세스 : 실행 중인 프로그램, 시분할 시스템에서 작업의 단위
- 스택, 데이터 섹션, 힙을 포함한다
1.2 프로세스 상태
  
  ![ex_screenshot](/res/os9.png)
  - 새로운(new) : 프로세스 생성 중
  - 실행(running) :  명령어들이 실행
  - 대기(wating) : 프로세스가 어떤 사건이 일어나길 기다림
  - 준비 완료(ready) : 프로세스가 처리기에 할당되기를 기다림
    - 프로세스 식별자 배정, 메모리 할당, 프로그램 적재, PCB 초기화, 스케줄링 추가
  - 종료(terminated) : 프로세스 실행이 종료
  
  - new -> ready : Job Scheduling
  - ready -> running : CPU Scheduling
1.3 프로세스 제어 블록(PCB)

  ![ex_screenshot](/res/os10.png) 
  
  - 프로세스 상태 : 상태는 new, ready, running, wating, halted 상태 등이 있다.
  - 프로그램 카운터 : 다음 실행할 명령어 주소를 가리킴
  - CPU 레지스터들 : 컴퓨터 구조에 따라 다양한 수와 타입을 가짐
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보 포함
  - CPU-스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터, 다른 스케줄 매개변수들을 포함
  - 메모리 관리 정보 : OS에 의해 사용되는 메모리 시스템에 따라 기준 레지스터, 한계 레지스터 값, OS가 사용하는 메모리 시스템에 따라 페이지 테이블 or 세그먼트 테이블과 같은 정보 포함
  - 회계 정보 : CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 or 프로세스 번호 등을 포함
  - 입출력 상태 정보 : 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함

  ![ex_screenshot](/res/os11.png) 

2. 프로세스 스케줄링
- 다중 프로그래밍의 목적 : CPU 이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다
- 시분할 목적 : 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU를 빈번히 교체하는 것
- 프로세스 스케줄러는 CPU에서 실행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택
2.1 스케줄링 큐

  ![ex_screenshot](/res/os12.png) 
- 프로세스가 시스템에 들어오면 잡 큐(시스템 안의 모든 프로세스로 구성)에 놓여진다
- 준비 완료 상태에서 실행 대기하는 프로세스들은 준비 완료 큐라는 리스트 상에 유지된다
  - 큐의 헤더는 리스트의 첫번째와 마지막 PCB를 가리키는 포인터 포함
  - 각 PCB는 준비 완료 큐에 있는 다음 프로세스를 가리키는 포인터 필드를 가짐
- 특정 입출력 장치를 대기하는 프로세스들의 리스트를 장치 큐라고 하며 각 장치는 자신의 장치의 장치 큐를 가짐
- 새로운 프로세스는 처음 준비 완료 큐에 놓이며 실행을 위해 선택 될 때 CPU를 할당 받을 때까지 준비 완료 큐에서 대기한다
- 프로세스에 CPU가 할당되어 실행되면 여러 사건 중 하나가 발생
  - 프로세스가 입출력 요청을 하여 입출력 큐에 넣어질 수 있다
  - 프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다릴 수 있다
    - 대기 상태에서 중비 완료 상태로 전환되고 다시 준비 완료 큐에 넣어지게 된다
  - 프로세스가 인터럽트의 결과에 의해 강제로 CPU로부터 제거되고, 준비 완료 큐에 다시 놓일 수 있다
- 프로세스는 종료될 때까지 주기를 계속하며 종료되면 모든 큐에서 삭제되고 자신의 PCB의 자원을 반납한다

  ![ex_screenshot](/res/os13.png) 
2.2 스케줄러
- 장기 스케줄러(잡 스케줄러, new-> ready) : 프로세스들을 선택하여 실행하기 위해 메모리로 적재
- 단기 스케줄러(CPU 스케줄러, ready -> new) : 실행 준비가 완료되어 있는 프로세스들 중 선택해 CPU를 할당 
- 두 스케줄러의 차이점은 실행 빈도에 있음
  - 단기 스케줄러는 CPU를 위해 반드시 자주 새로운 프로세스를 선택해야한다.
  - 장기 스케줄러는 실행 빈도수가 훨씬 적고 다중 프로그램의 정도를 제어한다 
    - 다중 프로그래밍의 정도가 안정적이면 평균 프로세스 생성률이 시스템을 떠나는 평균 프로세스 이탈률과 반드시 동일해야함
- 입출력 중심 프로세스 : 연산보다 입출력 실행에 더 많은 시간을 소요하는 프로세스
- CPU 중심 프로세스 : 입출력 중심 프로세스보다 연산에 시간을 더 소요하여, 입출력 요청을 드물게 발생시키는 프로세스
- 장기 스케줄러는 입출력 중심과 CPU 중심 프로세스들의 적절한 프로세스 혼합을 선택하는 것이 중요

- 중기 스케줄러 : 메모리에서 프로세스들을 제거함으로써 다중 프로그래밍 정도를 완화하는 것이 핵심 아이디어 

  ![ex_screenshot](/res/os14.png) 
  - 차후 다시 프로세스를 메모리로 불러와 중단 시점에서부터 실행 재개 -> swapping
  - 스와핑은 프로세스 혼합 상태를 개선하기 위해 필요하기도 하며, 메모리 요구에 대한 변화가 가용 메모리에 비해 너무 많은 요규를 수용하여, 메모리를 자유화시키기 위해 필요하기도 함

2.3 문맥 교환
- 인터럽트 발생 시 시스템은 인터럽트 처리 후 문맥을 복구할 수 있도록 현재 실행 프로세스의 현재 문맥을 저장할 필요가 있다
- 문맥은 프로세스의 PCB에 표현
- 문맥 교환 : CPU를 다른 프로세스로 교환하려면 이전 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업
- 문맥 교환 발생 시, 커널은 과거 프로세스의 문맥을 PCB에 저장, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구
- 문맥 교환 시간은 순수한 오버헤드
- 운영체제가 복잡할 수록 문맥교환 시 해야할 작업 양이 많다. 

3. 프로세스에 대한 연산
3.1 프로세스 생성
- 생성하는 프로세스를 부모 프로세스, 새로운 프로세스는 자식 프로세스
- 유일한 프로세스 식별자(pid)를 사용해 구분, 각 프로세스에 고유한 값을 가지도록 할당
- pid가 1인 init 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행
- 프로세스가 자식 프로세스를 생성할 때, 자식 프로세스는 자신의 임무를 달성하기 위해 어떤 자원(CPU 시간, 메모리, 파일, 입출력 장치)이 필요
- 자식 프로세스는 자원을 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한
- 부모 프로세스는 자원을 분할해 자식 프로세스에 나누어 주거나 메모리나 파일 같은 몇몇 자원은 자식 프로세스들이 같이 사용할 수 있다
- 부모 프로세스 자원의 일부분만 사용하도록 자식 프로세스가 쓸 수 있게 제한하며 자식 프로세스들을 많이 생성해 시스템을 과부하 상태로 만드는 프로세스를 방지 할 수 있다

- 프로세스가 새로운 프로세스 생성 시
  - 부모는 자식과 병행하게 실행을 계속한다
  - 부모는 일부 OR 모든 자식이 실행을 종료할 때까지 기다린다
- 새로운 프로세스들의 주소 공간 측면
  - 자식 프로세스는 부모 프로세스의 복사본(부모와 같은 프로그램과 데이터를 가짐)
  - 자식 프로세스가 자신에게 적재될 새로운 프로그램을 갖음
- UNIX 
  - 새로운 프로세스는 fork()로 호출, 원래 프로세스의 주소 공간의 복사본으로 구성
  - 부모 프로세스가 쉽게 자식 프로세스와 통신할 수 있게 한다
  - fork()의 복귀 코드가 서로 다르다
    - 자식 프로세스의 식별자가 부모로 복귀되지만, 새로운 프로세스는 '0'이 복귀된다
  - exec()는 자식의 메모리 공간을 새로운 프로그램으로 교체한다 (동시 실행)
  - 부모는 더 많은 자식을 생성할 수 있고, 자식이 실행하는 동안 할일 없으면, 자식이 종료될 때까지 준비 완료 큐에서 자신을 제거하기 위해 wait() 를 호출한다
  - 자식 프로세스에게 보이는 pid값은 0이고 부모 프로세스에게 보이는 pid값은 0보다 큰 정수값
  - 자식 프로세스는 열린 파일과 같은 자원, 특권, 스케줄링 속성을 부모 프로세스로부터 상속받고 부모는 wait()로 자식 프로세스가 끝나기 기다림
  - 부모와 자식은 같은 코드를 실행하는 병행 실행 프로세스
  - 자식은 부모의 복사본이기에 각 프로세스는 모든 데이터에 대해 자신만의 복사본을 가짐
3.2 프로세스 종료
- exit 시스템 호출을 사용해 운영체제에게 자신의 삭제를 요청하면 종료한다
- 프로세스는 자신의 부모 프로세스에게 상태값을 반환할 수 있고, 물리 메모리, 파일, 입출력 버퍼 등 프로세스의 모든 자원이 운영체제로 반환
- 한 프로세스는 적당 시스템 호출을 통해 다른 프로세스의 종료를 유발할 수 있다(부모만 호출 가능)
  - 부모가 자식의 pid를 알아야 종료시킬 수 있다
  - 새로운 프로세스 생성 시, 새로운 프로세스의 신원이 부모에게 전달된다
- 부모가 자식의 실행을 종료하는 경우
  - 자식이 자신에게 할당된 자원을 초과하여 사용할 때, 부모가 자식들의 상태를 검사할 수 있는 방편이 주어져야함
  - 자식에게 할당된 태스크가 더 이상 필요 없을 때
  - 부모가 exit 하는데, 운영체제는 부모가 exit한 후 자식이 실행을 계속하는 것을 허용하지 않는 경우
- 부모는 wait를 통해 자식 프로세스가 종료할 때를 기다리며 wait는 부모가 자식으이 종료 상태를 얻어낼 수 있도록 하나의 인자를 전달 받음
- wait는 부모가 어느 자식이 종료되었는지 구별할 수 있도록 종료된 자식 프로세스 식별자를 반환
- 좀비 프로세스 : 종료되었지만 부모 프로세스가 아직 wait를 호출하지 않은 프로세스
- 고아 프로세스 : 부모 프로세스가 wait를 호출하는 대신 종료할 때 자식 프로세스 

4. 프로세스간 통신
- 프로세스 협력을 허용하는 환경을 제공하는 이유
  - 정보 공유
  - 계산 가속화 : 병렬 실행
  - 모듈성
  - 편의성
- 협력적 프로세스들은 데이터와 정보를 교환할 수 있는 프로세스간 통신 기법을 필요로 함

 ![ex_screenshot](/res/os17.png) 
 
- 공유 메모리 모델
  - 협력 프로세스들에 의해 공유되는 메모리 영역이 구축
  - 프로세스들은 영역에서 데이터를 읽고 쓰고 함으로 정보를 교환
  - 공유 메모리 영역을 구축할 경우에만 시스템 호출이 필요
  - 메시지 전달 모델 보다 빠르다
  - 캐시 일관성 문제로 인해 성능 저하가 발생할 수 있다
- 메시지 전달 모델 
  - 협력 프로세스들 사이 교환되는 메시지를 통해 통신한다
  - 충돌을 회피할 필요가 없기에 적은 양의 데이터 교환을 하는데 유용
  - 통상 시스템 호출을 사용해 구현되므로 부가적 시간 소비 작업들이 필요로 하기에 공유 메모리 모델 보다 느리다
  - 많은 처리 코어를 가진시스템 사엥서는 메시지 전달이 더 나은 성능을 보인다
- 시스템 처리 코어의 수가 증가할수록 IPC로 메시지 전달이 선호될 수 있다

4.1 공유 메모리 시스템
- 공유 메모리 영역을 구축해야한다
- 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치 
- 통신 시 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야함
4.2 메시지 전달 시스템
- 동일 주소 공간을 공유하지 않고도 프로세스들이 통신하고, 동작을 동기화할 수 있도록 허용하는 기법을 제공
- 프로세스들이 네트워크에 의해 연결된 분산 환경에서 유용하다
- 프로세스 P와 Q가 통신을 원하면 반드시 서로 메시지를 보내고 받아야하며 통신 연결이 설정되어야 한다
- 통신 연결 
  - 직접 통신하에서 통신을 원하는 프로세스는 통신의 수신, 송신자의 이름을 명시해야한다
    - send(P, message) : 프로세스 P에게 메시지를 전송
    - reveive(Q, message) : 프로세스 Q로부터 메시지를 수신
    - 통신을 원하는 각 프로세스의 쌍들 사이 연결이 자동적으로 구축되며 서로 상대방의 신원만 알면 된다
    - 연결은 정확히 두 프로세스들 사이에만 연관
    - 각 쌍 사이에는 정확히 하나의 연결이 존재해야 한다
  - 주소 지정 시 비대칭을 사용하는 경우, 송신자만 수신자 이름을 지명한다
    - send(P, message) : 메시지를 프로세스 P에 전송
    - reveive(id, message) : 임의 프로세스로부터 메시지 수신, 변수 id는 통신을 발생시킨 프로세스의 이름
  -> 두 방법은 결과로 얻어지는 프로세스 정의의 제한된 모듈성이 있는 단점이 있다 
  
  - 간접 통신에서 메시지들은 메일박스 or 포트로 송신되고 수신된다
  - 메일박스는 프로세스들에 이해 메시지들이 넣어지고 제거될 수 있는 객체
  - 각 메일박스는 고유 id를 갖는다 
    - send(A, message) : 메시지를 메일박스 A로 송신
    - receive(A, message) : 메시지를 메일박스 A로부터 수신
    - 한쌍의 프로세스들 사이 연결은 프로세스가 공유 메일박스를 가질 때만 구축된다
    - 연결은 두 개 이상의 프로세스들과 연관될 수 있다
    - 통신하는 각 프로세스들 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다 
  - 메일박스는 한 프로세스 OR 운영체제에 의해 소유될 수 있다
    - 프로세스에 의해 소유될 경우, 소유자와 메일박스 사용자를 구분 할 수 있고 메일 박스를 소유한 프로세스 종료시 메일박스는 사라지며 메일박스로 송신하는 프로세스들은 메일박스가 존재하지 않다는 사실을 통보 받아야 한다
    - 운영체제에 의해 소유한 경우 메일박스는 자체적으로 존재한다 (메일박스 생성, 송수신, 삭제 등을 제공해야함)
  - 메일박스 생성 프로세스는 디폴트로 메일박스의 소유자가 된다 

- 동기화
  - 봉쇄형 보내기 : 송신하는 프로세스는 메시지가 수신 프로세스 OR 메일박스에 의해 수신될 때까지 봉쇄
  - 비봉쇄형 보내기 : 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다
  - 봉쇄형 받기 : 메시지가 이용 가능할 때까지 프로세스 봉쇄
  - 비봉쇄형 받기 : 송신하는 프로세스가 유효한 메시지 또는 NULL을 받음
  - send(), receive()가 모두 봉쇄형일 때, 우리는 송,수신자 간에 랑데부를 갖게된다 
- 버퍼링 
  - 무용량 : 큐의 최대 길이가 0이고, 링크는 자체 안에 대기하는 메시지들을 가질 수 없다 -> 송신자는 수신자가 메시지 수신할 때까지 기다림
  - 유한 용량 : 유한 길이 큐를 가지낟
  - 무한 용량 : 무한한 길이의 큐를 가지고 메시지들은 얼마든지 큐 안에서 대기할 수 있다
6. 클라이언트 서버 환경에서 통신 
6.1 소켓 
- 두 프로세스가 네트워크상에서 통신하려면 양 프로세스 마다 하나씩 소켓이 필요
- 소켓은 IP 주소, 포트 번호 두가지를 접합해 구별
- 클라이언트 프로세스가 연결을 요청하면 호스트 컴퓨터가 포트 번호를 부여
- 두 호스트 사이에 패킷들이 오갈 때 패킷들은 목적지 포트 번호가 지정하는 데 따라 적절한 프로세스로 배달딘다
- 모든 연결은 유일해야하며 모든 연결이 유일한 소켓 쌍으로 구성되는 것을 보장한다 

6.2 원격 프로시저 호출(RPC)
- 메시지 반 통신을 해야한다
- 각 메시지에는 원격지 포트에서 listen 중인 RPC 디먼의 주소가 지정되어 있고 실행되어야 할 함수 식별자, 그 함수에게 전달되어야 할 매개변수가 포함된다
- 네트워크 주소는 하나씩 갖지만 시스템에서 지원되는 여러 서비스를 구별하기 위해 포트를 여러개 가질 수 있다
- 원격 프로세스가 어떤 서비스를 받고자하면 서비스에 대응되는 적절한 포트 주소로 메시지를 보내야함
- RPC는 클라이언트가 원격 호스트 프로시저 호출하는 것을 자기 프로시저 호출 처럼 해준다
- RPC시스템은 클라이언트 쪽에 stub을 제공해 통신하는 데 필요한 자세한 사항들을 숨겨 준다
- 원격 프로시저 마다 다른 stub가 존재한다
- 클라이언트가 원격 프로시저 호출하면 RPC는 대응 stub를 호출하고 원격 프로시저가 필요로한 매개변수를 건네주고 stub가 원격 서버의 포트를 찾고 매개변수를 정돈 한다.
  - 매개 변수 전동 : 프로시저에게 갈 매개변수를 네트워크로 전송하기 위해 적절한  형태로 재구성하는 작업
- stub는 메시지 전달 기법을 사용해 서버에게 메시지를 전송한다.
- 대응 stub가 서버에 존재하여 서버측 stub가 수신후 적절 서버의 프로시저를 호출하고 필요한 경우 반환 값들도 동일 방식으로 되돌려 준다.

- 클라이언트와 서버의 데이터 표현 방식이 다른 경우 RPC 시스템은 기종 중립적인 데이터 표현 방식을 정의한다
  - 클라이언트 측에서 서버에 보내기전 매개변수 정돈 작업의 일환으로 전송 데이터를 XDR 형태로 바꾸어 보냄
  - 수신측에서 XDR을 받으면 매개변수를 풀어 자기 기종의 형태로 데이터 바꾼 후 서버에게로 전잘 
- 호출의 의미
  - 운영체제로 하여금 메시지가 최대 한 번 실행되는 것이 아니라 정확히 한번 처리되도록 보장하게 한다 
    - 응답 메시지 활용
- 클라이언트와 서버간 통신 문제
  - 고정된 포트 주소 형태로 미리 정해 놓는 방법
    - 컴파일 시 RPC에게는 고정된 포트 번호가 주어짐
  - 랑데부 방식에 의해 동적으로 바인딩하는 방법
    - 운영체제는 미리 정해진 고정 RPC 포트를 통해 랑데부용 디먼을 제공
    - 클라이언트가 실행을 원하는 RPC 이름을 담은 메시지를 랑데부 디먼에 보내 RPC 이름에 대응하는 포트 번호가 무엇인지 알려달라 요청
    - 포트 번호가 클라이언트에 반환되고 클라이언트는 포트 번호로 RPC 요청을 계속 보냄

  ![ex_screenshot](/res/os15.png) 
  
  ![ex_screenshot](/res/os16.png) 

6.3 파이프
- 파이프 : 두 프로세스가 통신할 수 있게 하는 전달자로서 동작
- 일반 파이프 : 생산자-소비자 형태로 두 프로세스 간 통신을 허용
  - 생산자는 파이프의 한 종단에 쓰고, 소비자는 다른 종단에서 읽음
  - 한쪽으로만 데이터 전송하며 오직 단반형 통신만 가능
  - 파이프를 생성한 프로세스 이외는 접근 할 수 없다
  - 통상 부모 프로세스가 파이프를 생성하고 fork()로 생성한 자식 프로세스와 통신하기 위해 사용
  - Windows 시스템의 일반 파이프는 익명 파이프라 불린다
  - 동일한 기계 상의 두 프로세스만 통신이 가능!
- 지명 파이프
  - 양방향으로 가능하며 부모-자식 관계도 필요로 하지 않음
  - 지명 파이프가 구축되면 여러 프로세스 들이 통신할 수 있다 
  - UNIX에서 FIFO라 부르며 반이중 전송만이 가능하며, 바이트-단위 통신만 허용
  - Windows는 전이중 통신을 하용하고 두 프로세스는 같은 기계 or 다른 기계 상에 존재할 수 있고, 바이트-단위 or 메시지-단위 데이터 전송 허용

### 스레드 
- 스레드는 CPU 이용의 기본 단위이며 스레드 ID, PC(프로그램 카운터), 레지스터 집합, 스택으로 구성
- 같은 프로세스에 속한 다른 스레드, 코드, 데이터 섹션, 운영체제 자원들을 공유한다
